<!DOCTYPE html> 
<html> 
<head>     <title></title> 
<meta  charset="utf-8" /> 
<meta name="generator" content="TeX4ht (https://tug.org/tex4ht/)" /> 
<meta name="viewport" content="width=device-width,initial-scale=1" /> 
<link rel="stylesheet" type="text/css" href="xSPDE_users_guide.css" /> 
<meta name="src" content="xSPDE_users_guide.tex"> 
<script>window.MathJax = { tex: { tags: "ams", }, }; </script> 
 <script type="text/javascript" async="async" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"></script>  
<meta charset="utf-8"/> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)" /> 
<link rel="stylesheet" type="text/css" href="xSPDE_users_guide.css" /> 
</head><body 
>
<div class="titlepage">
                                                                                
                                                                                
                                                                                
                                                                                
<!--l. 48--><p class="indent" >
                                                                                
                                                                                

<h2 class="titleHead">xSPDE3: The Stochastic Toolbox<br />
User’s Guide<br />
v3.44</h2>
<div class="subtitle"></div>
<div class="tabular"> <table id="TBL-1" class="tabular" 
 
><colgroup id="TBL-1-1g"><col 
id="TBL-1-1"></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-1-1-"><td  style="white-space:nowrap; text-align:center;" id="TBL-1-1-1"  
class="td11"><div class="author" ><span 
class="ec-lmr-12x-x-120">Peter D. Drummond, Ria R. Joseph, Simon Kiesewetter</span></div></td></tr></table>
</div>
<div class="date" ><span 
class="ec-lmr-12x-x-120">December 19, 2022</span></div>
                                                                                
                                                                                
</div>
<!--l. 52--><p class="noindent" ><span 
class="ec-lmbx-10x-x-109">Centre</span>
<span 
class="ec-lmbx-10x-x-109">for</span>
<span 
class="ec-lmbx-10x-x-109">Quantum</span>
<span 
class="ec-lmbx-10x-x-109">Science</span>
<span 
class="ec-lmbx-10x-x-109">and</span>
<span 
class="ec-lmbx-10x-x-109">Technology</span>
<span 
class="ec-lmbx-10x-x-109">Theory,</span>
<span 
class="ec-lmbx-10x-x-109">Swinburne</span>
<span 
class="ec-lmbx-10x-x-109">University</span>
<span 
class="ec-lmbx-10x-x-109">of</span>
<span 
class="ec-lmbx-10x-x-109">Technology,</span>
<span 
class="ec-lmbx-10x-x-109">Melbourne,</span>
<span 
class="ec-lmbx-10x-x-109">Victoria,</span>
<span 
class="ec-lmbx-10x-x-109">Australia.</span><br />
<span 
class="ec-lmbx-10x-x-109">School</span>
<span 
class="ec-lmbx-10x-x-109">of</span>
<span 
class="ec-lmbx-10x-x-109">Information</span>
<span 
class="ec-lmbx-10x-x-109">Technology,</span>
<span 
class="ec-lmbx-10x-x-109">Deakin</span>
<span 
class="ec-lmbx-10x-x-109">University,</span>
<span 
class="ec-lmbx-10x-x-109">Melbourne,</span>
<span 
class="ec-lmbx-10x-x-109">Victoria,</span>
<span 
class="ec-lmbx-10x-x-109">Australia.</span>
                                                                                
                                                                                
                                                                                
                                                                                
<!--l. 54--><p class="indent" >  <a 
 id="chapter*.1"></a>
<!--l. 54--><p class="noindent" >  
<h2 class="likechapterHead"><a 
 id="x1-1000"></a>Contents</h2>
<div class="tableofcontents">  
<span class="chapterToc" >1  <a 
href="#x1-20001" id="QQ2-1-2">Introduction</a></span>
<br />   <span class="sectionToc" >1.1  <a 
href="#x1-30001.1" id="QQ2-1-3">The xSPDE distribution</a></span>
<br />   <span class="sectionToc" >1.2  <a 
href="#x1-40001.2" id="QQ2-1-4">Structure of the user’s guide</a></span>
<br />  <span class="chapterToc" >2  <a 
href="#x1-50002" id="QQ2-1-5">SDE theory</a></span>
<br />   <span class="sectionToc" >2.1  <a 
href="#x1-60002.1" id="QQ2-1-6">General form</a></span>
<br />   <span class="sectionToc" >2.2  <a 
href="#x1-70002.2" id="QQ2-1-7">Stochastic calculus</a></span>
<br />   <span class="sectionToc" >2.3  <a 
href="#x1-80002.3" id="QQ2-1-8">Interaction picture</a></span>
<br />   <span class="sectionToc" >2.4  <a 
href="#x1-90002.4" id="QQ2-1-9">Probability distributions</a></span>
<br />   <span class="sectionToc" >2.5  <a 
href="#x1-110002.5" id="QQ2-1-11">Example: random walk</a></span>
<br />   <span class="sectionToc" >2.6  <a 
href="#x1-130002.6" id="QQ2-1-13">Probability densities</a></span>
<br />   <span class="sectionToc" >2.7  <a 
href="#x1-150002.7" id="QQ2-1-15">Fourier transforms</a></span>
<br />   <span class="sectionToc" >2.8  <a 
href="#x1-170002.8" id="QQ2-1-17">Input-output spectra</a></span>
<br />  <span class="chapterToc" >3  <a 
href="#x1-190003" id="QQ2-1-19">SPDE theory</a></span>
<br />   <span class="sectionToc" >3.1  <a 
href="#x1-200003.1" id="QQ2-1-20">SPDE definitions</a></span>
<br />   <span class="sectionToc" >3.2  <a 
href="#x1-210003.2" id="QQ2-1-21">Boundary conditions</a></span>
<br />   <span class="sectionToc" >3.3  <a 
href="#x1-220003.3" id="QQ2-1-22">Spatial grid and boundary locations</a></span>
<br />   <span class="sectionToc" >3.4  <a 
href="#x1-250003.4" id="QQ2-1-25">Example: multidimensional random walk</a></span>
<br />   <span class="sectionToc" >3.5  <a 
href="#x1-270003.5" id="QQ2-1-27">Interaction picture</a></span>
<br />   <span class="sectionToc" >3.6  <a 
href="#x1-280003.6" id="QQ2-1-28">Fourier transforms</a></span>
<br />   <span class="sectionToc" >3.7  <a 
href="#x1-290003.7" id="QQ2-1-29">Trigonometric transforms</a></span>
<br />   <span class="sectionToc" >3.8  <a 
href="#x1-300003.8" id="QQ2-1-30">Spectral transforms and boundaries</a></span>
<br />   <span class="sectionToc" >3.9  <a 
href="#x1-350003.9" id="QQ2-1-35">Frequency or momentum grid </a></span>
<br />   <span class="sectionToc" >3.10  <a 
href="#x1-360003.10" id="QQ2-1-36">Derivatives</a></span>
<br />  <span class="chapterToc" >4  <a 
href="#x1-420004" id="QQ2-1-42">Solving an SDE </a></span>
<br />   <span class="sectionToc" >4.1  <a 
href="#x1-430004.1" id="QQ2-1-43">Starting with xSPDE</a></span>
<br />   <span class="sectionToc" >4.2  <a 
href="#x1-460004.2" id="QQ2-1-47">Input parameters</a></span>
<br />   <span class="sectionToc" >4.3  <a 
href="#x1-490004.3" id="QQ2-1-50">Fields and noises</a></span>
<br />   <span class="sectionToc" >4.4  <a 
href="#x1-530004.4" id="QQ2-1-54">Advanced random walk</a></span>
<br />   <span class="sectionToc" >4.5  <a 
href="#x1-550004.5" id="QQ2-1-56">Probability binning</a></span>
<br />   <span class="sectionToc" >4.6  <a 
href="#x1-570004.6" id="QQ2-1-58">Time-domain spectra</a></span>
<br />   <span class="sectionToc" >4.7  <a 
href="#x1-590004.7" id="QQ2-1-60">Examples</a></span>
<br />  <span class="chapterToc" >5  <a 
href="#x1-650005" id="QQ2-1-68">Solving an SPDE </a></span>
<br />   <span class="sectionToc" >5.1  <a 
href="#x1-660005.1" id="QQ2-1-69">Multidimensional Wiener process</a></span>
                                                                                
                                                                                
<br />   <span class="sectionToc" >5.2  <a 
href="#x1-670005.2" id="QQ2-1-71">SPDE parameters</a></span>
<br />   <span class="sectionToc" >5.3  <a 
href="#x1-700005.3" id="QQ2-1-74">Next example</a></span>
<br />   <span class="sectionToc" >5.4  <a 
href="#x1-710005.4" id="QQ2-1-76">Transverse lattice</a></span>
<br />   <span class="sectionToc" >5.5  <a 
href="#x1-760005.5" id="QQ2-1-82">Finite differences </a></span>
<br />   <span class="sectionToc" >5.6  <a 
href="#x1-790005.6" id="QQ2-1-86">Boundary conditions</a></span>
<br />   <span class="sectionToc" >5.7  <a 
href="#x1-850005.7" id="QQ2-1-92">Output transforms</a></span>
<br />   <span class="sectionToc" >5.8  <a 
href="#x1-860005.8" id="QQ2-1-93">Initial random fields</a></span>
<br />   <span class="sectionToc" >5.9  <a 
href="#x1-870005.9" id="QQ2-1-94">PDE and SPDE examples</a></span>
<br />   <span class="sectionToc" >5.10  <a 
href="#x1-980005.10" id="QQ2-1-106">Challenge problem #2</a></span>
<br />  <span class="chapterToc" >6  <a 
href="#x1-1000006" id="QQ2-1-108">xSIM and xGRAPH</a></span>
<br />   <span class="sectionToc" >6.1  <a 
href="#x1-1010006.1" id="QQ2-1-109">Batch job workflow</a></span>
<br />   <span class="sectionToc" >6.2  <a 
href="#x1-1020006.2" id="QQ2-1-110">Graphical data</a></span>
<br />   <span class="sectionToc" >6.3  <a 
href="#x1-1030006.3" id="QQ2-1-111">Scanned parameter plots</a></span>
<br />   <span class="sectionToc" >6.4  <a 
href="#x1-1050006.4" id="QQ2-1-114">Project examples</a></span>
<br />   <span class="sectionToc" >6.5  <a 
href="#x1-1100006.5" id="QQ2-1-119">Hints</a></span>
<br />  <span class="chapterToc" >7  <a 
href="#x1-1110007" id="QQ2-1-120">Algorithms</a></span>
<br />   <span class="sectionToc" >7.1  <a 
href="#x1-1120007.1" id="QQ2-1-121">Introduction to algorithms</a></span>
<br />   <span class="sectionToc" >7.2  <a 
href="#x1-1130007.2" id="QQ2-1-122">General differential form</a></span>
<br />   <span class="sectionToc" >7.3  <a 
href="#x1-1140007.3" id="QQ2-1-123">Standard methods</a></span>
<br />   <span class="sectionToc" >7.4  <a 
href="#x1-1210007.4" id="QQ2-1-130">Advanced method libraries</a></span>
<br />   <span class="sectionToc" >7.5  <a 
href="#x1-1230007.5" id="QQ2-1-132">Weighted library</a></span>
<br />   <span class="sectionToc" >7.6  <a 
href="#x1-1250007.6" id="QQ2-1-134"><span 
class="ec-lmri-10x-x-109">Enproj</span>, <span 
class="ec-lmri-10x-x-109">MPproj</span>, <span 
class="ec-lmri-10x-x-109">MPnproj</span>: projection library</a></span>
<br />   <span class="sectionToc" >7.7  <a 
href="#x1-1280007.7" id="QQ2-1-137"><span 
class="ec-lmri-10x-x-109">MPfb</span>: Forward-backward library</a></span>
<br />  <span class="chapterToc" >8  <a 
href="#x1-1300008" id="QQ2-1-139">Integration errors</a></span>
<br />   <span class="sectionToc" >8.1  <a 
href="#x1-1310008.1" id="QQ2-1-140">Discretization errors</a></span>
<br />   <span class="sectionToc" >8.2  <a 
href="#x1-1330008.2" id="QQ2-1-142">Higher order convergence</a></span>
<br />   <span class="sectionToc" >8.3  <a 
href="#x1-1360008.3" id="QQ2-1-145">Statistical errors</a></span>
<br />   <span class="sectionToc" >8.4  <a 
href="#x1-1380008.4" id="QQ2-1-147"><span 
class="ec-lmri-10x-x-109">Convergence tests</span></a></span>
<br />   <span class="sectionToc" >8.5  <a 
href="#x1-1420008.5" id="QQ2-1-151">Chi-squared estimates</a></span>
<br />   <span class="sectionToc" >8.6  <a 
href="#x1-1450008.6" id="QQ2-1-154">Error outputs</a></span>
<br />  <span class="chapterToc" >9  <a 
href="#x1-1520009" id="QQ2-1-161">xSIM reference </a></span>
<br />   <span class="sectionToc" >9.1  <a 
href="#x1-1530009.1" id="QQ2-1-162">Overview</a></span>
<br />   <span class="sectionToc" >9.2  <a 
href="#x1-1560009.2" id="QQ2-1-165">Parameter table</a></span>
<br />   <span class="sectionToc" >9.3  <a 
href="#x1-1570009.3" id="QQ2-1-166">Function tables</a></span>
<br />   <span class="sectionToc" >9.4  <a 
href="#x1-1600009.4" id="QQ2-1-169">Parameter reference</a></span>
<br />   <span class="sectionToc" >9.5  <a 
href="#x1-1890009.5" id="QQ2-1-198">Function reference </a></span>
<br />   <span class="sectionToc" >9.6  <a 
href="#x1-2090009.6" id="QQ2-1-218">Internal function reference</a></span>
<br />   <span class="sectionToc" >9.7  <a 
href="#x1-2150009.7" id="QQ2-1-224">Arrays and indices</a></span>
<br />   <span class="sectionToc" >9.8  <a 
href="#x1-2180009.8" id="QQ2-1-227">Internal parameter table</a></span>
<br />   <span class="sectionToc" >9.9  <a 
href="#x1-2190009.9" id="QQ2-1-228">xSIM overall structure</a></span>
<br />  <span class="chapterToc" >10  <a 
href="#x1-22200010" id="QQ2-1-231">xGRAPH reference</a></span>
<br />   <span class="sectionToc" >10.1  <a 
href="#x1-22300010.1" id="QQ2-1-232">Overview</a></span>
<br />   <span class="sectionToc" >10.2  <a 
href="#x1-22500010.2" id="QQ2-1-234">Parameter table</a></span>
<br />   <span class="sectionToc" >10.3  <a 
href="#x1-22600010.3" id="QQ2-1-235">Example</a></span>
                                                                                
                                                                                
<br />   <span class="sectionToc" >10.4  <a 
href="#x1-22700010.4" id="QQ2-1-237">xGRAPH data arrays</a></span>
<br />   <span class="sectionToc" >10.5  <a 
href="#x1-22900010.5" id="QQ2-1-239">xGRAPH output graphs</a></span>
<br />   <span class="sectionToc" >10.6  <a 
href="#x1-23200010.6" id="QQ2-1-242">Probability and \(\chi ^{2}\) plots</a></span>
<br />   <span class="sectionToc" >10.7  <a 
href="#x1-23300010.7" id="QQ2-1-243">Parameter reference</a></span>
<br />   <span class="sectionToc" >10.8  <a 
href="#x1-26000010.8" id="QQ2-1-270">User function reference</a></span>
<br />   <span class="sectionToc" >10.9  <a 
href="#x1-26300010.9" id="QQ2-1-273">xGRAPH structure</a></span>
<br />  <span class="chapterToc" >11  <a 
href="#x1-26600011" id="QQ2-1-276">Examples</a></span>
<br />   <span class="sectionToc" >11.1  <a 
href="#x1-26700011.1" id="QQ2-1-277">SDE examples</a></span>
<br />   <span class="sectionToc" >11.2  <a 
href="#x1-27200011.2" id="QQ2-1-284">Spectral examples</a></span>
<br />   <span class="sectionToc" >11.3  <a 
href="#x1-27700011.3" id="QQ2-1-291">Probability examples</a></span>
<br />   <span class="sectionToc" >11.4  <a 
href="#x1-28000011.4" id="QQ2-1-296">SPDE examples</a></span>
<br />   <span class="sectionToc" >11.5  <a 
href="#x1-29400011.5" id="QQ2-1-316">Projection examples</a></span>
</div>
                                                                                
                                                                                
                                                                                
                                                                                
  
<h2 class="chapterHead"><span class="titlemark">1</span>  <a 
 id="x1-20001"></a>Introduction</h2>
<!--l. 58--><p class="noindent" >
  
<h3 class="sectionHead"><span class="titlemark">1.1</span>  <a 
 id="x1-30001.1"></a>The xSPDE distribution</h3>
<!--l. 63--><p class="noindent" ><span 
class="ec-lmbxi-10x-x-109">The stochastic toolbox is an eXtensible Stochastic Partial Differential Equation</span>
<span 
class="ec-lmbxi-10x-x-109">solver </span><span class="cite">[<a 
href="#Xkiesewetter2016xspde">1</a>]</span><a 
 id="x1-3001"></a>.
<!--l. 65--><p class="indent" >  xSPDE has functions that can numerically solve both ordinary and partial differential
stochastic equations of any type, obtaining correlations, probabilities and averages. There are
many equations of this type <span class="cite">[<a 
href="#XLangevin1908-theorie">2</a>, <a 
href="#XKaratzas1991-brownian">3</a>, <a 
href="#Xgardinerhandbook2004">4</a>, <a 
href="#XGlasserman2010-monte">5</a>, <a 
href="#XDrummond2014">6</a>]</span><a 
 id="x1-3002"></a> in diverse areas of physics, chemistry, engineering,
biology, medicine, and finance.
<!--l. 72--><p class="indent" >  The examples given are focused mostly on physics and quantum technology, but the code is
designed to have general applicability. The emphasis in xSPDE is on combining a very simple
user interface with an extremely wide range of useful functions. Importantly, this includes the
essential features of averaging and global error estimates for the averages. The code enables an
efficient use memory and parallelism, which is vital for large stochastic models, and it is able
to be further extended if needed.
<!--l. 81--><p class="indent" >  The extensible structure of the code-base permits drop-in replacements of the algorithms.
Different simulations can be carried out sequentially. This models different stages in an
experiment or simulated environment. It can be used with or without noise terms,
and can use a range of either built-in or user defined integration algorithms. This
user guide describes xSPDE3, which is an improved version of an earlier toolbox
<span class="cite">[<a 
href="#Xkiesewetter2016xspde">1</a>]</span>.
<!--l. 89--><p class="indent" >  xSPDE calculates and plots averages and probabilities of arbitrary functions of any number
of complex or real fields, as well as Fourier transforms in time or space with any
given dimensionality. Importantly, it gives error estimates for the discretization and
sampling error, but control of the step-size and number of samples used is up to the
user.
<!--l. 96--><p class="indent" >  Ordinary and stochastic differential equations of many types can be treated numerically
<span class="cite">[<a 
href="#XDrummond1991">7</a>, <a 
href="#XKloeden1992">8</a>]</span><a 
 id="x1-3003"></a>, including stochastic partial differential equations with space dependence <span class="cite">[<a 
href="#XWerner1997">9</a>]</span><a 
 id="x1-3004"></a>.
Comparative \(\chi ^{2}\) statistical tests are available. Additional libraries exist for projected,
forward-backward, and weighted equations.
<!--l. 102--><p class="indent" >  The algorithms included are designed to be useful and fast in many practical
applications. Higher order convergence is obtained through order extrapolation. This allows
higher-order convergence to be realized in a uniform way. More complex higher-order
algorithms are known <span class="cite">[<a 
href="#XKloeden1992">8</a>, <a 
href="#Xburrage2006comment">10</a>]</span><a 
 id="x1-3005"></a>, which can be included if preferred, as the code is
extensible.
<!--l. 108--><p class="indent" >  The code can be used interactively or in batch mode. All graphs, data, and input
parameters, including default values, can be stored permanently using standard
file-types. It has a fully integrated graphics program, xGRAPH. This is able to handle
data of any dimensions, with multiple types of graphical output, error-bars and
comparisons.
<!--l. 114--><p class="indent" >  xSPDE supports parallelism at both multiple core and vector instruction level using array
syntax and <span 
class="ec-lmri-10x-x-109">parfor </span>loops. This version is Octave/Matlab based. Matlab is a commercial
                                                                                
                                                                                
product, Octave is free and open-source. They each have excellent user interfaces and
reliable implementations. Full parallel operation currently requires the Matlab parallel
toolbox.
<!--l. 121--><p class="indent" >  Using the toolbox can be compared to dining in a very friendly restaurant. It allows
you to choose recipes from a large menu. It does the work of solving equations and
doing averages. Estimating errors and graphing results is carried out as well. But
it has a communal kitchen too. If you want more choice, you can add your own
dishes.
<!--l. 127--><p class="indent" >  See: <span 
class="ec-lmbx-10x-x-109">www.github.com/peterddrummond/xspde</span><span 
class="ec-lmbx-10x-x-109">_matlab.</span>
<!--l. 129--><p class="indent" >  If this Octave/Matlab distribution doesn’t suit, a somewhat faster but not as extensive
open-source alternative is available in C++ at http://www.xmds.org/.
<!--l. 134--><p class="indent" >  <span 
class="ec-lmri-10x-x-109">xSPDE is distributed without any guarantee, under an open-source license. Contributions</span>
<span 
class="ec-lmri-10x-x-109">and bug reports are always welcome.</span>
<!--l. 136--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">1.2</span>  <a 
 id="x1-40001.2"></a>Structure of the user’s guide</h3>
<!--l. 138--><p class="noindent" >Sections <a 
href="#x1-50002">2<!--tex4ht:ref: sec:SDE Theory --></a> and <a 
href="#x1-190003">3<!--tex4ht:ref: sec:SPDE Theory --></a> give background information. Expert readers simply interested in how to use
the code can go directly to section <a 
href="#x1-420004">4<!--tex4ht:ref: sec:Simulating-an-SDE --></a>.
<!--l. 142--><p class="indent" >  Section <a 
href="#x1-50002">2<!--tex4ht:ref: sec:SDE Theory --></a> has definitions and notations for stochastic differential equations (SDEs). This is
especially useful for understanding later sections. The section includes Ito and Stratonovich
calculus, probability distributions and Fokker-Planck equations. It also explains and defines
the Fourier input-output spectra used in quantum technology.
<!--l. 148--><p class="indent" >  Section <a 
href="#x1-190003">3<!--tex4ht:ref: sec:SPDE Theory --></a> gives the concepts of stochastic partial differential equations (SPDEs). It
includes details of spectral methods and the interaction picture approach. It has an
explanation of how Fourier transforms and discrete sine or cosine transforms are
implemented. It also explains how boundary conditions can be implemented using finite
differences.
<!--l. 155--><p class="indent" >  Section <a 
href="#x1-420004">4<!--tex4ht:ref: sec:Simulating-an-SDE --></a> describes the numerical solution of SDEs with xSPDE. This includes an
explanation of the user interface, how to input parameters and equations, and how
to define the output in terms of functional averages or probabilities. This section
uses the default algorithms, because a more detailed explanation is given in section
<a 
href="#x1-1110007">7<!--tex4ht:ref: sec:Algorithms --></a>.
<!--l. 162--><p class="indent" >  In section <a 
href="#x1-650005">5<!--tex4ht:ref: sec:Simulating-an-SPDE --></a>, the practical approach to solving stochastic partial differential equations with
xSPDE is explained. The techniques used in section <a 
href="#x1-650005">5<!--tex4ht:ref: sec:Simulating-an-SPDE --></a> are an extension of the previous one, so
a thorough understanding of section <a 
href="#x1-420004">4<!--tex4ht:ref: sec:Simulating-an-SDE --></a> is strongly recommended. Both sections contain a
number of examples. Section <a 
href="#x1-1000006">6<!--tex4ht:ref: sec:Projects:-xSIM-and --></a> explains how to create projects and provides some insight into
workflow and data storage issues.
<!--l. 170--><p class="indent" >  Section <a 
href="#x1-1110007">7<!--tex4ht:ref: sec:Algorithms --></a> outlines the integration algorithms used in the manual. It includes a number of
extended integration libraries, applicable to more specialized problems. Section <a 
href="#x1-1300008">8<!--tex4ht:ref: sec:Integration-errors --></a> outlines how
integration errors, including time-step and stochastic errors, can be estimated and
displayed.
                                                                                
                                                                                
<!--l. 176--><p class="indent" >  Section <a 
href="#x1-1520009">9<!--tex4ht:ref: sec:xSIM-reference --></a> provides a reference for the details of the internals as well as a comprehensive
explanation of the input parameters useful in xSPDE simulations. Section <a 
href="#x1-22200010">10<!--tex4ht:ref: sec:xGRAPH-reference --></a> provides an
extensive description of the visualization aspects of xSPDE, using the integrated xGRAPH
function. This includes an automatic ’waterfall’ of graphic output, where data of
arbitrary dimensions can be reduced to visualizable graphs through dimensional
reductions.
<!--l. 184--><p class="indent" >  Input parameters related to this are described as well. Data can also be graphed externally
or stored for later analysis if preferred. Both average and raw trajectory data can be
stored. However, the storage of raw data is generally not recommended, due to the
large storage requirements. Additional examples in section <a 
href="#x1-26600011">11<!--tex4ht:ref: sec:Examples --></a> demonstrate how to
obtain parametric plots against input parameters. Plots of one component value
against another can be graphed. A function that analyses convergence rates is also
available.
<!--l. 193--><p class="indent" >
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
  
<h2 class="chapterHead"><span class="titlemark">2</span>  <a 
 id="x1-50002"></a>SDE theory</h2>
<!--l. 199--><p class="noindent" ><span 
class="ec-lmbxi-10x-x-109">This section describes the basics of stochastic differential equation (SDE) theory,</span>
<span 
class="ec-lmbxi-10x-x-109">in order to explain the background to the numerical methods.</span>
  
<h3 class="sectionHead"><span class="titlemark">2.1</span>  <a 
 id="x1-60002.1"></a>General form</h3>
<!--l. 203--><p class="noindent" >A stochastic differential equation (SDE) is an equation with random noise terms <span class="cite">[<a 
href="#Xgardinerhandbook2004">4</a>, <a 
href="#XDrummond2014">6</a>]</span><a 
 id="x1-6001"></a>. These
occur in many fields of biology, chemistry, engineering, economics, physics, meteorology and
other disciplines. An ordinary stochastic differential equation in one time dimension
is,
<!--l. 211--><p class="indent" >  \begin {equation}  \frac {\partial \mathbf {a}}{\partial t}=\mathbf {A}\left (\mathbf {a},t\right )+\underline {\mathbf {B}}\left (\mathbf {a},t\right )\cdot \mathbf {w}(t)\,.\label {eq:SDE}  \end {equation}
Here \(\mathbf {a}\) is a real or complex vector, \(\mathbf {A}\) is a vector function, \(\underline {\mathbf {B}}\) a matrix function and \(\mathbf {w}\) is usually a
delta-correlated real Gaussian noise vector: <div class="eqnarray">\begin {eqnarray}  \left \langle w_{i}\left (t\right )w_{j}\left (t'\right )\right \rangle &amp; = &amp; \delta \left (t-t'\right )\delta _{ij}.\label {eq:noise-correlations}  \end {eqnarray}
</div>
<!--l. 219--><p class="indent" >  One can also have non-Gaussian noise or noise that is not delta-correlated. Although
these are somewhat less commonly treated, these alternatives are often found in real
applications.
<!--l. 223--><p class="indent" >  In all cases, there are multiple independent trajectories, and one is interested in
probabilistic averages, where the unweighted average of an observable \(\mathbf {O}\left (\mathbf {a}\right )\), for \(N_{s}\) trajectories \(\mathbf {a}^{\left (n\right )}\) is:
<div class="eqnarray">\begin {eqnarray}  \left \langle \mathbf {O}\right \rangle _{N_{s}} &amp; = &amp; \frac {1}{N_{s}}\sum _{n}\mathbf {O}\left (\mathbf {a}^{\left (n\right )}\right ).\label {eq:averages-1}  \end {eqnarray}
</div>
<!--l. 231--><p class="indent" >  In some types of stochastic equation, there is a weight \(\Omega \left (t\right )\) for each trajectory. This has an
additional equation of motion, where:
<!--l. 236--><p class="indent" >  \begin {equation}  \frac {\partial \Omega }{\partial t}=A_{\Omega }\left (\mathbf {a},\Omega ,t\right )+\underline {B}_{\Omega }\left (\mathbf {a},\Omega ,t\right )\cdot \mathbf {w}(t)\,.\label {eq:SDE-2}  \end {equation}
<!--l. 238--><p class="indent" >  The results for all mean values are then weighted by the term \(\exp \left (\Omega \left (t\right )\right )\), so that: \begin {equation}  \left \langle \mathbf {O}\right \rangle _{\Omega }=\frac {\sum _{n}\mathbf {O}\left (\mathbf {a}^{\left (n\right )}\right )\exp \left (\Omega ^{\left (n\right )}\left (t\right )\right )}{\sum _{n}\exp \left (\Omega ^{\left (n\right )}\left (t\right )\right )}.\label {eq:Weighted-averages-1}  \end {equation}
This expression reduces to the usual average if the weights are zero, i.e, \(\Omega =0\). Apart from the way
that averages are treated, the weight can simply be regarded as an additional term in the
stochastic differential equations. This simply means that one now has an equation with an
extra random field, so that \(\mathbf {a}\rightarrow \left [\mathbf {a},\Omega \right ]\), together with a modified expression for the averages. This, in
fact, is how these equations are solved.
<!--l. 251--><p class="indent" >  For reasons of efficiency, it is best to use “breeding” algorithms to treat these
numerically. This replicates highly weighted trajectories with \(\Omega ^{\left (n\right )}\left (t\right )\gg 0\) and removes trajectories
with \(\Omega ^{\left (n\right )}\ll 0\), that have negligible weight. The numerical method is described in section
<a 
href="#x1-1110007">7<!--tex4ht:ref: sec:Algorithms --></a>.
<!--l. 257--><p class="indent" >  The remainder of this section will focus on the most commonly treated case of unweighted,
Gaussian, delta-correlated noise.
<!--l. 260--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">2.2</span>  <a 
 id="x1-70002.2"></a>Stochastic calculus</h3>
<!--l. 262--><p class="noindent" >In the case of delta-correlated noise, the trajectories are not differentiable. As a result, there
                                                                                
                                                                                
are two variants of stochastic calculus used to define the derivatives, called Ito or
Stratonovich <span class="cite">[<a 
href="#XArnold1992-stochastic">11</a>, <a 
href="#Xgardinerhandbook2004">4</a>]</span><a 
 id="x1-7001"></a>. xSPDE can be used for either type. The default algorithms are
designed for Stratonovich cases, since this is just ordinary calculus. Ito calculus
can be treated also, either using a directly applicable method, or by appropriate
transformations.
<!--l. 270--><p class="indent" >  A single step in time of duration \(\Delta t\) uses finite noises \(\mathbf {w}\) which are defined to be delta-correlated
in the small time-step limit: <div class="eqnarray">\begin {eqnarray}  \left \langle w_{i}w_{j}\right \rangle &amp; = &amp; \delta _{ij}/\Delta t.\label {eq:noise-correlations-1}  \end {eqnarray}
</div>
<!--l. 276--><p class="indent" >  The limits as \(\Delta t\rightarrow 0\) are taken differently for the two types of stochastic calculus. Let \(\mathbf {a}_{0}=\mathbf {a}\left (t\right )\), \(\bar {\mathbf {a}}=\left (\mathbf {a}\left (t+\Delta t\right )+\mathbf {a}_{0}\right )/2\), and \(\bar {t}=t+\Delta t/2\), then
the next step in time is:
<ul class="itemize1">     
<li class="itemize">
<!--l. 281--><p class="noindent" >Stratonovich calculus - uses <span 
class="ec-lmbx-10x-x-109">midpoint </span>derivative evaluations</li></ul>

<!--l. 285--><p class="noindent" >\begin {equation}  \mathbf {a}\left (t+\Delta t\right )=\mathbf {a}_{0}+\left [\mathbf {A}\left (\bar {\mathbf {a}},\bar {t}\right )+\underline {\mathbf {B}}\left (\bar {\mathbf {a}},\bar {t}\right )\cdot \mathbf {w}\right ]\,\Delta t\,.\label {eq:SDE-1-1}  \end {equation}     
<ul class="itemize1">
<li class="itemize">     
<!--l. 288--><p class="noindent" >Ito calculus - uses <span 
class="ec-lmbx-10x-x-109">initial </span>derivative evaluations</li></ul>

<!--l. 292--><p class="noindent" >\begin {equation}  \mathbf {a}\left (t+\Delta t\right )=\mathbf {a}_{0}+\left [\mathbf {A}^{(I)}\left (\mathbf {a}_{0},t\right )+\underline {\mathbf {B}}\left (\mathbf {a}_{0},t\right )\cdot \mathbf {w}\right ]\,\Delta t\,\,.\label {eq:SDE-1}  \end {equation}
The drift term \(\mathbf {A}\) is changed in Ito calculus, if the noise coefficient \(B\) depends on the stochastic
variable: \begin {equation}  A_{i}^{(I)}=A_{i}+\frac {1}{2}B_{jk}\partial _{j}B_{ik}.  \end {equation}
<!--l. 299--><p class="indent" >  Here we define \(\partial _{n}\equiv \partial /\partial a_{n}\) and we use an Einstein convention of summing over all repeated
indices.
<!--l. 302--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">2.3</span>  <a 
 id="x1-80002.3"></a>Interaction picture</h3>
<!--l. 304--><p class="noindent" >The interaction picture allows one to eliminate linear terms in the time derivatives. It is
especially useful for stochastic partial differential equations, but it is applicable
to stochastic equations as well. Suppose there are linear terms \(\underline {\mathbf {L}}\), so that \(\mathbf {A}\left (\mathbf {a},t\right )=\mathbf {A}_{1}\left (\mathbf {a},t\right )+\underline {\mathbf {L}}\cdot \mathbf {a}\,\), where \(\underline {\mathbf {L}}\)
is a constant matrix. The interaction picture defines local variables \(\tilde {\mathbf {a}}\) for the fields
\(\mathbf {a}\).
<!--l. 312--><p class="indent" >  It is convenient to introduce an abbreviated notation as: \begin {equation}  \begin {split}\begin {aligned}D\left (\mathbf {a}\right )=\mathbf {A}_{1}\left (\mathbf {a},t\right )+\underline {\mathbf {B}}\left (\mathbf {a},t\right )\cdot \mathbf {w}(\mathbf {r})\end {aligned} \end {split} \label {eq:deriv_without_linear_term-1}  \end {equation}
Hence, we can write the differential equation as: \begin {equation}  \begin {split}\frac {\partial \mathbf {a}}{\partial t}=D\left (\mathbf {a}\right )+\underline {\mathbf {L}}\cdot \mathbf {a}.\end {split}  \end {equation}
Next, we define a linear propagator. This is given formally by: \begin {equation}  \begin {split}\underline {\mathbf {P}}\left (\Delta t\right )=\exp \left (\Delta t\underline {\mathbf {L}}\right )\end {split} .  \end {equation}
where \(\Delta t=t-\bar {t}\), and \(\bar {t}\) is the interaction picture origin. Transforming the field \(\mathbf {a}\) to an interaction picture
is achieved on defining: \begin {equation}  \tilde {\mathbf {a}}=\underline {\mathbf {P}}^{-1}\left (\Delta t\right )\cdot \mathbf {a}  \end {equation}
                                                                                
                                                                                
As a result, the equation of motion is: \begin {equation}  \begin {split}\frac {\partial \tilde {\mathbf {a}}}{\partial t}=D\left (\underline {\mathbf {P}}\left (\Delta t\right )\cdot \tilde {\mathbf {a}}\right ).\end {split}  \end {equation}
<!--l. 338--><p class="indent" >  This removes linear terms, which can cause stiffness in the equations, increasing the
discretization error. Given the case of a completely linear ODE, the solutions will be exact up
to round-off errors.
<!--l. 342--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">2.4</span>  <a 
 id="x1-90002.4"></a>Probability distributions</h3>
<!--l. 344--><p class="noindent" >Stochastic equations generate trajectories distributed with a probability density \(P\left (\mathbf {a}\right )\).
These can be defined as an average and hence can be evaluated stochastically, since:
\begin {equation}  P\left (\mathbf {a}'\right )=\left \langle \delta \left (\mathbf {a}'-\mathbf {a}\right )\right \rangle .  \end {equation}
Here \(\left \langle ..\right \rangle \equiv \left \langle ..\right \rangle _{\infty }\) is the infinite ensemble limit of the average over many trajectories. The probability can
be shown to follow a Fokker-Planck equation <span class="cite">[<a 
href="#XRisken1996">12</a>]</span><a 
 id="x1-9001"></a>: \begin {equation}  \frac {\partial P}{\partial t}=\mathcal {L}P=\left [-\partial _{n}A_{n}^{(I)}+\frac {1}{2}\partial _{n}\partial _{m}B_{nk}B_{mk}\right ]P\,,\label {eq:FPE}  \end {equation}
where the differential operators act on all terms to their right.
<!--l. 358--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">2.4.1</span>  <a 
 id="x1-100002.4.1"></a>Distribution averages</h4>
<!--l. 360--><p class="noindent" >The average of any observable \(\mathbf {O}\left (\mathbf {a}\right )\) is obtained either by averaging over the stochastic trajectories
numerically, or by analytic calculations, using: <div class="eqnarray">\begin {eqnarray}  \left \langle \mathbf {O}\right \rangle &amp; = &amp; \int \mathbf {O}\left (\mathbf {a}\right )P\left (\mathbf {a}\right )d\mathbf {a}.\label {eq:averages}  \end {eqnarray}
</div>
<!--l. 367--><p class="indent" >  The dynamics of an observable or moment follows an adjoint equation, where \(\tilde {\mathcal {L}}\) is the adjoint
of \(\mathcal {L}\): \begin {equation}  \left \langle \frac {\partial \mathbf {O}}{\partial t}\right \rangle =\left \langle \tilde {\mathcal {L}}\mathbf {O}\right \rangle .\label {eq:moment_equn}  \end {equation}
where: \begin {equation}  \left \langle \tilde {\mathcal {L}}\mathbf {O}\right \rangle =\left \langle \left [A_{n}^{(I)}\partial _{n}+\frac {1}{2}B_{nk}B_{mk}\partial _{n}\partial _{m}\right ]\mathbf {O}\right \rangle .  \end {equation}
This equation allows the time-evolution of averages to be calculated analytically in simple
cases, given an initial distribution. However, in more complex cases, a numerical simulation of
the stochastic equations is more practical, and this can be carried out with xSPDE or other
software.
<!--l. 382--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">2.5</span>  <a 
 id="x1-110002.5"></a>Example: random walk</h3>
<!--l. 384--><p class="noindent" >The first example of an SDE is the simplest possible stochastic equation or Wiener process: \begin {equation}  \dot {a}=w(t)\,.\label {eq:Wiener_process}  \end {equation}
<!--l. 390--><p class="indent" >  This has the solution that \begin {equation}  a\left (t\right )=a\left (0\right )+\int _{0}^{t}w\left (\tau \right )d\tau ,  \end {equation}
which means that the initial mean value does not change in time: \begin {equation}  \left \langle a\left (t\right )\right \rangle =\left \langle a\left (0\right )\right \rangle .\label {eq:Wiener_mean}  \end {equation}
                                                                                
                                                                                
<!--l. 400--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">2.5.1</span>  <a 
 id="x1-120002.5.1"></a>Variance solution</h4>
<!--l. 402--><p class="noindent" >The noise correlation is non-vanishing from Eq \eqref{eq:noise-correlations}, so the variance
must increase with time: \begin {align}  \left \langle a^{2}\left (t\right )\right \rangle &amp; =\left \langle a^{2}\left (0\right )\right \rangle +\int _{0}^{t}\int _{0}^{t}\left \langle w\left (\tau \right )w\left (\tau '\right )\right \rangle d\tau d\tau '\nonumber \\ &amp; =\left \langle a^{2}\left (0\right )\right \rangle +\int _{0}^{t}\int _{0}^{t}\delta \left (\tau -\tau '\right )d\tau d\tau '.  \end {align}
<!--l. 409--><p class="indent" >  Integrating the delta function gives unity, which means that the second moment and the
variance both increase linearly with time:
<!--l. 415--><p class="indent" >  \begin {align}  \left \langle a^{2}\left (t\right )\right \rangle &amp; =\left \langle a^{2}\left (0\right )\right \rangle +\int _{0}^{t}d\tau \nonumber \\ &amp; =\left \langle a^{2}\left (0\right )\right \rangle +t.\label {eq:Wiener_mean_square}  \end {align}
<!--l. 417--><p class="indent" >  The probability follows an elementary diffusion equation: \begin {equation}  \frac {\partial P}{\partial t}=\frac {1}{2}\frac {\partial ^{2}P}{\partial a^{2}}\,,\label {eq:FPE-1}  \end {equation}
which is an example of Eq \eqref{eq:FPE}. From this equation and using Eq
\eqref{eq:moment_equn}, the first two corresponding moment equations in this case are \begin {align}  \frac {\partial }{\partial t}\left \langle a\right \rangle = &amp; \left \langle \frac {1}{2}\frac {\partial ^{2}}{\partial a^{2}}a\,\right \rangle =0\nonumber \\ \frac {\partial }{\partial t}\left \langle a^{2}\right \rangle = &amp; \left \langle \frac {1}{2}\frac {\partial ^{2}}{\partial a^{2}}a^{2}\,\right \rangle =1  \end {align}
<!--l. 429--><p class="indent" >  These differential equations are satisfied by the solutions obtained directly from the stochastic
equations, namely Eq \eqref{eq:Wiener_mean} and Eq \eqref{eq:Wiener_mean_square}.
<!--l. 433--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">2.6</span>  <a 
 id="x1-130002.6"></a>Probability densities</h3>
<!--l. 435--><p class="noindent" >The Wiener process with an arbitrary noise strength has the stochastic equation: \begin {equation}  \dot {a}=bw\left (t\right ).  \end {equation}
<!--l. 441--><p class="indent" >  The probability density satisfies the Fokker-Planck equation for diffusion, \begin {equation}  \frac {\partial P}{\partial t}=\frac {b^{2}}{2}\frac {\partial ^{2}}{\partial a^{2}}P\,.  \end {equation}
<!--l. 446--><p class="indent" >  Then, if \(x\) initially is Gaussian distributed, this has a Gaussian distribution at time \(t\) with: \begin {equation}  P\left (a\right )=\frac {1}{\sqrt {2\pi \sigma ^{2}\left (t\right )}}\exp \left [-\frac {\left (a-\bar {a}\left (t\right )\right )^{2}}{2\sigma ^{2}\left (t\right )}\right ].  \end {equation}
<!--l. 452--><p class="indent" >  Here: \begin {align}  \bar {a}\left (t\right ) &amp; =\bar {a}\left (0\right )\\ \sigma ^{2}\left (t\right ) &amp; =\sigma ^{2}\left (0\right )+b^{2}t\nonumber  \end {align}
<!--l. 459--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">2.6.1</span>  <a 
 id="x1-140002.6.1"></a>Distributions of functions</h4>
<!--l. 461--><p class="noindent" >Any function of the stochastic variables has a corresponding probability density. For example,
the distribution of \(a^{2}\) has a \(\chi ^{2}\) distribution with a single degree of freedom, such that if \(y=\left (a-\bar {a}\left (t\right )\right )^{2}/\sigma ^{2}\left (t\right )\),
then:
                                                                                
                                                                                
<!--l. 468--><p class="indent" >  \begin {equation}  P\left (y\right )=\frac {1}{\sqrt {2\pi y}}\exp \left [-\frac {y}{2}\right ].  \end {equation}
Hence: \begin {equation}  P\left (a^{2}\right )=\frac {1}{\left |a-\bar {a}\left (t\right )\right |\sqrt {2\pi \sigma ^{2}\left (t\right )}}\exp \left [-\frac {\left (a-\bar {a}\left (t\right )\right )^{2}}{2\sigma ^{2}\left (t\right )}\right ]  \end {equation}
<!--l. 474--><p class="indent" >  More generally, it is often not known what the exact analytic solutions are, and a numerical
solution is employed. This can either use the stochastic equation directly, or the Fokker-Planck
equation, although it is generally difficult to scale this to many variables or to partial
differential equations,
<!--l. 480--><p class="indent" >  That is why we focus on the stochastic equation approach here, which can be used to
numerically calculate either the mean values or the probability distributions in general
cases.
<!--l. 484--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">2.7</span>  <a 
 id="x1-150002.7"></a>Fourier transforms</h3>
<!--l. 486--><p class="noindent" >Frequency spectra have many uses, especially for understanding the steady-state
fluctuations of any physical system in the presence of noise, typically either thermal or
quantum-mechanical, although the noise could have other sources.
<!--l. 491--><p class="indent" >  The time-domain spectral definition used here is: \begin {align}  \tilde {a}(\omega ) &amp; =\frac {1}{\sqrt {2\pi }}\int e^{i\omega t}a(t)dt\,\nonumber \\ a(t) &amp; =\frac {1}{\sqrt {2\pi }}\int e^{-i\omega t}\tilde {a}(\omega )d\omega .\,  \end {align}
<!--l. 497--><p class="indent" >  As a simple example, a sinusoidal oscillation in the form \begin {equation}  a(t)=\cos \left (\omega _{0}t\right )  \end {equation}
between \(t=-T/2\) and \(t=T/2\) has a Fourier transform given by: \begin {align}  \tilde {a}(\omega ) &amp; =\frac {1}{2\sqrt {2\pi }}\int _{-T/2}^{T/2}\left [e^{i\left (\omega -\omega _{0}\right )t}+e^{i\left (\omega +\omega _{0}\right )t}\right ]dt\,\\ &amp; =\frac {T}{2\sqrt {2\pi }}\left [sinc\left (\left (\omega -\omega _{0}\right )\frac {T}{2}\right )+sinc\left (\left (\omega +\omega _{0}\right )\frac {T}{2}\right )\right ]\nonumber  \end {align}
<!--l. 507--><p class="indent" >  While exact, this is rather impractical. In taking measurements and doing simulations, one
has a discrete set of data-points. Assuming the samples are at fixed intervals, the nearest one
can do in practical cases is a discrete Fourier transform, with discrete samples \(\bar {a}(t_{j})\) that are
defined as integrals over each small interval \(dt\):
<!--l. 513--><p class="indent" >  Let \(\bar {a}(t_{j})\) be the average over a small time interval: \begin {equation}  \bar {a}(t_{j})=\int _{t_{j}-dt/2}^{t_{j}+dt/2}e^{i\omega t}a(t)dt\,,\label {eq:field-average}  \end {equation}
then to a good approximation as \(dt\rightarrow 0\), provided \(\omega _{n}\) is not too large, \begin {align}  \tilde {a}(\omega _{n}) &amp; =\frac {\Delta t}{\sqrt {2\pi }}\sum _{j=1}^{N}e^{i\omega _{n}t_{j}}\bar {a}(t_{j})\,\nonumber \\ \bar {a}(t_{j}) &amp; =\frac {\Delta \omega }{\sqrt {2\pi }}\sum _{n=1}^{N}e^{-i\omega _{n}t_{j}}\tilde {a}(\omega _{n})\,  \end {align}
<!--l. 524--><p class="indent" >  These also form an invertible pair provided that \(\Delta t\Delta \omega =2\pi /N\). As well as being more practical, this is
very efficient due to the fast Cooley-Tukey (FFT) algorithm, allowing computation on
time-scales of \(O\left (N\ln N\right )\) rather than \(O\left (N^{2}\right )\) as one might expect.
<!--l. 530--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">2.7.1</span>  <a 
 id="x1-160002.7.1"></a>Damped random walk</h4>
<!--l. 532--><p class="noindent" >As an example, take the damped quantum harmonic oscillator, as described by a random walk
in a complex space, \begin {equation}  \frac {da}{dt}=-a+\zeta (t)  \end {equation}
where the noise is complex and \(\zeta (t)=\left (w_{1}(t)+iw_{2}(t)\right )/\sqrt {2}\). For the well-known case of the Wigner representation at zero
temperature <span class="cite">[<a 
href="#Xgardiner2004quantum">13</a>, <a 
href="#XDrummond2014">6</a>]</span><a 
 id="x1-16001"></a>, the correlations are \begin {align}  \left \langle \zeta (t)\left (\zeta (t')\right )^{*}\right \rangle &amp; =\delta \left (t-t'\right )\nonumber \\ \left \langle \zeta (\omega )\left (\zeta \left (\omega '\right )\right )^{*}\right \rangle &amp; =\delta \left (\omega -\omega '\right )  \end {align}
                                                                                
                                                                                
<!--l. 545--><p class="indent" >  The probability therefore follows the Fokker-Planck equation: \begin {equation}  \frac {\partial P}{\partial t}=\left [\frac {\partial }{\partial a_{x}}a_{x}\,+\frac {\partial }{\partial a_{y}}a_{y}+\frac {1}{4}\left (\frac {\partial ^{2}}{\partial a_{x}^{2}}\,+\frac {\partial ^{2}}{\partial a_{y}^{2}}\right )\,\right ]P\,,\label {eq:FPE-1-1}  \end {equation}
which is an example of Eq \eqref{eq:FPE}. Ignoring terms that vanish or can be obtained
from symmetry, the first corresponding moment equations in each of the real and imaginary
directions are \begin {align}  \frac {\partial }{\partial t}\left \langle a_{x}\right \rangle = &amp; \left \langle -a_{x}\frac {\partial }{\partial a_{x}}a_{x}\,\right \rangle =-\left \langle a_{x}\,\right \rangle \nonumber \\ \frac {\partial }{\partial t}\left \langle a_{x}a_{y}\right \rangle = &amp; \left \langle -\left (a_{x}\frac {\partial }{\partial a_{x}}+a_{y}\frac {\partial }{\partial a_{y}}\,\right )a_{x}a_{y}\,\right \rangle =-\left \langle a_{x}a_{y}\,\right \rangle \nonumber \\ \frac {\partial }{\partial t}\left \langle a_{x}^{2}\right \rangle = &amp; \left \langle \left (-a_{x}\frac {\partial }{\partial a_{x}}+\frac {1}{4}\frac {\partial ^{2}}{\partial a_{x}^{2}}\,\right )a_{x}^{2}\,\right \rangle =\frac {1}{2}-2\left \langle a_{x}^{2}\,\right \rangle  \end {align}
<!--l. 558--><p class="indent" >  The steady-state is therefore a Gaussian distribution with \(\left \langle a_{x,y}\,\right \rangle =0\), \(\left \langle a_{x}a_{y}\,\right \rangle =0\) and \(\left \langle a_{x,y}^{2}\,\right \rangle =1/4\). One can use an initial
condition of \(a=(v_{1}+iv_{2})/2\), with \(\left \langle v_{i}^{2}\right \rangle =1/2\), in order to replicate the steady state, which is a Gaussian with\(\left \langle a_{x}\,\right \rangle =\left \langle a_{y}\,\right \rangle =0\)
and\(\left \langle a_{x}^{2}\,\right \rangle =\left \langle a_{y}^{2}\,\right \rangle =1/4\).
<!--l. 564--><p class="indent" >  Neglecting any boundary terms, the equation in frequency space is:
<!--l. 568--><p class="indent" >  \begin {equation}  -i\omega \tilde {a}(\omega )=-\tilde {a}(\omega )+\tilde {\zeta }(\omega )  \end {equation}
<!--l. 570--><p class="indent" >  For sufficiently long times, the solution in frequency space - where \(\omega =2\pi f\) is the angular frequency
- is therefore given by: \begin {equation}  \tilde {a}\left (\omega \right )=\frac {\tilde {\zeta }(\omega )}{1-i\omega }  \end {equation}
The expectation value of the noise spectrum, \(\left \langle \left |\tilde {a}(\omega )\right |^{2}\right \rangle \) in the long time limit, is: <div class="eqnarray">\begin {eqnarray}  \left \langle \left |\tilde {a}(\omega )\right |^{2}\right \rangle &amp; = &amp; \frac {1}{2\pi \left (1+\omega ^{2}\right )}\int \int e^{-i\omega (t-t')}\left \langle \zeta (t)\zeta ^{*}(t')\right \rangle dtdt'\,.\nonumber \\ &amp; = &amp; \frac {T}{2\pi \left (1+\omega ^{2}\right )}.\label {eq:spectra_SHO}  \end {eqnarray}
</div>
<!--l. 583--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">2.8</span>  <a 
 id="x1-170002.8"></a>Input-output spectra</h3>
<!--l. 585--><p class="noindent" >An important application of stochastic equations is the calculation of measured input-output
spectra <span class="cite">[<a 
href="#Xgardiner2004quantum">13</a>]</span><a 
 id="x1-17001"></a> in lasers, quantum optics and quantum circuits. These have the feature that the
measured output spectrum includes noise from reflected fields at the input/output ports. In a
typical case like the harmonic oscillator described above, one has auxiliary equations: \begin {align}  a_{in} &amp; =\frac {1}{\sqrt {2}}\zeta \\ a_{out} &amp; =\sqrt {2}a-\frac {1}{\sqrt {2}}\zeta \nonumber  \end {align}
<!--l. 596--><p class="indent" >  As a result, one must include in the spectrum both the internal fluctuations and fluctuations
from the noise terms themselves. Solving for the spectra, one obtains auxiliary fields with \begin {align}  \tilde {a}_{in}(\omega ) &amp; =\frac {1}{\sqrt {2}}\tilde {\zeta }(\omega )\\ \tilde {a}_{out}(\omega ) &amp; =\sqrt {2}\tilde {a}(\omega )-\frac {1}{\sqrt {2}}\tilde {\zeta }(\omega )\nonumber  \end {align}
<!--l. 604--><p class="indent" >  For these systems, which are essentially quantum-mechanical, it is the input and output
fields that are amplified and measured. As a result, one must be able to compute the spectra
of the input and output fields. These have the additional feature that they include the
stochastic noise evaluated at the same time as the field is evaluated, since the noise is the
input here.
<!--l. 611--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">2.8.1</span>  <a 
 id="x1-180002.8.1"></a>Steady-state result</h4>
<!--l. 613--><p class="noindent" >Over long enough time-scales so that one is in the steady state, with no significant boundary
terms, the solution for \(\tilde {a}_{out}\) is that: \begin {align}  \tilde {a}_{out}(\omega ) &amp; =\sqrt {2}\left [\frac {1}{1-i\omega }-\frac {1}{2}\right ]\tilde {\zeta }(\omega )\nonumber \\ &amp; =\frac {1}{\sqrt {2}}\left [\frac {1+i\omega }{1-i\omega }\right ]\tilde {\zeta }(\omega )  \end {align}
                                                                                
                                                                                
<!--l. 621--><p class="indent" >  This gives the following expectation values: \begin {align}  \left \langle \tilde {a}_{out}(\omega )\left (\tilde {a}_{out}(\omega )\left (\omega '\right )\right )^{*}\right \rangle &amp; =\frac {1}{2}\delta \left (\omega -\omega '\right )\nonumber \\ \left \langle \tilde {a}_{in}(\omega )\left (\tilde {a}_{in}(\omega )\left (\omega '\right )\right )^{*}\right \rangle &amp; =\frac {1}{2}\delta \left (\omega -\omega '\right )  \end {align}
<!--l. 626--><p class="indent" >  These are the expectation values of the zero temperature quantum fluctuations in the input
and output channels. This means that the harmonic oscillator in its ground state is in
equilibrium with an external vacuum field reservoir, also in its ground state. However, from Eq
\eqref{eq:spectra_SHO}, the internal spectral correlations of the harmonic oscillator are
modified by the coupling.
<!--l. 633--><p class="indent" >  While this is a trivial result, exactly the same general type of behavior occurs in more
sophisticated cases. These may include many coupled modes with nonlinearities. It is
noteworthy that having additional fields that depend both on noise terms and internal
stochastic variables is required. The soluble case given above is a useful test case, and it is
treated numerically later in the manual.
<!--l. 640--><p class="indent" >
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
  
<h2 class="chapterHead"><span class="titlemark">3</span>  <a 
 id="x1-190003"></a>SPDE theory</h2>
<!--l. 646--><p class="noindent" ><span 
class="ec-lmbxi-10x-x-109">This section describes the basics of stochastic partial differential equation (SPDE)</span>
<span 
class="ec-lmbxi-10x-x-109">theory, in order to explain the background to the numerical methods.</span>
  
<h3 class="sectionHead"><span class="titlemark">3.1</span>  <a 
 id="x1-200003.1"></a>SPDE definitions</h3>
<!--l. 650--><p class="noindent" >A stochastic partial differential equation or SPDE is defined in both time \(t\) and one or more
space dimensions \(\mathbf {x}\). We suppose there are \(d\) total space-time dimensions. The space-time
coordinate is denoted as \(\mathbf {r}=\left (r^{1},\ldots r^{d}\right )=\left (t,\mathbf {x}\right )=\left (t,x,y,z,...\right )\).
<!--l. 655--><p class="indent" >  The stochastic partial differential equation solved is written in differential form
as
<!--l. 660--><p class="indent" >  \begin {equation}  \frac {\partial \mathbf {a}}{\partial t}=\mathbf {A}\left [\mathbf {\nabla },\mathbf {a},\mathbf {r}\right ]+\underline {\mathbf {B}}\left [\mathbf {\nabla },\mathbf {a},\mathbf {r}\right ]\cdot \mathbf {w}(\mathbf {r})+\mathbf {L}\left [\mathbf {\nabla },\mathbf {a},\mathbf {r}\right ].\mathbf {a}.\label {eq:spde}  \end {equation}
Here, \(\mathbf {a}=\left [a_{1},\dots a_{f}\right ]\) is a real or complex vector field, \(\mathbf {A}\) is a vector function of fields and space and \(\underline {\mathbf {B}}\) a matrix
function. The new feature is that terms can now include the operator \(\nabla \), which is a differential
term in a real space \(\mathbf {x}\). The exact structure of these terms is important, and not all such
equations have well-behaved solutions <span class="cite">[<a 
href="#Xquastel2015one">14</a>, <a 
href="#Xlam1998improved">15</a>]</span><a 
 id="x1-20001"></a>.
<!--l. 669--><p class="indent" >  In many common cases, the noise term \(\mathbf {w}\) is delta-correlated in time and space:
<div class="eqnarray">\begin {eqnarray}  \left \langle w_{i}\left (\mathbf {r}\right )w_{j}\left (\mathbf {r}'\right )\right \rangle &amp; = &amp; \delta \left (t-t'\right )\delta \left (\mathbf {x}-\mathbf {x}'\right )\delta _{ij}  \end {eqnarray}
</div>
<!--l. 674--><p class="indent" >  One can also have noise with a finite correlation length defined by a noise correlation
function \(N_{ij}\left (\mathbf {x}-\mathbf {x}'\right )\) in space so that: <div class="eqnarray">\begin {eqnarray}  \left \langle w_{i}\left (\mathbf {r}\right )w_{j}\left (\mathbf {r}'\right )\right \rangle &amp; = &amp; \delta \left (t-t'\right )N_{ij}\left (\mathbf {x}-\mathbf {x}'\right )  \end {eqnarray}
</div>
<!--l. 680--><p class="indent" >  It is even possible to have noise with a finite correlation time. Currently, these are not
directly treated in xSPDE, although user definitions of this are possible by adding a
customized noise function.
<!--l. 684--><p class="indent" >  Additionally, the initial field has a probability distribution. In most examples, we suppose
that this initial random field distribution can be generated as a function of Gaussian
distributed initial random fields \(\mathbf {v}\left (\mathbf {x}\right )\), where: \begin {equation}  \left \langle v_{i}\left (\mathbf {x}\right )v_{j}\left (\mathbf {x}'\right )\right \rangle =\delta \left (\mathbf {x}-\mathbf {x}'\right )\delta _{ij}  \end {equation}
<!--l. 692--><p class="indent" >  However, it is also possible that the initial random fields are also not delta-correlated, so
that
<!--l. 697--><p class="indent" >  \begin {equation}  \left \langle v_{i}\left (\mathbf {x}\right )v_{j}\left (\mathbf {x}'\right )\right \rangle =R_{ij}\left (\mathbf {x}-\mathbf {x}'\right ).  \end {equation}
Both finite correlation length and delta-correlated noise and random terms can be used in
xSPDE simulations, with finite correlation lengths defined through a Fourier transform
method.
<!--l. 702--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">3.2</span>  <a 
 id="x1-210003.2"></a>Boundary conditions</h3>
<!--l. 704--><p class="noindent" >There are three types of boundaries that are available in xSPDE. They are specified
independently for each space dimension \(j=2,\ldots d\), field component \(i=1,\dots f,\) and lower or upper location \(\ell =1,2\).
Each has an xSPDE boundary type. These are specified with a numerical code \(bt\),
                                                                                
                                                                                
as:   
<dl class="description"><dt class="description">
<!--l. 710--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Dirichlet</span> 
</dt><dd 
class="description">
<!--l. 710--><p class="noindent" >(specified value, \(bt=1\)): \(a_{i}\left (r^{1},r^{2},\dots r_{\ell }^{j},\dots \right )=f_{ij\ell }\left (\mathbf {r},\mathbf {a}\right )\)
</dd>     
<dt class="description">
<!--l. 711--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Periodic</span> 
</dt><dd 
class="description">
<!--l. 711--><p class="noindent" >(\(bt=0\)): \(a_{i}\left (r^{1},r^{2},\dots r_{\ell }^{j},\dots \right )=a_{i}\left (r^{1},r^{2},\dots r_{3-\ell }^{j},\dots \right )\)
</dd>     
<dt class="description">
<!--l. 712--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Robin/Neumann</span> 
</dt><dd 
class="description">
<!--l. 712--><p class="noindent" >(specified derivative, \(bt=-1\)): \(\frac {\partial }{\partial r^{j}}a_{i}\left (r^{1},r^{2},\dots r_{\ell }^{j},\dots \right )=g_{ij\ell }\left (\mathbf {r},\mathbf {a}\right )\).</dd></dl>
<!--l. 714--><p class="noindent" >There are five types of boundary <span 
class="ec-lmri-10x-x-109">combinations </span>of these for each dimension and field variable.
Note that the boundary type can change the error stability properties of an equation. The
most general boundaries can only be specified using finite differences currently, as the spectral
method boundary types are more limited.
<!--l. 720--><p class="indent" >  Periodic boundaries can’t be combined with other types, as this defines both
boundaries:
<dl class="description"><dt class="description">     
<!--l. 723--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">a)</span> 
</dt><dd 
class="description">  
<!--l. 723--><p class="noindent" >periodic-periodic- P-P: &#x0022;0,0&#x0022;
</dd>     
<dt class="description">
<!--l. 724--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">b)</span> 
</dt><dd 
class="description">  
<!--l. 724--><p class="noindent" >Dirichlet-Dirichlet- D-D: &#x0022;1,1&#x0022;
</dd>     
<dt class="description">
<!--l. 725--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">c)</span> 
</dt><dd 
class="description">  
<!--l. 725--><p class="noindent" >Robin-Robin- R-R: &#x0022;-1,-1&#x0022;
</dd>     
<dt class="description">
<!--l. 726--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">d)</span> 
</dt><dd 
class="description">  
<!--l. 726--><p class="noindent" >Robin-Dirichlet- R-D: &#x0022;-1,1&#x0022;
                                                                                
                                                                                
     
</dd>
<dt class="description">     
<!--l. 727--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">e)</span> 
</dt><dd 
class="description">  
<!--l. 727--><p class="noindent" >Dirichlet-Robin- D-R: &#x0022;1,-1&#x0022;</dd></dl>
<!--l. 729--><p class="noindent" >Just as with the derivative term, each of these types can change with dimension and field
component. Specified field or derivative values can be any user-defined functions of space,
time, and field amplitude or simply have fixed values. Currently, all combinations of
boundaries can be treated in xSPDE using finite difference derivatives. Spectral methods are
restricted to periodic or zero Dirichlet/Neumann boundary conditions.
<!--l. 737--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">3.3</span>  <a 
 id="x1-220003.3"></a>Spatial grid and boundary locations</h3>
<!--l. 739--><p class="noindent" >The precise location of the boundary is important in solving (S)PDEs, especially if high
accuracy is required, or if field values at the boundary itself are needed.
<!--l. 743--><p class="indent" >  Suppose the spatial grid spacing is \(\Delta x\) and the number of grid points in a particular
dimension \(d\) is \(points(d)=N\), then the maximum range from the first to last computed point is <span 
class="ec-lmbx-10x-x-109">always</span>:
\begin {equation}  \begin {split}R=(N-1)\Delta x=ranges(d).\end {split}  \end {equation}
Noting that \(\mathbf {r}=\left (t,\mathbf {x}\right )\), and \(\Delta \mathbf {r}=\left (\Delta t,\Delta \mathbf {x}\right ),\)this means that the space-time points are at: \begin {equation}  r_{i}=O_{i}+(i-1)\Delta r_{i}.  \end {equation}
However, there are two distinct spatial boundary locations used in xSPDE, as follows:
<!--l. 757--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">3.3.1</span>  <a 
 id="x1-230003.3.1"></a>Periodic boundary</h4>
<!--l. 759--><p class="noindent" >Due to periodicity, the logical boundary location is arbitrary. For the default case of a periodic
boundary, the indices are arranged as though on a circle from \(1:N\). It is common to suppose the
boundary as at both \(x_{1}-\Delta x/2\) and at \(x_{N}+\Delta x/2\). Neither upper or lower logical ’boundary’ is at a grid point if
this picture is used.
<!--l. 766--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">3.3.2</span>  <a 
 id="x1-240003.3.2"></a>Dirichlet/Robin boundary</h4>
<!--l. 768--><p class="noindent" >For the case of a non-periodic boundary, including Dirichlet, Robin and Neumann boundary
conditions, the indices are simply in a line from \(1:N\). The lower and upper lower boundaries are at
\(x_{1}\) and \(x_{N}\). In some PDE methods the logical boundaries are outside the grid boundaries, but that
is not the case here.
                                                                                
                                                                                
<!--l. 774--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">3.4</span>  <a 
 id="x1-250003.4"></a>Example: multidimensional random walk</h3>
<!--l. 776--><p class="noindent" >The simplest example of an SPDE is the multidimensional Wiener process: \begin {equation}  \dot {a}=w(t,\mathbf {x})\,.\label {eq:Wiener_process-1}  \end {equation}
<!--l. 781--><p class="indent" >  This has a solution that is identical in appearance to an SDE: \begin {equation}  a\left (t,\mathbf {x}\right )=a\left (0,\mathbf {x}\right )+\int _{0}^{t}w\left (\tau ,\mathbf {x}\right )d\tau .  \end {equation}
Just as for an SDE, this means that the initial mean value does not change in time: \begin {equation}  \left \langle a\left (t,\mathbf {x}\right )\right \rangle =\left \langle a\left (0,\mathbf {x}\right )\right \rangle .\label {eq:Wiener_mean-1}  \end {equation}
<!--l. 792--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">3.4.1</span>  <a 
 id="x1-260003.4.1"></a>Variance solution</h4>
<!--l. 794--><p class="noindent" >The noise correlation is non-vanishing from Eq \eqref{eq:noise-correlations}, so the variance
must increase with time: \begin {align}  \left \langle a^{2}\left (t,\mathbf {x}\right )\right \rangle &amp; =\left \langle a^{2}\left (0,\mathbf {x}\right )\right \rangle +\int _{0}^{t}\int _{0}^{t}\left \langle w\left (\tau ,\mathbf {x}\right )w\left (\tau ',\mathbf {x}\right )\right \rangle d\tau d\tau '\nonumber \\ &amp; =\left \langle a^{2}\left (0,\mathbf {x}\right )\right \rangle +\delta ^{d-1}\left (0\right )\int _{0}^{t}\int _{0}^{t}\delta \left (\tau -\tau '\right )d\tau d\tau '.  \end {align}
<!--l. 801--><p class="indent" >  Integrating the temporal delta function gives unity. The spatial delta-function is replaced by
\(1/\Delta V\) in a discretized lattice calculation at points \(\mathbf {x}_{j}\) with cell volume \(\Delta V\), which means that the second
moment and the variance both increase linearly with time:
<!--l. 809--><p class="indent" >  \begin {align}  \left \langle a^{2}\left (t,\mathbf {x}_{j}\right )\right \rangle &amp; =\left \langle a^{2}\left (0,\mathbf {x}_{j}\right )\right \rangle +t/\Delta V.\label {eq:Wiener_mean_square-1}  \end {align}
<!--l. 811--><p class="indent" >  The probability on the lattice for observing lattice field values \(a_{j}\) follows an elementary
diffusion equation: \begin {equation}  \frac {\partial P}{\partial t}=\frac {1}{2\Delta V}\sum _{j}\frac {\partial ^{2}P}{\partial a_{j}^{2}}\,,\label {eq:FPE-1-2}  \end {equation}
which is an example of Eq \eqref{eq:FPE}. From this equation and using Eq
\eqref{eq:moment_equn}, the first two corresponding moment equations in this case are \begin {align}  \frac {\partial }{\partial t}\left \langle a_{j}\right \rangle = &amp; \left \langle \frac {1}{2}\frac {\partial ^{2}}{\partial a_{j}^{2}}a_{j}\,\right \rangle =0\nonumber \\ \frac {\partial }{\partial t}\left \langle a_{j}^{2}\right \rangle = &amp; \left \langle \frac {1}{2\Delta V}\frac {\partial ^{2}}{\partial a_{j}^{2}}a_{j}^{2}\,\right \rangle =\frac {1}{\Delta V}  \end {align}
<!--l. 824--><p class="indent" >  These differential equations are satisfied by the solutions obtained directly from the
stochastic equations, but as one can see, the coupling between the lattice points provides more
interesting behavior. This requires derivative terms such as Laplacians.
<!--l. 829--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">3.5</span>  <a 
 id="x1-270003.5"></a>Interaction picture</h3>
<!--l. 831--><p class="noindent" >To treat Laplacians, spectral or interaction-picture methods can be very efficient, and in
certain cases give both much lower errors and much faster run-times. They do not have the
large errors and stability problems of finite difference methods, which allows much larger
time-steps to be used.
<!--l. 837--><p class="indent" >  To explain the algorithm, (S)PDEs often contain terms which are linear in the field
variables \(\mathbf {a}\), including derivative operators acting on \(\mathbf {a}\). This can be treated using an
                                                                                
                                                                                
<span 
class="ec-lmri-10x-x-109">interaction picture</span>, which leads to dramatically reduced time-step errors and higher
stability <span class="cite">[<a 
href="#XWerner1997">9</a>]</span><a 
 id="x1-27001"></a>. In the literature on partial differential equations, this is called a spectral
method.
<!--l. 844--><p class="indent" >  The interaction picture provides a means to solve for linear terms in the time derivatives in
a very efficient way. This is based on introducing local variables \(\tilde {\mathbf {a}}\) for the field variables \(\mathbf {a}\). It is
convenient for the purposes of describing such interaction picture methods to introduce an
abbreviated notation as: \begin {equation}  \begin {split}\begin {aligned}\mathcal {D}\left [\mathbf {a},\mathbf {r}\right ]=\mathbf {A}\left [\mathbf {\nabla },\mathbf {a},\mathbf {r}\right ]+\underline {\mathbf {B}}\left [\mathbf {\nabla },\mathbf {a},\mathbf {r}\right ]\cdot \mathbf {w}(\mathbf {r})\end {aligned} \end {split} \label {eq:deriv_without_linear_term}  \end {equation}
Hence, provided that \(\underline {\mathbf {L}}\left [\boldsymbol {\nabla }\right ]\) has no explicit space-dependence, we can write the differential equation
as: \begin {equation}  \begin {split}\frac {\partial \boldsymbol {a}}{\partial t}=\mathcal {D}\left [\mathbf {a},\mathbf {r}\right ]+\underline {\mathbf {L}}\left [\boldsymbol {\nabla }\right ]\cdot \boldsymbol {a}.\end {split}  \end {equation}
Next, we define a linear propagator. This is given formally by: \begin {equation}  \begin {split}\mathcal {P}\left (\Delta t\right )=\exp \left (\Delta t\underline {\mathbf {L}}\left [\boldsymbol {\nabla }\right ]\right )\end {split} .  \end {equation}
where \(\Delta t=t-\bar {t}\), and \(\bar {t}\) is the interaction picture origin. Transforming the field \(\mathbf {a}\) to an interaction picture
is achieved on defining: \begin {equation}  \tilde {\mathbf {a}}=\mathcal {P}^{-1}\left (\Delta t\right )\cdot \mathbf {a}  \end {equation}
As a result, the equation of motion is: \begin {equation}  \begin {split}\frac {\partial \tilde {\mathbf {a}}}{\partial t}=\mathcal {D}\left [\mathcal {P}\left (\Delta t\right )\cdot \tilde {\mathbf {a}},t\right ].\end {split}  \end {equation}
<!--l. 876--><p class="indent" >  This allows an SPDE to be treated like an SDE, if transformations are used. These can be
efficiently implemented using Fourier or discrete sine or cosine transforms. The xSPDE
implementation of this currently requires either periodic or zero boundary conditions and a
diagonal linear operator <span 
class="ec-lmri-10x-x-109">L </span>without space-dependence. The linear operator can have any
derivative in the periodic case, but only even order derivatives in the Dirichlet and Neumann
case.
<!--l. 884--><p class="indent" >  As well as the linear term, derivatives and nonlinear functions that are not tractable with
spectral methods can appear in the residual term \(\mathcal {D}\left [\mathbf {a},\mathbf {r}\right ]\), where they are treated using finite
difference techniques. As a result, while the interaction picture does not handle all
derivative terms, it also does not restrict them from being used elsewhere in the
equations.
<!--l. 891--><p class="indent" >  Other methods exist in the literature, and not all possible algorithms are implemented.
<!--l. 894--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">3.6</span>  <a 
 id="x1-280003.6"></a>Fourier transforms</h3>
<!--l. 896--><p class="noindent" >It is often useful to transform a field to implement the interaction picture, or to
extract nonlocal correlation properties in space. The Fourier transforms or spectrum
definitions used in xSPDE are given by the symmetric Fourier transform definition: \begin {align}  \tilde {a}(\mathbf {k}) &amp; =\mathcal {F}\left (a(\mathbf {x})\right )\nonumber \\ &amp; =\frac {1}{\left [2\pi \right ]^{\left (d-1\right )/2}}\int e^{-i\mathbf {k}\cdot \mathbf {x}}a(\mathbf {x})d\mathbf {x}\,  \end {align}
<!--l. 905--><p class="indent" >  The inverse Fourier transform is the function: \begin {align}  a(\mathbf {x}) &amp; =\mathcal {F}^{-1}\left (\tilde {a}\right )\nonumber \\ &amp; =\frac {1}{\left [2\pi \right ]^{\left (D-1\right )/2}}\int e^{i\mathbf {k}\cdot \mathbf {x}}\tilde {a}(\mathbf {k})d\mathbf {k}\,.  \end {align}
<!--l. 911--><p class="indent" >  In simulations, this is not combined with any time (or space) averaging as in the
temporal Fourier transforms. The reason for this is that the interaction picture
transformations must be invertible, which is the case for a point-based discrete Fourier
transform.
<!--l. 916--><p class="indent" >  During propagation, we define temporary internal fields \(A\left (\mathbf {k}_{\mathbf {n}}\right )\), gthat are normalized using FFT
                                                                                
                                                                                
conventions: \begin {align}  A\left (\mathbf {k}_{\mathbf {n}}\right ) &amp; =\sum _{j_{2}=1}^{N_{2}}\ldots \sum _{j_{d}=1}^{N_{d}}e^{-i\mathbf {k}_{n}\cdot \mathbf {x}_{\mathbf {j}}}a\left (\mathbf {x}_{\mathbf {j}}\right )\,\nonumber \\ a\left (\mathbf {x}_{\mathbf {j}}\right ) &amp; =\frac {1}{\prod _{k=2}^{D}N_{k}}\sum _{n_{2}=1}^{N_{2}}\ldots \sum _{n_{D}=1}^{N_{D}}e^{i\mathbf {k}_{\mathbf {n}}\cdot \mathbf {x}_{\mathbf {j}}}A\left (\mathbf {k}_{\mathbf {n}}\right )\,  \end {align}
<!--l. 922--><p class="indent" >  Otherwise, for graphical and output averages, we define Fourier transforms using physics
and mathematics conventions:
<!--l. 928--><p class="indent" >  \begin {align}  \tilde {a}\left (\mathbf {k}_{\mathbf {n}}\right ) &amp; =\prod _{d=2}^{D}\left [\frac {\Delta x_{d}}{\sqrt {2\pi }}\right ]\sum _{j_{2}=1}^{N_{2}}\ldots \sum _{j_{d}=1}^{N_{D}}e^{-i\mathbf {k}_{n}\cdot \mathbf {x}_{\mathbf {j}}}a\left (\mathbf {x}_{\mathbf {j}}\right )\,\nonumber \\ a\left (\mathbf {x}_{\mathbf {j}}\right ) &amp; =\prod _{d=2}^{D}\left [\frac {\Delta k_{d}}{\sqrt {2\pi }}\right ]\sum _{n_{2}=1}^{N_{2}}\ldots \sum _{n_{d}=1}^{N_{D}}e^{i\mathbf {k}_{\mathbf {n}}\cdot \mathbf {x}_{\mathbf {j}}}\tilde {a}\left (\mathbf {k}_{\mathbf {n}}\right )\,  \end {align}
<!--l. 930--><p class="indent" >  Note that this rescaling is consistent, because \begin {equation}  \Delta x_{d}\Delta k_{d}=\frac {2\pi }{N_{d}}  \end {equation}
<!--l. 936--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">3.7</span>  <a 
 id="x1-290003.7"></a>Trigonometric transforms</h3>
<!--l. 938--><p class="noindent" >Taking the interaction picture approach, we now consider other types of boundary
conditions, which we assume here are either a zero field (Dirichlet) or a zero derivative
(Neumann). We will only treat cases of even order derivatives, which do not change the
trigonometric function. Any odd order derivatives are taken to be included in the \(\mathcal {D}\)
term.
<!--l. 945--><p class="indent" >  In the spectral transform method, one uses a trigonometric function, \(T\left (kx\right )=T_{1}\sin \left (kx\right )+T_{2}\cos \left (kx\right )\) to expand as: \begin {align}  a_{i}\left (t,x\right ) &amp; =\sum _{n}a_{i,n}(t)T(k_{i,n}x),  \end {align}
<!--l. 951--><p class="indent" >  The discrete inverse transform allows evaluation at sample points \(x_{j}\), in order to satisfy the
boundary conditions: \begin {equation}  a_{i,n}(t)=\sum _{j}a_{i}(t,x_{j})\tilde {T}(k_{n}x_{j}),  \end {equation}
The trigonometrical function is defined such that:
<!--l. 960--><p class="indent" >  \begin {equation}  \partial _{x}^{2p}T(kx)=\left (-k^{2}\right )^{p}T(kx)  \end {equation}
<!--l. 962--><p class="indent" >  This means that the propagation equation is now soluble for the sampled points, since for
each component \begin {align}  \mathcal {L}\cdot a(t,x_{j}) &amp; =\sum _{ijn}\mathcal {L}a_{n}(t)T(k_{n}x_{j}),\nonumber \\ &amp; =-\sum _{ijnp}L_{p}\left (-k_{n}^{2}\right )^{p}a_{n}(t)T(k_{n}x_{j})),  \end {align}
<!--l. 969--><p class="indent" >  Hence, \begin {equation}  a_{n}(t)=\exp \left (\sum L_{p}\left (-k_{n}^{2}t\right )^{p}t\right )a_{n}(0)  \end {equation}
<!--l. 974--><p class="indent" >  This is an exact solution, provided the initial condition has the given expansion. There
are no approximations made on the transverse derivative. Provided the \(k\) values are
the same, this propagator is identical for all types of trigonometric and Fourier
transforms.
<!--l. 979--><p class="indent" >  As explained above in (<a 
href="#x1-210003.2">3.2<!--tex4ht:ref: subsec:Boundary-conditions --></a>), there are five types of boundary combinations that are possible
in each dimension and field component. Each has a corresponding xSPDE boundary type and
spectral integrator. Just as with the derivative term, each of these types can change with
dimension and field component.
<!--l. 985--><p class="indent" >  Currently, all can be treated in xSPDE using finite differences, and each type of boundary
has a particular spectral method that preserves the boundary requirement. In principle, more
than one transform can be used. It is possible to define the relevant trigonometric transforms
to correspond to whole symmetries whose boundary is either at a grid point, or half
                                                                                
                                                                                
symmetries which are half-way between two grid points.
<!--l. 992--><p class="indent" >  However, differential equations can have first order terms, which currently require using
finite differences or periodic boundaries. These make use of boundaries at a grid point, in
order to compute the relevant terms, which means that there is greater compatibility with the
finite difference methods when the boundaries are at the grid points. With this restriction, the
available transforms are reduced.
<!--l. 999--><p class="indent" >  It is possible to compute first-order derivatives with spectral methods, but these turn sine
transforms into cosine transforms. This is not compatible with simple interaction picture
transformations, except for the periodic case.
<!--l. 1004--><p class="indent" >  In summary, spectral transforms can all be implemented using fast FTT, discrete sine
(DST) or cosine (DCT) transforms, but the exact trigonometric method to be used is specific
to the boundary type.
<!--l. 1008--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">3.8</span>  <a 
 id="x1-300003.8"></a>Spectral transforms and boundaries</h3>
<!--l. 1010--><p class="noindent" >Suppose that there are Dirichlet or Neumann boundaries, then the following expansion can be
employed: \begin {equation}  a=\sum _{n=1}^{\infty }\left [S_{n}\sin \left (k_{n}x\right )+C_{n}\cos \left (k_{n}x\right )\right ]e^{\sum L_{p}\left (-k_{n}^{2}\right )^{p}t}  \end {equation}
Here \(k_{n},C_{n},S_{n}\) are chosen to satisfy the initial and boundary conditions. Boundaries are taken, for the
purposes of explanation, as being from \(x=0\) to \(x=\pi \). This is not the case in the actual code, which
treats arbitrary locations.
<!--l. 1020--><p class="indent" >  We suppose there are \(N\) computational grid points. For the spatial grid (1-based), this
corresponds to \(x_{n}=\left (n-1\right )\Delta x\), \(n=1,...,N\) with \(\Delta x=\frac {\pi }{N-1}\) , so we have \(x_{1}=0\) and \(x_{N}=\pi \).
<!--l. 1025--><p class="indent" >  In carrying out a discrete transform on \(N_{T}\) points, using standard trigonometric
transform definitions, there may be less grid points required, so we may have \(N_{T}\le N\) if some
of the boundary values are defined due to Dirichlet boundaries. Internal xSPDE
definitions always use the full computational grid range, \(N\), which <span 
class="ec-lmri-10x-x-109">includes </span>boundary
values.
<!--l. 1032--><p class="indent" >  An unnormalized inverse results in the original array multiplied by \(N_{FT}/2=\left (N-1\right )/2\), where \(N_{FT}=N-1\) is the FFTW
’logical’ size, so our definitions include a factor of \(\sqrt {2/\left (N-1\right )}\). Here\(N_{T}\), the number of points in the standard
DST/DCT transforms, can differ from <span 
class="ec-lmbx-10x-x-109">both </span>the xSPDE computation grid size \(N\) that includes
both boundaries, and also from the FFTW ’logical’ size, which always includes one periodic
boundary.
<!--l. 1040--><p class="indent" >  The notation in this section is based on the discrete sine and cosine transform
(FFTW) definitions. However, we use \(1-\)based indices, often found in mathematics and in
Octave/Matlab/Julia/Fortran, so that for these examples of discrete Fourier transforms, we
remind the reader that: \begin {equation}  x_{n}=\pi \left (n-1\right )/(N-1).  \end {equation}
<span 
class="ec-lmbx-10x-x-109">The following lists the inverse transforms required to obtain</span> \(a(x)\) <span 
class="ec-lmbx-10x-x-109">from</span> \(a_{k}\)<span 
class="ec-lmbx-10x-x-109">.</span>
<!--l. 1051--><p class="noindent" >
                                                                                
                                                                                
<h4 class="subsectionHead"><span class="titlemark">3.8.1</span>  <a 
 id="x1-310003.8.1"></a>D-D case: Discrete map (DST-I)</h4>
<!--l. 1053--><p class="noindent" >Take \(a(0)=a(\pi )=0\), with a sine transform. The representation of \(a\) is
<!--l. 1058--><p class="indent" >  \begin {align}  a\left (x_{n},t\right ) &amp; =\sqrt {\frac {2}{N-1}}\sum _{k=2}^{N-1}a_{k}\left (t\right )\sin \left (\pi \frac {\left (k-1\right )\left (n-1\right )}{N-1}\right )  \end {align}
<!--l. 1060--><p class="indent" >  <span 
class="ec-lmbx-10x-x-109">Forward transform: this is also DST-I</span>
<!--l. 1062--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">3.8.2</span>  <a 
 id="x1-320003.8.2"></a>R-R case: Discrete map (DCT-I)</h4>
<!--l. 1064--><p class="noindent" >Take \(a'(0)=a'(\pi )=0\). The representation of \(a\) is
<!--l. 1068--><p class="indent" >  \begin {align}  a\left (x_{n},t\right ) &amp; =\sqrt {\frac {2}{N-1}}\left (\frac {1}{2}\left (a_{1}+(-1)^{n-1}a_{N}\right )+\sum _{k=2}^{N-1}a_{k}\left (t\right )\cos \left (\pi \frac {\left (k-1\right )\left (n-1\right )}{N-1}\right )\right )  \end {align}
<!--l. 1070--><p class="indent" >  <span 
class="ec-lmbx-10x-x-109">Forward transform: this is also DCT-I</span>
<!--l. 1072--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">3.8.3</span>  <a 
 id="x1-330003.8.3"></a>D-R case: Discrete map (DST-II)</h4>
<!--l. 1074--><p class="noindent" >Take \(a(0)=a'(\pi )=0\). The representation of \(a\) is:
<!--l. 1078--><p class="indent" >  \begin {align}  a\left (t,x_{n}\right ) &amp; =\sqrt {\frac {2}{N-1}}\left (\sum _{k=1}^{N-1}a_{k}\left (t\right )\sin \left [\frac {\pi }{N-1}\left (k-\frac {1}{2}\right )n\right ]\right )  \end {align}
<!--l. 1080--><p class="indent" >  <span 
class="ec-lmbx-10x-x-109">Forward transform: this is DST-III</span>.
<!--l. 1082--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">3.8.4</span>  <a 
 id="x1-340003.8.4"></a>R-D case Discrete map (DCT-II)</h4>
<!--l. 1084--><p class="noindent" >Take \(a'(0)=a(\pi )=0\). The representation of \(a\) is:
<!--l. 1088--><p class="indent" >  \begin {align}  a\left (t,x_{n}\right ) &amp; =\sqrt {\frac {2}{N-1}}\sum _{k=1}^{N-1}a_{k}\left (t\right )\cos \left [\frac {\pi }{N-1}\left (k-\frac {1}{2}\right )\left (n-1\right )\right ]  \end {align}
<!--l. 1090--><p class="indent" >  <span 
class="ec-lmbx-10x-x-109">Forward transform: this is DCT-III</span>.
<!--l. 1092--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">3.9</span>  <a 
 id="x1-350003.9"></a>Frequency or momentum grid </h3>
<!--l. 1094--><p class="noindent" >The frequency or momentum grid spacing is defined for all output graphs and periodic Fourier
transforms as \begin {equation}  \begin {split}\Delta k=\frac {2\pi }{N\Delta x}\end {split} .  \end {equation}
<!--l. 1101--><p class="indent" >  The xSPDE algorithms all allow the use of a sequence of interaction pictures. Each
successive interaction picture is referenced to \(t=t_{n}\), for the n-th step starting at \(t=t_{n}\), so \(\boldsymbol {a}_{I}(t_{n})=\boldsymbol {a}(t_{n})\equiv \boldsymbol {a}_{n}\). It is also
                                                                                
                                                                                
possible to solve stochastic partial differential equations in xSPDE using explicit derivatives,
but this is less efficient.
<!--l. 1107--><p class="indent" >  A discrete Fourier transform (DFT) using a fast Fourier transform method is employed for
the interaction picture (IP) transforms used in computations, as this is faster. This is
normalized differently to the graphed Fourier transforms, but the difference is not
computationally significant. We note that \(\Delta k\) (as used internally) will change with the precise
type of trigonometric transform used.
<!--l. 1114--><p class="indent" >  In one dimension, the DFT is usually given by a sum over indices starting with zero, rather
than the Matlab convention of one. Hence, if \(\tilde {m}=m-1\): \begin {equation}  \begin {split}A_{\tilde {n}}=\mathcal {F}\left (a\right )=\sum _{\tilde {m}=0}^{N-1}a_{\tilde {m}}\exp \left [-2\pi i\tilde {m}\tilde {n}/N\right ]\end {split} .  \end {equation}
For periodic boundaries, the IP Fourier transform can be written in terms of an FFT as
\begin {equation}  \begin {split}\boldsymbol {A}\left (\boldsymbol {k}_{\boldsymbol {n}}\right )=\prod _{j}\left [\sum _{\tilde {m}_{j}}\exp \left [-i\left (dk_{j}dx_{j}\right )\tilde {m}_{j}\tilde {n}_{j}\right ]\right ]\end {split} .  \end {equation}
The inverse FFT Fourier transforms divide by the correct factors of \(\prod _{j}N_{j}\) to ensure invertibility.
Due to the periodicity of the exponential function, negative momenta are obtained if we
consider an ordered lattice such that: \begin {equation}  \begin {split}\begin {aligned}k_{j} &amp; =(j-1)dk\,\,\,(j\le N/2)\\ k_{j} &amp; =(j-1-N)dk\,\,(j&gt;N/2) \end {aligned} .\end {split}  \end {equation}
This Fourier transform is then multiplied by the appropriate factor to propagate in the
interaction picture, then an inverse Fourier transform is applied. While it is not scaled for
interaction picture transforms, an additional scaling factor is applied to obtain transformed
fields in any averages for output plots.
<!--l. 1142--><p class="indent" >  In other words, in the averages \begin {equation}  \begin {split}\tilde {a}_{n}=\frac {\Delta x}{\sqrt {2\pi }}A_{\tilde {n}'}.\end {split}  \end {equation}
where the indexing change indicates that graphed momenta are stored from negative to
positive values. Note also that for plotted frequency spectra a <span 
class="ec-lmbx-10x-x-109">positive </span>sign is used in the
frequency exponent of the transform to frequency space, to agree with common physics
conventions.
<!--l. 1152--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">3.10</span>  <a 
 id="x1-360003.10"></a>Derivatives</h3>
<!--l. 1154--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">3.10.1</span>  <a 
 id="x1-370003.10.1"></a>Spectral derivatives</h4>
<!--l. 1156--><p class="noindent" >For spectral derivatives in the interaction picture, we define \(D_{x}\left (k\right )\) to obtain a derivative. To explain,
one integrates by parts: \begin {equation}  \begin {split}D_{x}^{p}\tilde {\boldsymbol {a}}\left (\boldsymbol {k}\right )=\left [ik_{x}\right ]^{p}\tilde {\boldsymbol {a}}\left (\boldsymbol {k}\right )=\frac {1}{\left (2\pi \right )^{d/2}}\int d\boldsymbol {x}e^{-i\boldsymbol {k}\cdot \boldsymbol {x}}\left [\frac {\partial }{\partial x}\right ]^{p}\boldsymbol {a}\left (\boldsymbol {x}\right ).\end {split}  \end {equation}
This means, for example, that to calculate a one dimensional space derivative in a Fourier
interaction picture routine, one uses:
<!--l. 1168--><p class="indent" >   \begin {equation}  \nabla _{x}\rightarrow D_{x}  \end {equation}
<!--l. 1170--><p class="indent" >  Here <span 
class="ec-lmri-10x-x-109">Dx </span>is an array of momenta in cyclic order in dimension \(d\) as defined above, suitable for
an FFT calculation. The imaginary \(i\) is not needed to give the correct sign, as it is
included in the derivative array. In two dimensions, a full two-dimensional Laplacian
is:
                                                                                
                                                                                
<!--l. 1180--><p class="indent" >   \begin {equation}  \boldsymbol {\nabla }^{2}=\nabla _{x}^{2}+\nabla _{y}^{2}\rightarrow D_{x}^{2}+D_{y}^{2}.  \end {equation}
<!--l. 1182--><p class="indent" >  Then, on inverting the transform \begin {equation}  \left [\frac {\partial }{\partial x}\right ]^{p}\boldsymbol {a}\left (\boldsymbol {x}\right )=\frac {1}{\left (2\pi \right )^{d/2}}\int d\boldsymbol {x}e^{i\boldsymbol {k}\cdot \boldsymbol {x}}\left [D_{x}\left (\boldsymbol {k}\right )\right ]^{p}\tilde {\boldsymbol {a}}\left (\boldsymbol {k}\right ).  \end {equation}
<!--l. 1188--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">3.10.2</span>  <a 
 id="x1-380003.10.2"></a>Finite difference derivatives</h4>
<!--l. 1190--><p class="noindent" >For calculating derivatives using finite differences, the following central differencing method is
used, away from the boundaries: \begin {equation}  \nabla _{x}a\left (x_{i}\right )\rightarrow \frac {1}{2\Delta x}\left [a\left (x_{i+1}\right )-a\left (x_{i-1}\right )\right ]  \end {equation}

<!--l. 1198--><p class="indent" >  \begin {equation}  \nabla _{x}^{2}a\left (x_{i}\right )\rightarrow \frac {1}{\Delta x^{2}}\left [a\left (x_{i+1}\right )-2a\left (x_{i}\right )+a\left (x_{i-1}\right )\right ]  \end {equation}
<!--l. 1200--><p class="indent" >  This raises the question of how to calculate derivatives at the boundary, for example at the
lower boundary \(x_{1}\), where \(a\left (x_{0}\right )\) is not known, and similarly at the upper boundary. The answer
depends on the boundary type <span class="cite">[<a 
href="#Xcrank1947practical">16</a>]</span><a 
 id="x1-38001"></a>, and is obtained by extending the boundary to an
additional point \(a\left (x_{0}\right )\) that is assumed to extend the boundary condition:
<!--l. 1207--><p class="indent" >  <a 
 id="paragraph*.2"></a>
<!--l. 1207--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-390003.10.2"></a>Periodic: \(a\left (x_{0}\right )=a\left (x_{N}\right )\) </span>
\begin {equation}  \nabla _{x}a\left (x_{1}\right )\rightarrow \frac {1}{2\Delta x}\left [a\left (x_{2}\right )-a\left (x_{N}\right )\right ]  \end {equation}
  
\begin {equation}  \nabla _{x}^{2}a\left (x_{1}\right )\rightarrow \frac {1}{\Delta x^{2}}\left [a\left (x_{2}\right )-2a\left (x_{2}\right )+a\left (x_{N}\right )\right ]  \end {equation}
<!--l. 1218--><p class="indent" >  <a 
 id="paragraph*.3"></a>
<!--l. 1218--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-400003.10.2"></a>Dirichlet: \(\tilde {a}\left (x_{1}\right )\) specified:  \(a\left (x_{0}\right )=\tilde {a}\left (x_{1}\right )\) </span>
\begin {equation}  \nabla _{x}a\left (x_{1}\right )\rightarrow \frac {1}{2\Delta x}\left [a\left (x_{2}\right )-\tilde {a}\left (x_{1}\right )\right ]  \end {equation}
  
\begin {equation}  \nabla _{x}^{2}a\left (x_{1}\right )\rightarrow \frac {1}{\Delta x^{2}}\left [a\left (x_{2}\right )-\tilde {a}\left (x_{1}\right )\right ]  \end {equation}
<!--l. 1229--><p class="indent" >  <a 
 id="paragraph*.4"></a>
<!--l. 1229--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-410003.10.2"></a>Robin/Neumann: \(\tilde {a}'\left (x_{1}\right )\) specified:  \(a\left (x_{0}\right )=a\left (x_{2}\right )-2\tilde {a}'\left (x_{1}\right )\Delta x\) </span>
\begin {equation}  \nabla _{x}a\left (x_{1}\right )\rightarrow \tilde {a}'\left (x_{1}\right )  \end {equation}
  
\begin {equation}  \nabla _{x}^{2}a\left (x_{1}\right )\rightarrow \frac {2}{\Delta x^{2}}\left [a\left (x_{2}\right )-a\left (x_{1}\right )-\tilde {a}'\left (x_{1}\right )\Delta x\right ]  \end {equation}
                                                                                
                                                                                
  
In all cases the boundary value is evaluated as part of the derivative evaluation, so it can be
a nonlinear function of \(\mathbf {a}\).
<!--l. 1242--><p class="indent" >
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
  
<h2 class="chapterHead"><span class="titlemark">4</span>  <a 
 id="x1-420004"></a>Solving an SDE </h2>
<!--l. 1248--><p class="noindent" ><span 
class="ec-lmbxi-10x-x-109">This section describes how to use the xSPDE numerical toolbox to solve an SDE</span>
<span 
class="ec-lmbxi-10x-x-109">to obtain and graph averages, spectra or probability distributions.</span>
  
<h3 class="sectionHead"><span class="titlemark">4.1</span>  <a 
 id="x1-430004.1"></a>Starting with xSPDE</h3>
<!--l. 1252--><p class="noindent" >Stochastic equations have very few analytic solutions, except in unusually simple cases. They
generally require numerical solutions. A stochastic toolbox helps to streamline the job of
writing and executing code. The xSPDE simulation program is straightforward to
use, and provides many options. To run it, an Octave or Matlab environment is
needed.
<!--l. 1258--><p class="indent" >  The current xSPDE distribution includes:
<ul class="itemize1">     
<li class="itemize">
<!--l. 1260--><p class="noindent" >The toolbox: \(xspde.mltbx\), or a folder: xSPDE.
</li>     
<li class="itemize">
<!--l. 1261--><p class="noindent" >simulation (xSIM) and graphics (xGRAPH) functions.
</li>     
<li class="itemize">
<!--l. 1262--><p class="noindent" >xAMPLES: examples that can also be used as templates
</li>     
<li class="itemize">
<!--l. 1263--><p class="noindent" >xDOC: should contain the current user guide</li></ul>
<!--l. 1265--><p class="noindent" >xSPDE can be run interactively as a script, or as a function in batch mode, either at a local
workstation or on a remote cluster. Data can be either plotted immediately, or saved then
plotted later. To simulate a stochastic equation interactively, first check that the xSPDE
toolbox is installed.
<!--l. 1272--><p class="indent" >  <span 
class="ec-lmbx-10x-x-109">If you have the toolbox file,</span> \(xspde.mltbx\)<span 
class="ec-lmbx-10x-x-109">, just open it and click on</span> \(install\)<span 
class="ec-lmbx-10x-x-109">. </span>Otherwise the
Octave/Matlab path must point to the xSPDE folder and subfolders. If you have the folders,
but not the toolbox, proceed as follows:
<ul class="itemize1">     
<li class="itemize">
<!--l. 1276--><p class="noindent" >Click on the Octave/Matlab HOME tab (top left), then Set Path
</li>     
<li class="itemize">
<!--l. 1277--><p class="noindent" >Click on Add with Subfolders
                                                                                
                                                                                
     
</li>
<li class="itemize">     
<!--l. 1278--><p class="noindent" >Find the xSPDE folder in the drop-down menu, and select it
</li>     
<li class="itemize">
<!--l. 1279--><p class="noindent" >Click on close to save the path.</li></ul>
<!--l. 1281--><p class="noindent" >Type \(clear\) to clear old data, and enter the xSPDE inputs and functions into the command window.
For the simplest cases, one can do this by cutting and pasting from an electronic file of this
manual.
<!--l. 1285--><p class="indent" >  For more advanced cases, it is best to create a function that calls xSPDE. The
Octave/Matlab built-in editor is also useful. There are many examples listed in this manual,
and there are more in the xAMPLES folder. Any of these can be used as templates for
building your own simulation.
<!--l. 1291--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">4.1.1</span>  <a 
 id="x1-440004.1.1"></a>Wiener process</h4>
<!--l. 1293--><p class="noindent" >To solve for a single trajectory of Eq \eqref{eq:Wiener_process} with xSPDE, just type
in:
<div class="center" 
>
<!--l. 1295--><p class="noindent" >
<div class="doublebox"><div class="minipage"><span 
class="ec-lmtt-10x-x-109">p.deriv = @(a,w,p) w;</span>
<!--l. 1299--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">xspde(p);</span>                                                  </div></div>
</div>
<!--l. 1303--><p class="indent" >  Here \(p.deriv\) defines the time derivative \(\dot {a}\) in the input parameter structure <span 
class="ec-lmri-10x-x-109">p, </span>while \(w\) is a
delta-correlated Gaussian noise generated internally. There are no other parameters, so default
values are used. This produces the graph shown in Fig (<a 
href="#x1-44001r1">4.1<!--tex4ht:ref: fig:The-simplest-case: Wiener --></a>), which gives a single
trajectory.
<div class="center" 
>
<!--l. 1308--><p class="noindent" >
<!--l. 1309--><p class="noindent" ><figure class="figure"> 
<a 
 id="x1-44001r1"></a><img 
src="xFIGURES/Wiener_1.svg" alt="pict"  
 style="width:31.36917em;" >
<figcaption class="caption" ><span class="id">Figure 4.1: </span><span  
class="content">The simplest example: a random walk.</span></figcaption><!--tex4ht:label?: x1-44001r1 -->
<!--l. 1312--><p class="noindent" ></figure>
</div>
<!--l. 1315--><p class="indent" >  At the end of the run, xSPDE reports the RMS errors. There are discretization, sampling
and comparison errors, all normalized by the maximum observable value, unless
compared to a result of zero. In the present simulation, the discretization or step
                                                                                
                                                                                
error is about \(10^{-16}\), due to round-off. This is just a single trajectory, but more can be
added.
<!--l. 1321--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">4.1.2</span>  <a 
 id="x1-450004.1.2"></a>General derivatives</h4>
<!--l. 1323--><p class="noindent" >All important xSPDE procedures use functions. Functions can be specified inline,
which is the simplest, or externally. The last argument of any xSPDE function is the
parameter structure. An example already introduced is the derivative function, labeled
\(p.deriv\).
<!--l. 1328--><p class="indent" >  For example, consider the stochastic differential equation, \begin {equation}  \frac {da}{dt}=-ga+w.  \end {equation}
The corresponding derivative code definition is:
<div class="center" 
>
<!--l. 1333--><p class="noindent" >
<div class="doublebox"><div class="minipage"><span 
class="ec-lmtt-10x-x-109">p.deriv = @(a,w,p) -p.G*a + w;</span>                           </div></div>
</div>
<!--l. 1339--><p class="indent" >  This code defines the function handle \(p.deriv\), which gives the derivative function, \(da/dt\). In this
example, it simply returns the derivative, in terms of the variable \(a\), loss parameter \(p.G\), and
stochastic noise term \(w.\) This user specified inline function is known internally by the function
handle \(p.deriv\).
<!--l. 1345--><p class="indent" >  Inside a complete xSPDE simulation input with a parameter values, it would look
like:
<div class="center" 
>
<!--l. 1347--><p class="noindent" >
<div class="doublebox"><div class="minipage"><span 
class="ec-lmtt-10x-x-109">p.G = 0.25;</span>
<!--l. 1351--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.deriv = @(a,w,p) -p.G*a + w;</span>
<!--l. 1353--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">xspde(p);</span>                                                  </div></div>
</div>
<!--l. 1357--><p class="indent" >  External function handles can also be used. They are useful for complex functions with more
internal logic.
<!--l. 1360--><p class="indent" >  A typical script first defines parameters and function specifications, in a structure, then runs
the simulation code with the parameter structure as an input, as follows:
<div class="center" 
>
<!--l. 1363--><p class="noindent" >
<div class="doublebox"><div class="minipage"><span 
class="ec-lmtt-10x-x-109">p.[label1] = [parameter1];</span>
<!--l. 1367--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">...</span>
<!--l. 1369--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.[label2] = [parameter2];</span>
<!--l. 1371--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.deriv = @(a,w,p) [derivative];</span>
<!--l. 1373--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">xspde(p);</span>                                                  </div></div>
                                                                                
                                                                                
</div>
<!--l. 1377--><p class="indent" >  Note the following points to remember:
<ul class="itemize1">     
<li class="itemize">
<!--l. 1379--><p class="noindent" >\(\mathtt {p.}[label1]=[parameter1]\) defines a parameter in the structure \(p\).
</li>     
<li class="itemize">
<!--l. 1381--><p class="noindent" >There are many possible inputs, which all have default values.
</li>     
<li class="itemize">
<!--l. 1382--><p class="noindent" >You don’t have to save the data if you want an immediate plot.
</li>     
<li class="itemize">
<!--l. 1383--><p class="noindent" >The notation \(\mathtt {p.deriv=}\mathtt {@(a,w,p)}\,\,[derivative]\) defines a function, \(da/dt\).
</li>     
<li class="itemize">
<!--l. 1385--><p class="noindent" >In this example, \(\mathtt {a}\) is the stochastic variable, \(\mathtt {w}\) the random noise, \(p\) a structure.
</li>     
<li class="itemize">
<!--l. 1387--><p class="noindent" >Other labels can be used instead of <span 
class="ec-lmri-10x-x-109">(a,w,p) </span>if preferred.</li></ul>
<!--l. 1390--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">4.2</span>  <a 
 id="x1-460004.2"></a>Input parameters</h3>
<!--l. 1392--><p class="noindent" >All xSPDE simulations use a structure for input data. Most functions also require a parameter
structure, combining the data input with additional internal parameters. Any naming
convention will do for either structure, as long as you are consistent.
<!--l. 1397--><p class="indent" >  User-defined parameters can be added freely. To ensure that there is no clash
with internal variables, it is best if user defined parameters start with a capital
letter.
<!--l. 1401--><p class="indent" >  The xSPDE inputs have default values, which are used if the input values are omitted. If
you only need the first element of a vector or array, just input the value required. Parameters
can be output with the verbose switch, <span 
class="ec-lmtt-10x-x-109">p.verbose</span>. This has four levels of output: \(-1\),\(0\), \(1\)
or \(2\), with <span 
class="ec-lmtt-10x-x-109">p.verbose=0 </span>as default, giving final error reports. To get more progress
details and individual errors, use <span 
class="ec-lmtt-10x-x-109">p.verbose=1. </span>To eliminate almost everything, use
<span 
class="ec-lmtt-10x-x-109">p.verbose=-1. </span>For maximum information, including all the internal parameter values,
use;
                                                                                
                                                                                
<div class="center" 
>
<!--l. 1410--><p class="noindent" >
<div class="doublebox"><div class="minipage"><span 
class="ec-lmtt-10x-x-109">p.verbose = 2;</span>                                            </div></div>
</div>
<!--l. 1416--><p class="indent" >  While this level of detail is not usually needed, it can be useful to print out all the internal
parameters and default values to understand how the program operates.
<!--l. 1420--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">4.2.1</span>  <a 
 id="x1-470004.2.1"></a>Simulation parameters table</h4>
<!--l. 1422--><p class="noindent" >The most common xSPDE input parameters used to define the equations in a simulation,
together with their default values are: <br 
class="newline" />
<div class="center" 
>
<!--l. 1425--><p class="noindent" >
<div class="tabular"> <table id="TBL-2" class="tabular" 
 
><colgroup id="TBL-2-1g"><col 
id="TBL-2-1"></colgroup><colgroup id="TBL-2-2g"><col 
id="TBL-2-2"></colgroup><colgroup id="TBL-2-3g"><col 
id="TBL-2-3"></colgroup><colgroup id="TBL-2-4g"><col 
id="TBL-2-4"></colgroup><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-1-"><td  style="white-space:nowrap; text-align:center;" id="TBL-2-1-1"  
class="td11">    Label       </td>
                  <td  style="white-space:nowrap; text-align:center;" id="TBL-2-1-2"  
class="td11">    Type      </td>
                                <td  style="white-space:nowrap; text-align:center;" id="TBL-2-1-3"  
class="td11">Default value</td>
                                               <td  style="white-space:nowrap; text-align:center;" id="TBL-2-1-4"  
class="td11">         Description               </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-2-"><td  style="white-space:nowrap; text-align:center;" id="TBL-2-2-1"  
class="td11">     <span 
class="ec-lmri-10x-x-109">fields       </span></td>
                  <td  style="white-space:nowrap; text-align:center;" id="TBL-2-2-2"  
class="td11">integer vector</td>
                                <td  style="white-space:nowrap; text-align:center;" id="TBL-2-2-3"  
class="td11">      \(1\)      </td>
                                               <td  style="white-space:nowrap; text-align:center;" id="TBL-2-2-4"  
class="td11">   Number of stochastic <span 
class="ec-lmri-10x-x-109">fields    </span></td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-3-"><td  style="white-space:nowrap; text-align:center;" id="TBL-2-3-1"  
class="td11">    <span 
class="ec-lmri-10x-x-109">noises       </span></td>
                  <td  style="white-space:nowrap; text-align:center;" id="TBL-2-3-2"  
class="td11">integer vector</td>
                                <td  style="white-space:nowrap; text-align:center;" id="TBL-2-3-3"  
class="td11">      \(1\)      </td>
                                               <td  style="white-space:nowrap; text-align:center;" id="TBL-2-3-4"  
class="td11">       Number of <span 
class="ec-lmri-10x-x-109">noises          </span></td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-4-"><td  style="white-space:nowrap; text-align:center;" id="TBL-2-4-1"  
class="td11">     <span 
class="ec-lmri-10x-x-109">name       </span></td>
                  <td  style="white-space:nowrap; text-align:center;" id="TBL-2-4-2"  
class="td11">   string     </td>
                                <td  style="white-space:nowrap; text-align:center;" id="TBL-2-4-3"  
class="td11">     ’ ’       </td>
                                               <td  style="white-space:nowrap; text-align:center;" id="TBL-2-4-4"  
class="td11">       Simulation <span 
class="ec-lmri-10x-x-109">name          </span></td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-5-"><td  style="white-space:nowrap; text-align:center;" id="TBL-2-5-1"  
class="td11">     <span 
class="ec-lmri-10x-x-109">deriv       </span></td>
                  <td  style="white-space:nowrap; text-align:center;" id="TBL-2-5-2"  
class="td11">  function    </td>
                                <td  style="white-space:nowrap; text-align:center;" id="TBL-2-5-3"  
class="td11">     0        </td>
                                               <td  style="white-space:nowrap; text-align:center;" id="TBL-2-5-4"  
class="td11">    The stochastic <span 
class="ec-lmri-10x-x-109">deriv</span>ative      </td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-6-"><td  style="white-space:nowrap; text-align:center;" id="TBL-2-6-1"  
class="td11"> <span 
class="ec-lmri-10x-x-109">initial </span></td>
                  <td  style="white-space:nowrap; text-align:center;" id="TBL-2-6-2"  
class="td11">  function    </td>
                                <td  style="white-space:nowrap; text-align:center;" id="TBL-2-6-3"  
class="td11">     0        </td>
                                               <td  style="white-space:nowrap; text-align:center;" id="TBL-2-6-4"  
class="td11"> Function to <span 
class="ec-lmri-10x-x-109">initial</span>ize variables  </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-7-"><td  style="white-space:nowrap; text-align:center;" id="TBL-2-7-1"  
class="td11">    <span 
class="ec-lmri-10x-x-109">method      </span></td>
                  <td  style="white-space:nowrap; text-align:center;" id="TBL-2-7-2"  
class="td11">  function    </td>
                                <td  style="white-space:nowrap; text-align:center;" id="TBL-2-7-3"  
class="td11">   [see <a 
href="#x1-1110007">7<!--tex4ht:ref: sec:Algorithms --></a>]     </td>
                                               <td  style="white-space:nowrap; text-align:center;" id="TBL-2-7-4"  
class="td11">      Integration <span 
class="ec-lmri-10x-x-109">method         </span></td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-8-"><td  style="white-space:nowrap; text-align:center;" id="TBL-2-8-1"  
class="td11">   <span 
class="ec-lmri-10x-x-109">ensembles    </span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-2-8-2"  
class="td11">integer vector</td><td  style="white-space:nowrap; text-align:center;" id="TBL-2-8-3"  
class="td11">   [1,1,1]     </td><td  style="white-space:nowrap; text-align:center;" id="TBL-2-8-4"  
class="td11">    Stochastic <span 
class="ec-lmri-10x-x-109">ensemble </span>sizes      </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-9-"><td  style="white-space:nowrap; text-align:center;" id="TBL-2-9-1"  
class="td11">    <span 
class="ec-lmri-10x-x-109">ranges       </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-2-9-2"  
class="td11"> real vector  </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-2-9-3"  
class="td11">    [10]      </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-2-9-4"  
class="td11">    Time and space <span 
class="ec-lmri-10x-x-109">ranges       </span></td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-10-"><td  style="white-space:nowrap; text-align:center;" id="TBL-2-10-1"  
class="td11">     <span 
class="ec-lmri-10x-x-109">points       </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-2-10-2"  
class="td11">integer vector</td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-2-10-3"  
class="td11">    [51]      </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-2-10-4"  
class="td11">Output lattice <span 
class="ec-lmri-10x-x-109">points </span>in [t,x,y,z,..]</td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-11-"><td  style="white-space:nowrap; text-align:center;" id="TBL-2-11-1"  
class="td11">     <span 
class="ec-lmri-10x-x-109">steps       </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-2-11-2"  
class="td11">   integer     </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-2-11-3"  
class="td11">      \([1]\)      </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-2-11-4"  
class="td11">Intermediate <span 
class="ec-lmri-10x-x-109">steps </span>per time point</td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-12-"><td  style="white-space:nowrap; text-align:center;" id="TBL-2-12-1"  
class="td11">   <span 
class="ec-lmri-10x-x-109">observe</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}    </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-2-12-2"  
class="td11">  function    </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-2-12-3"  
class="td11">     <span 
class="ec-lmri-10x-x-109">a       </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-2-12-4"  
class="td11"> <span 
class="ec-lmri-10x-x-109">Observ</span>able function for averages </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-13-"><td  style="white-space:nowrap; text-align:center;" id="TBL-2-13-1"  
class="td11">  <span 
class="ec-lmri-10x-x-109">compare</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}   </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-2-13-2"  
class="td11">  function    </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-2-13-3"  
class="td11">     <span 
class="ec-lmri-10x-x-109">0        </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-2-13-4"  
class="td11"><span 
class="ec-lmri-10x-x-109">Compar</span>ison function for averages</td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-14-"><td  style="white-space:nowrap; text-align:center;" id="TBL-2-14-1"  
class="td11"><span 
class="ec-lmri-10x-x-109">binranges</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}</span><span 
class="ec-lmri-10x-x-109">{m</span><span 
class="ec-lmri-10x-x-109">}</span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-2-14-2"  
class="td11">   vector     </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-2-14-3"  
class="td11">     [0]       </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-2-14-4"  
class="td11"> <span 
class="ec-lmri-10x-x-109">Bin</span>ning <span 
class="ec-lmri-10x-x-109">ranges </span>for probabilities </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-15-"><td  style="white-space:nowrap; text-align:center;" id="TBL-2-15-1"  
class="td11">              </td></tr></table></div>
</div>
<!--l. 1460--><p class="indent" >  A more detailed explanation of these parameters is found below, and a complete table is
given in section <a 
href="#x1-1560009.2">9.2<!--tex4ht:ref: sec:Simulation-parameters --></a>.
<!--l. 1463--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">4.2.2</span>  <a 
 id="x1-480004.2.2"></a>Graphics parameters</h4>
<!--l. 1465--><p class="noindent" >The generated average data can be graphed using any graphics editors, or else using the
internal xGRAPH function defined for this purpose. An xSPDE simulation can return many
different averages. These are defined in a cell array with indices in braces. The index is used to
address the output data produced.
                                                                                
                                                                                
<!--l. 1471--><p class="indent" >  For each index, one can define parameters that define the quantity stored, together with
corresponding graphics outputs. Some commonly used options are:<br 
class="newline" />
<div class="center" 
>
<!--l. 1475--><p class="noindent" >
<div class="tabular"> <table id="TBL-3" class="tabular" 
 
><colgroup id="TBL-3-1g"><col 
id="TBL-3-1"></colgroup><colgroup id="TBL-3-2g"><col 
id="TBL-3-2"></colgroup><colgroup id="TBL-3-3g"><col 
id="TBL-3-3"></colgroup><colgroup id="TBL-3-4g"><col 
id="TBL-3-4"></colgroup><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-3-1-"><td  style="white-space:nowrap; text-align:center;" id="TBL-3-1-1"  
class="td11">   Label     </td>
               <td  style="white-space:nowrap; text-align:center;" id="TBL-3-1-2"  
class="td11"> Type </td>
                        <td  style="white-space:nowrap; text-align:center;" id="TBL-3-1-3"  
class="td11">Default value</td>
                                      <td  style="white-space:nowrap; text-align:center;" id="TBL-3-1-4"  
class="td11">             Description                     </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-3-2-"><td  style="white-space:nowrap; text-align:center;" id="TBL-3-2-1"  
class="td11">  <span 
class="ec-lmri-10x-x-109">olabels</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}   </span></td>
               <td  style="white-space:nowrap; text-align:center;" id="TBL-3-2-2"  
class="td11"> string </td>
                        <td  style="white-space:nowrap; text-align:center;" id="TBL-3-2-3"  
class="td11">    <span 
class="ec-lmri-10x-x-109">’a’       </span></td>
                                      <td  style="white-space:nowrap; text-align:center;" id="TBL-3-2-4"  
class="td11">           Observable label                  </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-3-3-"><td  style="white-space:nowrap; text-align:center;" id="TBL-3-3-1"  
class="td11"><span 
class="ec-lmri-10x-x-109">transverse</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">} </span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-3-3-2"  
class="td11">integer</td><td  style="white-space:nowrap; text-align:center;" id="TBL-3-3-3"  
class="td11">      \(0\)      </td><td  style="white-space:nowrap; text-align:center;" id="TBL-3-3-4"  
class="td11">        Transverse slices in time             </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-3-4-"><td  style="white-space:nowrap; text-align:center;" id="TBL-3-4-1"  
class="td11"><span 
class="ec-lmri-10x-x-109">transforms</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}</span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-3-4-2"  
class="td11">vector</td><td  style="white-space:nowrap; text-align:center;" id="TBL-3-4-3"  
class="td11">      \(0\)      </td><td  style="white-space:nowrap; text-align:center;" id="TBL-3-4-4"  
class="td11">  Set to 1 for Fourier transforms in time   </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-3-5-"><td  style="white-space:nowrap; text-align:center;" id="TBL-3-5-1"  
class="td11"> <span 
class="ec-lmri-10x-x-109">scatters</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}  </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-3-5-2"  
class="td11">integer</td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-3-5-3"  
class="td11">      \(0\)      </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-3-5-4"  
class="td11">Set to s for s scatter plots in the observable</td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-3-6-"><td  style="white-space:nowrap; text-align:center;" id="TBL-3-6-1"  
class="td11">            </td></tr></table></div><br />
</div>
<!--l. 1493--><p class="indent" >  The full definition of the options is given in the user guide in sections <a 
href="#x1-1600009.4">9.4<!--tex4ht:ref: sec:xSIM-parameters --></a> and <a 
href="#x1-22200010">10<!--tex4ht:ref: sec:xGRAPH-reference --></a>, although
most will be clear from examples.
<!--l. 1497--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">4.3</span>  <a 
 id="x1-490004.3"></a>Fields and noises</h3>
<!--l. 1499--><p class="noindent" >Stochastic variables in an SDE are <span 
class="ec-lmri-10x-x-109">fields</span>, stored in a real or complex matrix, \(a(i,j)\). Here, \(i\) is an
internal field index, while \(e\) is the ensemble index.
<dl class="description"><dt class="description">     
<!--l. 1503--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">fields</span> 
</dt><dd 
class="description">
<!--l. 1503--><p class="noindent" >gives the range of the first internal index. This is the total number of SDE variables
or fields. It has a default value of \(fields=1\).
</dd>     
<dt class="description">
<!--l. 1506--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">ensembles</span> 
</dt><dd 
class="description">
<!--l. 1506--><p class="noindent" >allows multiple trajectories to be integrated. This has up to three components. The
first component, <span 
class="ec-lmri-10x-x-109">ensembles(1), </span>gives a vector of local trajectories, so \(e=1,\ldots \)<span 
class="ec-lmri-10x-x-109">ensembles(1)</span>.
The two other ensemble values specify serial or parallel processing, as explained
below.
</dd>     
<dt class="description">
<!--l. 1511--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">noises</span> 
</dt><dd 
class="description">
<!--l. 1511--><p class="noindent" >are noise dimensions, similar to <span 
class="ec-lmri-10x-x-109">fields</span>, and used as \(w(i,j),\) where the first noise index has
     
\(noises\) components. The default value is \(noises=fields\).</dd></dl>
                                                                                
                                                                                

<!--l. 1515--><p class="noindent" >In the example above, we could add the fields, dimensions, ensembles and noises:
<div class="doublebox"><div class="minipage"><span 
class="ec-lmtt-10x-x-109">p.fields = 1;</span>
<!--l. 1521--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.dimensions = 1;</span>
<!--l. 1523--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.noises = 1;</span>
<!--l. 1525--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.ensembles = 1;</span>                                          </div></div>
<!--l. 1528--><p class="indent" >  As these are all default values, this is superfluous in a simple case. The full definition of
ensembles as a vector is given below, and in some cases uses the parallel toolbox in
Matlab.
<!--l. 1532--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">4.3.1</span>  <a 
 id="x1-500004.3.1"></a>Initial values, points and ranges</h4>
<!--l. 1534--><p class="noindent" >Initial values are required to define any differential equation, and in a numerical calculation
one must also have a defined lattice.
<dl class="description"><dt class="description">     
<!--l. 1537--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">initial</span> 
</dt><dd 
class="description">
<!--l. 1537--><p class="noindent" >The initial value is defined by a function  \(p.initial\). This must return either an initial vector
of size <span 
class="ec-lmri-10x-x-109">fields</span>, or else a random array of size \(fields\times ensembles(1)\). The default function simply returns
zero.
</dd>     
<dt class="description">
<!--l. 1541--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">inrandoms</span> 
</dt><dd 
class="description">
<!--l. 1541--><p class="noindent" >are initial random number dimensions, similar to <span 
class="ec-lmri-10x-x-109">fields</span>, and used as \(v(i,j),\) where the
first random dimension has \(randoms\) components. The default value is \(randoms=noises\). Specifies the first
argument of the function  \(p.initial(v,p)\) as a real Gaussian noise vector \(v\) with unit variance. The
same noise is used when error-checking, so that changes are from the step-size, not
from random fluctuations.
</dd>     
<dt class="description">
<!--l. 1548--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">points</span> 
</dt><dd 
class="description">
<!--l. 1548--><p class="noindent" >The number of integration points. The default setting is currently \(51\).
</dd>     
<dt class="description">
<!--l. 1550--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">steps</span> 
</dt><dd 
class="description">
<!--l. 1550--><p class="noindent" >The number of integration steps used for each output time-step. The default is \(1\).
                                                                                
                                                                                
     
</dd>
<dt class="description">     
<!--l. 1552--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">ranges</span> 
</dt><dd 
class="description">
<!--l. 1552--><p class="noindent" >The total integration range in each dimension, the first element being the maximum
integration time \(T\). The default setting is currently \(10\).</dd></dl>
<!--l. 1557--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">4.3.2</span>  <a 
 id="x1-510004.3.2"></a>Observables\( \)</h4>
<dl class="description"><dt class="description">     
<!--l. 1559--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">observe</span> 
</dt><dd 
class="description">
<!--l. 1559--><p class="noindent" >is a cell array of functions of stochastic fields, each defining an average. xSPDE
expects a (named or anonymous) function that takes two parameters, namely the
field matrix \(a\) and the input structure \(p\). The function must return a real or complex
matrix of dimension \((\ell ,ensembles(1))\), where \(\ell \) indexes over a vector observable. xSPDE then averages
over the second index, to calculate the observable.<br 
class="newline" />To plot the variance, for example:</dd></dl>
<div class="doublebox"><div class="minipage"><span 
class="ec-lmtt-10x-x-109">p.observe</span><span 
class="ec-lmtt-10x-x-109">{1</span><span 
class="ec-lmtt-10x-x-109">} = @(a,p) (a(1,:)-mean(a,2)).</span><span 
class="ec-lmtt-10x-x-109">^2;</span>            </div></div>
<dl class="description"><dt class="description">     
<!--l. 1572--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">rawdata</span> 
</dt><dd 
class="description">
<!--l. 1572--><p class="noindent" >By  setting  <span 
class="ec-lmri-10x-x-109">p.rawdata=1  </span>(see  section  <a 
href="#x1-1600009.4">9.4<!--tex4ht:ref: sec:xSIM-parameters --></a>),  one  can  also  store  the  trajectories
themselves, but this is very memory-intensive for large simulations.
</dd>     
<dt class="description">
<!--l. 1575--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">olabels</span> 
</dt><dd 
class="description">
<!--l. 1575--><p class="noindent" >is cell array of graph labels associated with each average, although one can also
define a function of the averages to be graphed with this label.</dd></dl>
<!--l. 1579--><p class="noindent" >Observables are computed as a two-dimensional packed array, then unpacked for storage, giving
an array of dimension \((d1,dspacetime,ensemble(1))\). Here \(d1\) is the local observable dimension, so \(d1=1\) for a scalar
observable. The space-time dimension is \(dspacetime=1\) for an SDE, otherwise a vector for a SPDE,
and \(ensemble(1)\) is the size of the ensemble of trajectories computed in each processor. Once
data is averaged internally over \(ensemble(1)\), further transforms of the resulting averages are
available.
                                                                                
                                                                                
<!--l. 1588--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">4.3.3</span>  <a 
 id="x1-520004.3.3"></a>Using the dot</h4>
<!--l. 1590--><p class="noindent" >All equations entered in xSPDE utilize the Matlab syntax. This is designed to handle scientific
or mathematical matrix and array-based formulae. It has features to simplify matrix or array
equations which often require a ’dot’ or a ’colon’.
<ul class="itemize1">     
<li class="itemize">
<!--l. 1595--><p class="noindent" >Stochastic variables in xSPDE are matrices or arrays, where the last index is used
to treat parallel stochastic trajectories, for greater efficiency. This requires use of
the ’dot’ notation to perform multiplication inside equations.
</li>     
<li class="itemize">
<!--l. 1599--><p class="noindent" >To multiply vectors, matrices or arrays element-wise, like \(a_{ij}=b_{ij}c_{ij}\), the notation \(a=b.*c\) indicates
that all the elements are multiplied. This is used to speed up calculations in parallel.
</li>     
<li class="itemize">
<!--l. 1602--><p class="noindent" >An equation in xSPDE can apply to many stochastic trajectories in parallel. Using
the dot shortens the equation, and it also means that a fast parallel arithmetic will
be used. The same principle holds for larger arrays with spatial lattices, treated in
in section <a 
href="#x1-650005">5<!--tex4ht:ref: sec:Simulating-an-SPDE --></a>.
</li>     
<li class="itemize">
<!--l. 1606--><p class="noindent" >Broadcasting occurs if one or more dimensions has a unit size. For example, arrays
of size (1,100) and (6,1) can be added or multiplied to give a (6,100) matrix.
</li>     
<li class="itemize">
<!--l. 1609--><p class="noindent" >A formula for a stochastic field may require you to address the first index - which
is the field component - and treat all the other elements in parallel. To do this in a
compact way, one may use the notation \(a(1,:)\), which indicates that all the subsequent
index elements are being addressed as well.
</li>     
<li class="itemize">
<!--l. 1614--><p class="noindent" >For an an SPDE this can “flatten” a larger array into a matrix. This requires care
to make sure all the terms have the same dimensionality as described in section <a 
href="#x1-650005">5<!--tex4ht:ref: sec:Simulating-an-SPDE --></a>.
xSPDE includes routines to help this issue.</li></ul>
<!--l. 1619--><p class="noindent" >In summary, whenever a formula combines multiplication operations over spatial lattices or
ensembles, <span 
class="ec-lmbx-10x-x-109">USE THE DOT</span>.
                                                                                
                                                                                
<!--l. 1622--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">4.4</span>  <a 
 id="x1-530004.4"></a>Advanced random walk</h3>
<!--l. 1624--><p class="noindent" >We now return to the random walk, but with some more advanced features: \begin {equation}  \dot {a}=w(t)\,,  \end {equation}
<!--l. 1629--><p class="indent" >  This is integrated numerically and graphed with \(N=points(1)\) points. The first point stored is the initial
value, so there are \(N-1\) integration steps, of length \(dt=ranges(1)/(N-1)\). Numerical graphs have discrete steps, and
more detail is obtained if more time steps are used. The default value is \(N=51\), which is predefined
in the \(xpreferences\) file. This is adjustable by the user. It can also be changed for a simulation, by inputting
a new value of \(points\).
<!--l. 1637--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">4.4.1</span>  <a 
 id="x1-540004.4.1"></a>Simple xSPDE example</h4>
<!--l. 1639--><p class="noindent" >Unless you type <span 
class="ec-lmri-10x-x-109">clear </span>first, any changes to the input structure are additive; so in the exercises
you should get the combination of all the previous structure inputs as well as your new
input.
<ul class="itemize1">     
<li class="itemize">
<!--l. 1643--><p class="noindent" ><span 
class="ec-lmbx-10x-x-109">Run the complete xSPDE script of Example 1 in Matlab.</span></li></ul>
<!--l. 1645--><p class="noindent" >It is simple to cut and paste from an electronic file to the command window. Be careful; pasting
can cause subtle changes that may require correction. Some generated characters may be
invalid input characters, and these will need retyping if this occurs.
<!--l. 1650--><p class="indent" >  You should get the output in Fig (<a 
href="#x1-44001r1">4.1<!--tex4ht:ref: fig:The-simplest-case: Wiener --></a>).
<ul class="itemize1">     
<li class="itemize">
<!--l. 1652--><p class="noindent" ><span 
class="ec-lmbx-10x-x-109">What do you see if you average over</span> \(10000\) <span 
class="ec-lmbx-10x-x-109">trajectories ?</span></li></ul>
<div class="center" 
>
<!--l. 1655--><p class="noindent" >
<div class="doublebox"><div class="minipage"><span 
class="ec-lmtt-10x-x-109">p.ensembles = 10000;</span>
<!--l. 1659--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">xspde(p);</span>                                                  </div></div>
</div>     
<ul class="itemize1">
<li class="itemize">     
<!--l. 1663--><p class="noindent" ><span 
class="ec-lmbx-10x-x-109">What  do  you  see  if  you  plot  the  mean  square  distance?  Note  that</span>
<span 
class="ec-lmbx-10x-x-109">variances should increase linearly with</span> \(t\)<span 
class="ec-lmbx-10x-x-109">.</span></li></ul>
                                                                                
                                                                                
<div class="center" 
>
<!--l. 1666--><p class="noindent" >
<div class="doublebox"><div class="minipage"><span 
class="ec-lmtt-10x-x-109">p.observe = @(a,p) a.</span><span 
class="ec-lmtt-10x-x-109">^2;</span>
<!--l. 1671--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.olabels = ’</span><span 
class="ec-lmtt-10x-x-109">&#x003C;a</span><span 
class="ec-lmtt-10x-x-109">^2</span><span 
class="ec-lmtt-10x-x-109">&#x003E;’;</span>
<!--l. 1673--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">xspde(p);</span>                                                  </div></div>
</div>     
<ul class="itemize1">
<li class="itemize">     
<!--l. 1677--><p class="noindent" ><span 
class="ec-lmbx-10x-x-109">What if you add a force that takes the particle back to the origin?</span>
\begin {equation}  \dot {a}=-a+w(t)\,,\label {eq: damped_path_with_noise}  \end {equation}     
</li></ul>
<div class="center" 
>
<!--l. 1683--><p class="noindent" >
<div class="doublebox"><div class="minipage"><span 
class="ec-lmtt-10x-x-109">p.deriv = @(a,w,p) -a+w;</span>
<!--l. 1687--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">xspde(p);</span>                                                  </div></div>
</div>
<!--l. 1691--><p class="indent" >  The corresponding Fokker-Planck equation from Eq \eqref{eq:FPE} is: \begin {equation}  \frac {\partial P\left (a\right )}{\partial t}=\left [\frac {\partial }{\partial a}+\frac {1}{2}\frac {\partial ^{2}}{\partial a^{2}}\right ]P\left (a\right ).  \end {equation}
It is easy to verify that inserting this dynamical equation into Eq \eqref{eq:moment_equn}
gives the result: \begin {equation}  \frac {\partial }{\partial t}\left \langle a^{2}\right \rangle =1-2\left \langle a^{2}\right \rangle  \end {equation}
<ul class="itemize1">     
<li class="itemize">
<!--l. 1702--><p class="noindent" >Solve for \(\left \langle a^{2}\left (t\right )\right \rangle \) and use xSPDE to compare the numerical and analytic solutions. The
current time is accessible as the parameter \(p.t\). Can you explain the graph differences?</li></ul>
<!--l. 1708--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">4.5</span>  <a 
 id="x1-550004.5"></a>Probability binning</h3>
<!--l. 1710--><p class="noindent" >It is possible to graph probability densities of real observables instead of averages, if \(p.ensembles\) is large.
This is achieved by inputting the observable number and binning range:
<!--l. 1716--><p class="indent" >  \begin {equation}  p.binranges\{n\}=\{oa:ostep:ob\};  \end {equation}
<!--l. 1718--><p class="indent" >  If present, this returns probability density of the \(n\)-th observable \(o\{n\}\), through binning into
ranges of width \(ostep\) around the centers of each bin, starting at \(\text {\emph {oa}}\), and ending at \(ob\). The
simulation returns a result of \(1/ostep\) in the \(j-th\) bin if the trajectory is inside the bin, so that
                                                                                
                                                                                
\(o(j)-ostep/2&lt;o&lt;o(j)+ostep/2\), and zero otherwise. This gives a probability density on output, plotted against
time. Note that on graphing, an extra dimension is added for the variable \(o\). The
probability density at <span 
class="ec-lmri-10x-x-109">ntimes </span>equally spaced simulation times can be plotted with
<span 
class="ec-lmri-10x-x-109">p.transverse</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}=ntimes</span>.
<!--l. 1728--><p class="indent" >  The probability can be plotted for any <span 
class="ec-lmri-10x-x-109">observe </span>function of the stochastic variable.
<!--l. 1731--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">4.5.1</span>  <a 
 id="x1-560004.5.1"></a>Multivariate probabilities</h4>
<!--l. 1733--><p class="noindent" >The probability density is multivariate for vector observables. This is possible because the
binning ranges are stored in a cell array, which may contain several bin vectors. If the
observable \(o\{n\}\) is two-dimensional, then one can input:
<!--l. 1740--><p class="indent" >  \begin {equation}  p.binranges\{n\}=\{oa(1):ostep(1):ob(1),oa(2):ostep(2):ob(2)\};  \end {equation}
<!--l. 1742--><p class="indent" >  On graphing, <span 
class="ec-lmri-10x-x-109">two </span>extra dimensions are added for the variable \(o\) in this case. The graphics
program <span 
class="ec-lmri-10x-x-109">xGRAPH </span>will attempt to graph them, but it is limited by graphical visualization
constraints. In general, an arbitrary observable dimension is possible, but this is also limited
by the sampling and memory, since the number of samples per bin will decrease rapidly with
dimensionality.
<!--l. 1749--><p class="indent" >  The graphics program extracts slices and windows of probabilities if required. To plot the
probabilities of two observables, one for a range of \(-5:5\) and the other for 0:25 for a range of 0:1,
add the following inputs before the <span 
class="ec-lmri-10x-x-109">xsim </span>or <span 
class="ec-lmri-10x-x-109">xspde </span>command:
<div class="center" 
>
<!--l. 1753--><p class="noindent" >
<div class="doublebox"><div class="minipage">p.<span 
class="ec-lmtt-10x-x-109">binranges</span><span 
class="ec-lmtt-10x-x-109">{1</span><span 
class="ec-lmtt-10x-x-109">} = </span><span 
class="ec-lmtt-10x-x-109">{-5:0.25:5</span><span 
class="ec-lmtt-10x-x-109">};</span>
<!--l. 1757--><p class="noindent" >p.<span 
class="ec-lmtt-10x-x-109">binranges</span><span 
class="ec-lmtt-10x-x-109">{2</span><span 
class="ec-lmtt-10x-x-109">} = </span><span 
class="ec-lmtt-10x-x-109">{0:0.5:25</span><span 
class="ec-lmtt-10x-x-109">};</span>                              </div></div>
</div>
<!--l. 1761--><p class="indent" >  In the case of a two-dimensional probability density, plotted against time, there are a total
of four graphics dimensions. That is, one dimension for time, two for the observable
dimensions, and one for the probability itself. One can also plot how the probability density
changes in space for the case of a stochastic partial differential equation, as described in
section <a 
href="#x1-650005">5<!--tex4ht:ref: sec:Simulating-an-SPDE --></a>.
<!--l. 1768--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">4.6</span>  <a 
 id="x1-570004.6"></a>Time-domain spectra</h3>
<!--l. 1770--><p class="noindent" >To get an output from a temporally Fourier transformed field, set \(transforms\{n\}=1\) for the observable (\(n\)) you
need to calculate in transform space. This parameter is a cell array. It can have a different
value for every observable and for every dimension in space-time, if you have space dimensions
as well.
                                                                                
                                                                                
<!--l. 1776--><p class="indent" >  From Eq \eqref{eq:field-average}, all fields are must be averaged internally, using
trapezoidal integration in time over the integration interval, to give the average midpoint
value. This uses the same interval for fine and coarse integration, to allow comparisons
for error-checking. After this, the resulting step-averaged fields are then Fourier
transformed.
<!--l. 1782--><p class="indent" >  In the simplest case of just one internal step, with no error-checking, this means that the
field used to calculate a spectrum is: \begin {equation}  \begin {split}\bar {a}_{j}=\left ({a}_{j-1}+{a}_{j}\right )/2,\end {split}  \end {equation}
which corresponds to the time in the spectral Fourier transform of: \begin {equation}  \begin {split}\bar {t}_{j}=\left ({t}_{j-1}+{t}_{j}\right )/2.\end {split}  \end {equation}
<!--l. 1793--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">4.6.1</span>  <a 
 id="x1-580004.6.1"></a>Error-checking</h4>
<!--l. 1795--><p class="noindent" >For an error-checking calculation with two internal <span 
class="ec-lmri-10x-x-109">steps</span>, there are three successive
valuations: \(a_{j-1}\), \(a_{j-1/2}\), \(a_{j}\). In this case, for spectral calculations one averages according to: \begin {equation}  \begin {split}\bar {a}_{j}=\left (a_{j-1}+2a_{j-1/2}+a_{j}\right )/4.\end {split}  \end {equation}
<!--l. 1802--><p class="indent" >  In addition, one must define the first field \(\bar {a}_{1}\). Due to the cyclic nature of discrete Fourier
transforms, this is also logically the last field value. This is set equal to the corresponding
cyclic average of the first and last field value, in order to reduce potential aliasing errors at
high frequencies in the resulting spectrum: \begin {equation}  \begin {split}\bar {a}_{1}=\frac {1}{2}\left ({a}_{N}+{a}_{1}\right ),\end {split}  \end {equation}
which corresponds to a time in the spectral Fourier transform of: \begin {equation}  \begin {split}\bar {t}_{1}={t}_{1}-dt/2\sim {t}_{N}+dt/2.\end {split}  \end {equation}
The time integral is carried out numerically as a sum which has \(N=points(1)\) time points of interval \(dt\). In
xSPDE, \(dt=T/(N-1)\), where \(T=ranges(1)\). The ‘effective’ integration time for the Fourier transform time integrals is \(T_{eff}=Ndt=2\pi /d\omega =T\times N/(N-1)=T+dt\).
Aliasing of virtual times higher and lower than the integration time is due to the discrete
Fourier transform.
<!--l. 1821--><p class="indent" >  When there are larger numbers of steps, from using the internal <span 
class="ec-lmri-10x-x-109">steps </span>parameter, there are
more points to Fourier transform. These additional frequencies are computed while
carrying out the Fourier transform, but only the frequency points near zero are
saved. The unused high frequency results are not stored or plotted, to conserve
memory.
<!--l. 1827--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">4.7</span>  <a 
 id="x1-590004.7"></a>Examples</h3>
<!--l. 1829--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">4.7.1</span>  <a 
 id="x1-600004.7.1"></a>Complex damped spectrum</h4>
                                                                                
                                                                                
<!--l. 1831--><p class="noindent" >We consider the spectrum of Eq \eqref{eq: damped_path_with_noise}, a complex noise,
\begin {equation}  \left \langle w\left (t\right )w^{*}\left (t'\right )\right \rangle =\delta \left (t-t'\right ),  \end {equation}
and a random initial equation near the equilibrium value, and a range of \(t=100\), with \(640\) points. Here
there are two real noises.
<!--l. 1839--><p class="indent" >  The input parameters are given below. There are parallel operations here, for ensemble
averaging, so we <span 
class="ec-lmbx-10x-x-109">USE THE DOT</span>.
<div class="center" 
>
<!--l. 1841--><p class="noindent" >
<div class="doublebox"><div class="minipage"><span 
class="ec-lmtt-10x-x-109">clear</span>
<!--l. 1845--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.points = 640;</span>
<!--l. 1847--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.ranges = 100;</span>
<!--l. 1849--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.noises = 2;</span>
<!--l. 1851--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.ensembles = 10000;</span>
<!--l. 1853--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.initial = @(v,p) (v(1,:)+1i*v(2,:))/sqrt(2);</span>
<!--l. 1855--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.deriv = @(a,w,p) -a + w(1,:)+1i*w(2,:);</span>
<!--l. 1857--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.observe = @(a,p) a.*conj(a);</span>
<!--l. 1859--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.transforms = 1;</span>
<!--l. 1861--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.olabels = ’</span><span 
class="ec-lmtt-10x-x-109">|a(</span><span 
class="ec-lmtt-10x-x-109">\omega)</span><span 
class="ec-lmtt-10x-x-109">|</span><span 
class="ec-lmtt-10x-x-109">^2’;</span>
<!--l. 1863--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">xspde(p);</span>                                                  </div></div>
</div>
<!--l. 1867--><p class="indent" >  Note that <span 
class="ec-lmri-10x-x-109">p.</span><span 
class="ec-lmtti-10x-x-109">transforms = 1 </span>tells xSPDE to Fourier transform the field over the
time coordinate before averaging, to give a spectrum. Both <span 
class="ec-lmri-10x-x-109">observe </span>and <span 
class="ec-lmri-10x-x-109">transforms</span>
could be cell arrays, but the this is not needed with a single observable. The first
argument \(v\) of the <span 
class="ec-lmri-10x-x-109">initial </span>function is a random field, used to initialize the stochastic
variable.
<!--l. 1874--><p class="indent" >  To define as many observables as you like, use a Matlab cell array;
<div class="center" 
>
<!--l. 1875--><p class="noindent" >
<div class="doublebox"><div class="minipage"><span 
class="ec-lmtt-10x-x-109">p.observe</span><span 
class="ec-lmtt-10x-x-109">{1</span><span 
class="ec-lmtt-10x-x-109">} = ..;</span>
<!--l. 1879--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.observe</span><span 
class="ec-lmtt-10x-x-109">{2</span><span 
class="ec-lmtt-10x-x-109">} = ..;</span>                                        </div></div>
</div>
<!--l. 1883--><p class="indent" >  To learn more, try the following:
<ul class="itemize1">     
<li class="itemize">
<!--l. 1885--><p class="noindent" ><span 
class="ec-lmbx-10x-x-109">Simulate over a range of</span> \(t=200\)<span 
class="ec-lmbx-10x-x-109">. What changes do you see? Why?</span>
</li>     
<li class="itemize">
<!--l. 1887--><p class="noindent" ><span 
class="ec-lmbx-10x-x-109">Change the equation to the laser noise equations introduced in the next</span>
<span 
class="ec-lmbx-10x-x-109">section (Laser quantum noise). Why is the spectrum much narrower?</span></li></ul>
                                                                                
                                                                                
<!--l. 1892--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">4.7.2</span>  <a 
 id="x1-610004.7.2"></a>Laser amplification noise</h4>
<!--l. 1894--><p class="noindent" >Consider a model for the quantum noise of a single mode laser as it turns on, near
threshold:
<!--l. 1899--><p class="indent" >  \begin {equation}  \dot {a}=ga+bw(t)  \end {equation}
where the noise is complex, \(w=\left (w_{1}+iw_{2}\right )\), so that: \begin {equation}  \left \langle w(t)w^{*}(t')\right \rangle =2\delta \left (t-t'\right )\,.  \end {equation}
<!--l. 1905--><p class="indent" >  Here the coefficient \(b\) describes the quantum noise of the laser, and is inversely proportional
to the equilibrium photon number.
<!--l. 1908--><p class="indent" >  Try the following, noting that you should type <span 
class="ec-lmri-10x-x-109">clear </span>first when starting new simulations.
<ul class="itemize1">     
<li class="itemize">
<!--l. 1911--><p class="noindent" ><span 
class="ec-lmbx-10x-x-109">Solve for the case of</span> \(g=0.1\)<span 
class="ec-lmbx-10x-x-109">,</span> \(b=0.01\)</li></ul>
<!--l. 1913--><p class="noindent" >Most lasers have more than \(100\) photons and hence much less noise than this.
<!--l. 1916--><p class="indent" >  For this exercise, small error-bars will display on the graph. These are calculated from the
difference between using steps of size \(dt\) and steps of size \(dt/2\). They only appear if greater
than a minimum relative size, typically \(1\%\) of the graph size, which can be set by the
user.
<div class="center" 
>
<!--l. 1921--><p class="noindent" >
<div class="doublebox"><div class="minipage"><span 
class="ec-lmtt-10x-x-109">clear</span>
<!--l. 1925--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.noises = 2;</span>
<!--l. 1927--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.observe = @(a,p) abs(a)</span><span 
class="ec-lmtt-10x-x-109">^2;</span>
<!--l. 1929--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.olabels = ’</span><span 
class="ec-lmtt-10x-x-109">|a</span><span 
class="ec-lmtt-10x-x-109">|</span><span 
class="ec-lmtt-10x-x-109">^2’;</span>
<!--l. 1931--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.deriv = @(a,w,p) a + 0.01*(w(1)+1i*w(2));</span>
<!--l. 1933--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">xspde(p);</span>                                                  </div></div>
</div>
<!--l. 1937--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">4.7.3</span>  <a 
 id="x1-620004.7.3"></a>Saturated laser noise</h4>
<!--l. 1939--><p class="noindent" >Consider the case where the laser saturates to a steady state:
<!--l. 1943--><p class="indent" >  \begin {equation}  \dot {a}=\left (1-\left |a\right |^{2}\right )a+bw(t)  \end {equation}
<!--l. 1945--><p class="indent" >  To learn how to use the function inputs, try the following:
<ul class="itemize1">     
<li class="itemize">
<!--l. 1947--><p class="noindent" ><span 
class="ec-lmbx-10x-x-109">Solve for the saturated laser case</span></li></ul>
                                                                                
                                                                                
<!--l. 1949--><p class="noindent" >You should get the output graph in Fig (<a 
href="#x1-62001r2">4.2<!--tex4ht:ref: fig:The-laser --></a>).
<div class="center" 
>
<!--l. 1950--><p class="noindent" >
<div class="doublebox"><div class="minipage"><span 
class="ec-lmtt-10x-x-109">p.deriv = @(a,w,p) (1-abs(a)</span><span 
class="ec-lmtt-10x-x-109">^2)*a+0.01*(w(1)+1i*w(2));</span>
<!--l. 1954--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">xspde(p);</span>                                                  </div></div>
</div>
<!--l. 1958--><p class="indent" >  <figure class="figure"> 

                                                                                
                                                                                
<a 
 id="x1-62001r2"></a>
                                                                                
                                                                                
<!--l. 1959--><p class="noindent" ><img 
src="xFIGURES/Laser.svg" alt="pict"  
 style="width:31.36917em;" >
<figcaption class="caption" ><span class="id">Figure 4.2: </span><span  
class="content">Simulation of the stochastic equation describing a laser turning on.</span></figcaption><!--tex4ht:label?: x1-62001r2 -->
                                                                                
                                                                                
<!--l. 1961--><p class="indent" >  </figure>
  
<h4 class="subsectionHead"><span class="titlemark">4.7.4</span>  <a 
 id="x1-630004.7.4"></a>Financial calculus</h4>
<!--l. 1966--><p class="noindent" >A well-known Ito-type stochastic equation is called the Black-Scholes equation, used to price
financial options. It describes the fluctuations in a stock value: \begin {equation}  da=\mu a\,dt+a\sigma \,dw,  \end {equation}
where \(\left \langle dw^{2}\right \rangle =dt\). Since the noise is multiplicative, the equation is different in Ito and Stratonovich forms
of stochastic calculus.
<!--l. 1976--><p class="indent" >  The corresponding Stratonovich equation, as used in xSPDE for the standard default
integration routine is: \begin {equation}  \dot {a}=\left (\mu -\sigma ^{2}/2\right )a+a\sigma w(t).  \end {equation}
<!--l. 1982--><p class="indent" >  An interactive xSPDE script in Matlab is given below with an output graph in Fig (<a 
href="#x1-63001r3">4.3<!--tex4ht:ref: fig:The-Black-Scholes --></a>).
This is for a startup with a volatile stock having \(\mu =0.1,\,\sigma =1\). The spiky behavior is typical of
multiplicative noise, and also of the more risky stocks in the small capitalization portions of
the stock market.
<div class="center" 
>
<!--l. 1987--><p class="noindent" >
<div class="doublebox"><div class="minipage"><span 
class="ec-lmtt-10x-x-109">clear</span>
<!--l. 1991--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.initial = @(v,p) 1;</span>
<!--l. 1993--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.deriv = @(a,w,p) -0.4*a+a*w;</span>
<!--l. 1995--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">xspde(p);</span>                                                  </div></div>
</div>
<!--l. 1999--><p class="indent" >  <figure class="figure"> 

                                                                                
                                                                                
<a 
 id="x1-63001r3"></a>
                                                                                
                                                                                
<!--l. 2000--><p class="noindent" ><img 
src="xFIGURES/Black-Scholes.svg" alt="pict"  
 style="width:31.36917em;" >
<figcaption class="caption" ><span class="id">Figure 4.3: </span><span  
class="content">Simulation of the Black-Scholes equation describing stock prices.</span></figcaption><!--tex4ht:label?: x1-63001r3 -->
                                                                                
                                                                                
<!--l. 2002--><p class="indent" >  </figure>
<!--l. 2004--><p class="indent" >  Here \(p.initial\) describes the initialization function. The first argument of \(@(v,p)\) is \(v\), an initial random
variable with unit variance. <span 
class="ec-lmri-10x-x-109">The error-bars are estimates of step-size error</span>. Errors can be
reduced by using more time-steps.
<!--l. 2009--><p class="indent" >  To learn more, try the following:
<ul class="itemize1">     
<li class="itemize">
<!--l. 2011--><p class="noindent" ><span 
class="ec-lmbx-10x-x-109">Solve for a more mature stock having</span> \(\mu =0.1,\,\sigma =0.1\)<span 
class="ec-lmbx-10x-x-109">.</span></li></ul>
  
<h4 class="subsectionHead"><span class="titlemark">4.7.5</span>  <a 
 id="x1-640004.7.5"></a>Nonlinear quantum phase-space simulation</h4>
<!--l. 2016--><p class="noindent" >This is a harder example, involving a full nonlinear quantum phase-space simulation. The
method can also be used to investigate quantum non-equilibrium phase transitions, tunneling
in open systems, quantum entanglement, Einstein-Podolsky-Rosen paradoxes, Bell violations,
and many other problems treated in the literature<span class="cite">[<a 
href="#XDrummond2014">6</a>, <a 
href="#Xgardinerhandbook2004">4</a>, <a 
href="#Xgardiner2004quantum">13</a>]</span><a 
 id="x1-64001"></a>.
<!--l. 2022--><p class="indent" >  A simple case is the nonlinear driven quantum subharmonic generator - for example, an
opto-mechanical, superconducting or nonlinear optical medium in a driven cavity.
<!--l. 2026--><p class="indent" >  This has a Stratonovich equation, which is the form treated by the xSPDE software: \begin {align}  \frac {da_{1}}{dt} &amp; =-(c+\frac {1}{2})a_{1}+a_{2}\lambda \left [1-a_{1}^{2}\right ]+\sqrt {1-a_{1}^{2}}w_{1}\left (t\right )\nonumber \\ \frac {da_{2}}{dt} &amp; =-(c+\frac {1}{2})a_{2}+a_{1}\lambda \left [1-a_{2}^{2}\right ]+\sqrt {1-a_{2}^{2}}w_{2}\left (t\right )\,,  \end {align}
<!--l. 2033--><p class="indent" >  where \(w_{1},w_{2}\) are delta-correlated real Gaussian noises.
<!--l. 2035--><p class="indent" >  There is a bistable region, which leads to a discrete time symmetry breaking. The solution
in the steady-state is \begin {equation}  P=\left (1-a_{1}^{2}\right )^{c}\left (1-a_{2}^{2}\right )^{c}e^{2\lambda a_{1}a_{2}}  \end {equation}
<!--l. 2041--><p class="indent" >  The integration manifold is the region of real \(a_{1}\), \(a_{2}\), such that \(a_{1}^{2}\le 1\) , \(a_{2}^{2}\le 1\). There are two physically
possible metastable values of the amplitudes. The physically observed quantity is the
amplitude and number: \begin {align}  \left \langle \hat {a}\right \rangle &amp; =\frac {1}{2}\left \langle a_{1}+a_{2}\right \rangle \nonumber \\ \left \langle \hat {n}\right \rangle &amp; =\left \langle a_{1}a_{2}\right \rangle .  \end {align}
<!--l. 2050--><p class="indent" >  Typical parameters that show bistable behavior are \(c=1\), \(\lambda =4\). To learn more, try the
following:
<ul class="itemize1">     
<li class="itemize">
<!--l. 2053--><p class="noindent" ><span 
class="ec-lmbx-10x-x-109">Simulate the nonlinear oscillator by creating a file,</span> \(Nonlinear.m\)
</li>     
<li class="itemize">
<!--l. 2054--><p class="noindent" ><span 
class="ec-lmbx-10x-x-109">Can you observe quantum tunneling in the bistable regime?</span>
</li>     
<li class="itemize">
<!--l. 2055--><p class="noindent" ><span 
class="ec-lmbx-10x-x-109">Do you see transient Schrodinger ‘cat states’ with a negative n value?</span></li></ul>
                                                                                
                                                                                
<!--l. 2058--><p class="noindent" >Since tunneling is random, for real experimental comparisons, one would have to measure
correlation functions and spectra. However, a tunneling event in a simulation indicates that it
is likely in experiment too. These calculations require long time scales, \(\mathtt {p.ranges}\), to observe tunneling,
and a large number of time steps per plotted time point, \(\mathtt {p.steps}\), to maintain accuracy in the
quantum simulations.
<!--l. 2066--><p class="indent" >
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
  
<h2 class="chapterHead"><span class="titlemark">5</span>  <a 
 id="x1-650005"></a>Solving an SPDE </h2>
<!--l. 2072--><p class="noindent" ><span 
class="ec-lmbxi-10x-x-109">This section describes how to simulate a PDE or SPDE, including choosing</span>
<span 
class="ec-lmbxi-10x-x-109">spectral or finite difference methods and specifying boundary conditions.</span>
  
<h3 class="sectionHead"><span class="titlemark">5.1</span>  <a 
 id="x1-660005.1"></a>Multidimensional Wiener process</h3>
<!--l. 2076--><p class="noindent" >To solve for a single four-dimensional trajectory with three space dimensions, as in Eq
\eqref{eq:Wiener_process-1} , just type in:
<div class="center" 
>
<!--l. 2078--><p class="noindent" >
<div class="doublebox"><div class="minipage"><span 
class="ec-lmtt-10x-x-109">p.dimensions = 4;</span>
<!--l. 2082--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.deriv = @(a,w,p) w;</span>
<!--l. 2084--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">xspde(p);</span>                                                  </div></div>
</div>
<!--l. 2088--><p class="indent" >  Here \(p.deriv\) defines the time derivative \(\dot {a}\) in the input parameter structure <span 
class="ec-lmri-10x-x-109">p, </span>while \(w\) is a
delta-correlated Gaussian noise generated internally. Apart from the dimensions, there are no
other parameters, so default values are used. This produces the graph shown in Fig (<a 
href="#x1-66001r1">5.1<!--tex4ht:ref: fig:The-simplest-case: Wiener-1 --></a>),
which gives a single trajectory.
<div class="center" 
>
<!--l. 2094--><p class="noindent" >
<!--l. 2095--><p class="noindent" ><figure class="figure"> 
<a 
 id="x1-66001r1"></a> <img 
src="xFIGURES/Multi-Wiener.svg" alt="pict"  
 style="width:31.36917em;" >
<figcaption class="caption" ><span class="id">Figure 5.1: </span><span  
class="content">A multidimensional random walk of a three-dimensional field projected onto
\(y=z=0\).</span></figcaption><!--tex4ht:label?: x1-66001r1 -->
<!--l. 2098--><p class="noindent" ></figure>
</div>
<!--l. 2101--><p class="indent" >  For more interesting problems than this, more parameters are needed, as explained
next.
<!--l. 2104--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">5.2</span>  <a 
 id="x1-670005.2"></a>SPDE parameters</h3>
<!--l. 2106--><p class="noindent" >A stochastic partial differential equation or \(SPDE\) for a complex vector field is defined in both time \(t\)
and space dimension(s) \(\mathbf {x}\). The total <span 
class="ec-lmri-10x-x-109">dimensions</span> \(d\) includes both time and space. To solve a
stochastic partial differential equation xSPDE involves a similar procedure to the case of the
SDE, covered in section <a 
href="#x1-420004">4<!--tex4ht:ref: sec:Simulating-an-SDE --></a>.
<!--l. 2112--><p class="indent" >  The numerical solutions require additional parameters to define the spatial grid, and to
define the linear transformations in an interaction picture, if spectral methods are used. The
SPDE input parameters extend those already introduced in (<a 
href="#x1-470004.2.1">4.2.1<!--tex4ht:ref: subsec:Simulation-parameters-1 --></a>). Some new and extended
parameters are listed in the table below:
                                                                                
                                                                                
<div class="center" 
>
<!--l. 2117--><p class="noindent" >
<div class="tabular"> <table id="TBL-4" class="tabular" 
 
><colgroup id="TBL-4-1g"><col 
id="TBL-4-1"></colgroup><colgroup id="TBL-4-2g"><col 
id="TBL-4-2"></colgroup><colgroup id="TBL-4-3g"><col 
id="TBL-4-3"></colgroup><colgroup id="TBL-4-4g"><col 
id="TBL-4-4"></colgroup><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-4-1-"><td  style="white-space:nowrap; text-align:center;" id="TBL-4-1-1"  
class="td11">   Label     </td>
               <td  style="white-space:nowrap; text-align:center;" id="TBL-4-1-2"  
class="td11">    Type      </td>
                              <td  style="white-space:nowrap; text-align:center;" id="TBL-4-1-3"  
class="td11">Typical value</td>
                                            <td  style="white-space:nowrap; text-align:center;" id="TBL-4-1-4"  
class="td11">          Description               </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-4-2-"><td  style="white-space:nowrap; text-align:center;" id="TBL-4-2-1"  
class="td11"> <span 
class="ec-lmri-10x-x-109">dimensions  </span></td>
               <td  style="white-space:nowrap; text-align:center;" id="TBL-4-2-2"  
class="td11">   integer     </td>
                              <td  style="white-space:nowrap; text-align:center;" id="TBL-4-2-3"  
class="td11">      \(2\)      </td>
                                            <td  style="white-space:nowrap; text-align:center;" id="TBL-4-2-4"  
class="td11">     Space-time dimensions        </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-4-3-"><td  style="white-space:nowrap; text-align:center;" id="TBL-4-3-1"  
class="td11">   <span 
class="ec-lmri-10x-x-109">linear     </span></td>
               <td  style="white-space:nowrap; text-align:center;" id="TBL-4-3-2"  
class="td11">  function    </td>
                              <td  style="white-space:nowrap; text-align:center;" id="TBL-4-3-3"  
class="td11"> @(p) p.Dx  </td>
                                            <td  style="white-space:nowrap; text-align:center;" id="TBL-4-3-4"  
class="td11">Linear interaction picture function</td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-4-4-"><td  style="white-space:nowrap; text-align:center;" id="TBL-4-4-1"  
class="td11">   <span 
class="ec-lmri-10x-x-109">ranges     </span></td>
               <td  style="white-space:nowrap; text-align:center;" id="TBL-4-4-2"  
class="td11"> real vector  </td>
                              <td  style="white-space:nowrap; text-align:center;" id="TBL-4-4-3"  
class="td11">  [10,10,...]   </td>
                                            <td  style="white-space:nowrap; text-align:center;" id="TBL-4-4-4"  
class="td11">    Ranges in time and space      </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-4-5-"><td  style="white-space:nowrap; text-align:center;" id="TBL-4-5-1"  
class="td11"><span 
class="ec-lmri-10x-x-109">transforms</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}</span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-4-5-2"  
class="td11">integer vector</td><td  style="white-space:nowrap; text-align:center;" id="TBL-4-5-3"  
class="td11">      \([1,0,1,..]\)      </td><td  style="white-space:nowrap; text-align:center;" id="TBL-4-5-4"  
class="td11">   Space-time transform switch    </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-4-6-"><td  style="white-space:nowrap; text-align:center;" id="TBL-4-6-1"  
class="td11">   <span 
class="ec-lmri-10x-x-109">points     </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-4-6-2"  
class="td11">integer vector</td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-4-6-3"  
class="td11">  [51,35,..]   </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-4-6-4"  
class="td11">Output lattice points in [t,x,y,z,..]</td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-4-7-"><td  style="white-space:nowrap; text-align:center;" id="TBL-4-7-1"  
class="td11">   <span 
class="ec-lmri-10x-x-109">origins     </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-4-7-2"  
class="td11"> real vector  </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-4-7-3"  
class="td11">   [0,-5,..]    </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-4-7-4"  
class="td11">  Space-time integration origin    </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-4-8-"><td  style="white-space:nowrap; text-align:center;" id="TBL-4-8-1"  
class="td11"><span 
class="ec-lmri-10x-x-109">boundaries</span><span 
class="ec-lmri-10x-x-109">{i</span><span 
class="ec-lmri-10x-x-109">} </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-4-8-2"  
class="td11"> integer array </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-4-8-3"  
class="td11">      \([0,0;0,0]\)      </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-4-8-4"  
class="td11">  Boundary type per field index   </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-4-9-"><td  style="white-space:nowrap; text-align:center;" id="TBL-4-9-1"  
class="td11">            </td></tr></table></div>
</div>
<!--l. 2140--><p class="indent" >  Setting \(dimensions&gt;1\) defines an (S)PDE as opposed to an ordinary (S)DE. Here the cell index \(i\)
indicates a field index, and the cell index \(n\) gives the observable output or graph
index.
<!--l. 2144--><p class="indent" >  In the xSPDE implementation, the total space-time <span 
class="ec-lmri-10x-x-109">dimensions </span>is unlimited, although, large
space-time dimensions become memory-intensive and slow. There is a practical limit of about
ten space-time dimensions with current digital computers, unless you have a very large, fast
computer.
<!--l. 2150--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">5.2.1</span>  <a 
 id="x1-680005.2.1"></a>SPDE spatial lattice</h4>
<!--l. 2152--><p class="noindent" >Stochastic variables in an SPDE are stored in a real or complex array, \(a(i,\mathbf {\ell },e)\). Here \(i\) is
the internal field index, \(\mathbf {\ell }\) is a \(d-1\) dimensional spatial lattice index for <span 
class="ec-lmri-10x-x-109">d </span>space-time
dimensions, and \(e\) is the ensemble index. To specify the spatial lattice, one must
define:
<dl class="description"><dt class="description">     
<!--l. 2158--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">dimensions</span> 
</dt><dd 
class="description">
<!--l. 2158--><p class="noindent" >The dimensionality in time and space. The default is an SDE: \(d=1\).
</dd>     
<dt class="description">
<!--l. 2160--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">points</span> 
</dt><dd 
class="description">
<!--l. 2160--><p class="noindent" >The number of integration points. The default is \(\mathbf {N}=[51,35,35..]\).
</dd>     
<dt class="description">
<!--l. 2161--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">ranges</span> 
</dt><dd 
class="description">
<!--l. 2161--><p class="noindent" >The integration ranges in each dimension. The default is \(\mathbf {R}=[10,10,10..]\).
                                                                                
                                                                                
     
</dd>
<dt class="description">     
<!--l. 2163--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">origins</span> 
</dt><dd 
class="description">
<!--l. 2163--><p class="noindent" >The origins of the space-time integration domains. By default, the origin is \(O\left (1\right )=0\) for
the time coordinate and \(\mathbf {O}=-\mathbf {R}/2\) for the space coordinates (\(\mathbf {R}\) is the \(ranges\) variable) such that the
spatial grid is symmetric around \(\mathbf {r}=0\).</dd></dl>
<!--l. 2170--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">5.2.2</span>  <a 
 id="x1-690005.2.2"></a>Initial conditions</h4>
<!--l. 2172--><p class="noindent" >Initial conditions are set at the initial time of \(t=O_{1}\) with a user-defined function so that:
\begin {equation}  a(O_{1})=initial(v,p)  \end {equation}
The <span 
class="ec-lmri-10x-x-109">initial </span>function includes initial random fields \(v=\left [v^{x},v^{k}\right ]\). Their correlations are either delta
correlated or spatially correlated. To allow this, the input parameter \(randoms\) is a vector such that: \(randoms(1)\) is
the number of delta-correlated random fields, \(v^{x}\), and \(randoms(2)\) is the number of correlated random fields,
\(v^{k}\). All random fields in the <span 
class="ec-lmri-10x-x-109">initial </span>function, even if correlated using filters in momentum space,
are transformed to position space before use. If there is no filtering, \(v^{x}\) and \(v^{k}\) have the same
correlations.
<!--l. 2187--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">5.3</span>  <a 
 id="x1-700005.3"></a>Next example</h3>
<!--l. 2189--><p class="noindent" >As another very simple example, consider the SPDE
<div class="eqnarray">\begin {eqnarray}  \frac {\partial a}{\partial t} &amp; = &amp; -\frac {1}{4}a+x\cdot w\label {eq:simple_spde_example}  \end {eqnarray}
</div>
<!--l. 2195--><p class="indent" >  The system has one spatial dimension, or \(d=2\) space-time dimensions, one field and
one noise variable. We suppose that the initial noise variance is Gaussian, with:
\begin {equation}  a(0,x)=10v(x).  \end {equation}
We want to consider \(10,000\) stochastic trajectories per sub-ensemble with\(10\) sub-ensembles. We will set
the origin for \(x\) to \(0\). The variable \(a\) will be initialized as delta-correlated in space with a gaussian
standard deviation on the lattice of \(\sigma =10/\sqrt {\Delta V}\). As our observable, we consider the second moment of
\(a\).
<!--l. 2207--><p class="indent" >  This is simulated through the following xSPDE code:
<div class="center" 
>
<!--l. 2208--><p class="noindent" >
                                                                                
                                                                                
<div class="doublebox"><div class="minipage"><span 
class="ec-lmtt-10x-x-109">clear;</span>
<!--l. 2212--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.name = ’simple SPDE’;</span>
<!--l. 2214--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.dimensions = 2;</span>
<!--l. 2216--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.ensembles = [10000,10];</span>
<!--l. 2218--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.origins = [0,0];</span>
<!--l. 2220--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.noises = 1;</span>
<!--l. 2222--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.initial = @(v,p) 10*v;</span>
<!--l. 2224--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.observe = @(a,</span><span 
class="ec-lmtt-10x-x-109">~) a.</span><span 
class="ec-lmtt-10x-x-109">^2;</span>
<!--l. 2227--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.olabels = ’</span><span 
class="ec-lmtt-10x-x-109">&#x003C;a</span><span 
class="ec-lmtt-10x-x-109">^2</span><span 
class="ec-lmtt-10x-x-109">&#x003E;’;</span>
<!--l. 2229--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.deriv = @(a,w,p) -0.25*a + p.x .* w;</span>
<!--l. 2231--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">xspde(p);</span>                                                  </div></div>
</div>
<!--l. 2235--><p class="indent" >  With this input, Matlab produces two output graphs:
<!--l. 2237--><p class="indent" >  <figure class="figure"> 

                                                                                
                                                                                
<a 
 id="x1-70001r2"></a>
                                                                                
                                                                                
<!--l. 2238--><p class="noindent" ><img 
src="xFIGURES/simple_SPDE1.svg" alt="pict"  
 style="width:20.91278em;" > <img 
src="xFIGURES/simple_SPDE2.svg" alt="pict"  
 style="width:20.91278em;" >
<figcaption class="caption" ><span class="id">Figure 5.2: </span><span  
class="content">Example: simple SPDE output graphs</span></figcaption><!--tex4ht:label?: x1-70001r2 -->
                                                                                
                                                                                
<!--l. 2239--><p class="indent" >  </figure>
<!--l. 2241--><p class="indent" >  The second graph shows the time evolution for \(x\) at the mid-point, \(x=5\).<span id="textcolor1"> </span>The variances are larger
than they would be in the SDE case, where one might expect an initial variance of \(\left \langle a^{2}(0)\right \rangle =100\). The
reason for this is that the initial noise random and noise fields are replaced by a
lattice with a variance of \(1/\Delta V\). In the default case, this causes an increase in the local
noise.
  
<h3 class="sectionHead"><span class="titlemark">5.4</span>  <a 
 id="x1-710005.4"></a>Transverse lattice</h3>
<!--l. 2251--><p class="noindent" >In the functions \(deriv\), \(initial\) and \(observe\), the field and noise variables \(a\) and \(w\) now have extended dimensionality
compared to the \(1\)-dimensional case, to index the transverse lattice. The indices are \(a\left (f,\mathbf {i},e\right )\), where
the:  
<dl class="description"><dt class="description">
<!--l. 2256--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">field</span> 
</dt><dd 
class="description">
<!--l. 2256--><p class="noindent" >index \(f\) corresponds to the field index for \(a\) and the noise index for \(w\).
</dd>     
<dt class="description">
<!--l. 2258--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">intermediate</span> 
</dt><dd 
class="description">
<!--l. 2258--><p class="noindent" >indices \(\mathbf {i},\) which are absent in the \(1\)-dimensional case, correspond to the spatial grid
and  have  the  same  structure.  For  example,  in  the  case  with  <span 
class="ec-lmri-10x-x-109">dimensions = 3</span>,
indicating one time index and two spatial dimension, \(\mathbf {i}\) corresponds to the two space
indices.
</dd>     
<dt class="description">
<!--l. 2263--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">last</span> 
</dt><dd 
class="description"> 
<!--l. 2263--><p class="noindent" >index \(e\) corresponds to the stochastic trajectory.</dd></dl>
<!--l. 2265--><p class="noindent" >For storing space coordinates like \(p.x\), the first and last index are \(f=e=1\). Where Fourier transforms are
used internally, the momentum arrays have zero momentum as the first index to follow
standard discrete Fourier transform conventions. This is changed to a symmetric convention in
all stored graphics data outputs.
<!--l. 2271--><p class="indent" >  As explained in section <a 
href="#x1-350003.9">3.9<!--tex4ht:ref: sec:IP-implementation --></a>, the general equation solved can be written in differential form
as
<!--l. 2276--><p class="indent" >  \begin {equation}  \frac {\partial \mathbf {a}}{\partial t}=\mathbf {A}\left [\mathbf {a}\right ]+\underline {\mathbf {B}}\left [\mathbf {a}\right ]\cdot \mathbf {w}(t)+\underline {\mathbf {L}}\left [\mathbf {\nabla },\mathbf {a}\right ]\,.  \end {equation}
<!--l. 2278--><p class="indent" >  The linear function \(L\) can be input either inside the derivative function using finite difference
operators described below, or as a separate <span 
class="ec-lmri-10x-x-109">linear </span>function, to allow for an interaction picture
in which case: \begin {equation}  \underline {\mathbf {L}}\left [\mathbf {\nabla },\mathbf {a}\right ]=\,\underline {\mathbf {L}}\left [\mathbf {\nabla }\right ]\mathbf {a}\,.  \end {equation}
This depends on momentum space coordinates, which involves Fourier transforms and means
                                                                                
                                                                                
that no space dependence is allowed. Spectral methods in xSPDE are currently restricted to
cases with linear derivative terms and periodic or zero boundary conditions. It is also possible
to use finite differences, in which case the derivative terms are included as part of the
derivative function <span 
class="ec-lmri-10x-x-109">deriv</span>.
<!--l. 2292--><p class="indent" >  The usual FFT spectral methods require periodicity. The four other boundary methods can
currently only be used with the default boundary values of zero, and with an interaction
picture derivative that only has even powers of derivatives. Additional spectral methods will
be included in a subsequent release: xSPDE4.
<!--l. 2298--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">5.4.1</span>  <a 
 id="x1-720005.4.1"></a>Linear operator</h4>
<!--l. 2300--><p class="noindent" >The field \(x\) is provided by the parameter structure, and corresponds to the variable \(x\) in Eq
\eqref{eq:simple_spde_example}. All parameters are preceded by the parameter structure
label. Likewise, for higher dimensional problems, the variables \(y\) and \(z\) exist. These are
placeholders for \(r\{1\},r\{2\},r\{3\}\), so the spatial variables of even higher dimensional problems can be accessed
through \(r\{n\}\).
<!--l. 2307--><p class="indent" >  Using a linear operator in an SPDE gives better accuracy, and allows use of the interaction
picture. This is included automatically for all built-in xSPDE algorithms, provided the <span 
class="ec-lmri-10x-x-109">linear</span>
function is defined in the parameter structure. Variables \(p.D\{i\}\) (with placeholders \(p.Dx,p.Dy,p.Dz\) for the first 3
spatial dimensions) provide access to the derivative operator. Higher-order derivatives are
found through potentiating \(p.Dx\) accordingly.
<!--l. 2315--><p class="indent" >  For example, the \(2\)-dimensional Laplacian operator \begin {equation}  \nabla ^{2}=\frac {\partial ^{2}}{\partial x^{2}}+\frac {\partial ^{2}}{\partial y^{2}}  \end {equation}
corresponds to a linear differential operator specified as: \begin {equation}  p.linear=@(p)\,\,\,p.Dx.^{2}+p.Dy^{2};  \end {equation}
For a comprehensive list of variables accessible through the \(p\)-structure, refer to sec.
<a 
href="#x1-2180009.8">9.8<!--tex4ht:ref: sec:Table-of-parameters --></a>.
<!--l. 2326--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">5.4.2</span>  <a 
 id="x1-730005.4.2"></a>Integrals and averages</h4>
<!--l. 2328--><p class="noindent" >There are functions available in xSPDE for spatial grid averages and integrals, to handle the
spatial grid. These are <span 
class="ec-lmbxi-10x-x-109">Ave </span>and <span 
class="ec-lmbxi-10x-x-109">Int, </span>which are used to calculate observables for
plotting. They operate in parallel over the lattice dimensions, by taking a vector or
scalar quantity, for example a single field component, and returning an average or a
space integral. In each case the first argument is the field, the second argument is
a vector defining the type of operation, and the last argument is the parameter
structure. If there are two arguments, the operation vector is replaced by its default
value.
<!--l. 2339--><p class="indent" >  Integrals over the spatial grid allow calculation of global quantities. To take an
integral over the spatial grid, use the xSPDE function <span 
class="ec-lmri-10x-x-109">Int </span>with arguments <span 
class="ec-lmri-10x-x-109">(o, [dx, ]</span>
<span 
class="ec-lmri-10x-x-109">p)</span>.
                                                                                
                                                                                
<!--l. 2343--><p class="indent" >  This function takes a scalar or vector quantity <span 
class="ec-lmri-10x-x-109">o</span>, and returns a trapezoidal space integral
over selected dimensions with vector measure <span 
class="ec-lmri-10x-x-109">dx</span>. If \(dx(j)&gt;0\) an integral is taken over dimension <span 
class="ec-lmri-10x-x-109">j</span>.
Dimensions are labelled from <span 
class="ec-lmri-10x-x-109">j = 1,2,3 ... </span>as in all xSPDE standards. Time integrals are
ignored at present. Integrals are returned at all lattice locations. To integrate over an
entire lattice, set <span 
class="ec-lmri-10x-x-109">dx = p.dx</span>, otherwise set <span 
class="ec-lmri-10x-x-109">dx(j) = p.dx(j) </span>for selected dimensions
<span 
class="ec-lmri-10x-x-109">j</span>.
<!--l. 2352--><p class="indent" >  If momentum-space integrals are needed, first use the <span 
class="ec-lmri-10x-x-109">transforms </span>switch to make sure
that the field is Fourier transformed before being averaged, and input <span 
class="ec-lmri-10x-x-109">dk </span>instead of
<span 
class="ec-lmri-10x-x-109">dx</span>.
<!--l. 2356--><p class="indent" >  Spatial grid averages can be used to obtain stochastic results with reduced sampling errors if
the overall grid is homogeneous. An average is carried out using the builtin xSPDE function
<span 
class="ec-lmri-10x-x-109">Ave() </span>with arguments <span 
class="ec-lmri-10x-x-109">(o, [av, ] p)</span>.
<!--l. 2361--><p class="indent" >  This takes a vector or scalar field or observable, defined on the lattice, and returns an
average over the spatial lattice. The input is a field <span 
class="ec-lmri-10x-x-109">a </span>or observable <span 
class="ec-lmri-10x-x-109">o</span>, and an optional
averaging switch <span 
class="ec-lmri-10x-x-109">av</span>. If \(av(j)&gt;0\), an average is taken over dimension <span 
class="ec-lmri-10x-x-109">j</span>. Space dimensions are labelled
from <span 
class="ec-lmri-10x-x-109">j = 2,3... </span>as elsewhere. If the <span 
class="ec-lmri-10x-x-109">av </span>vector is omitted, the average is taken over all space
directions.
<!--l. 2369--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">5.4.3</span>  <a 
 id="x1-740005.4.3"></a>One space-dimensional example</h4>
<!--l. 2371--><p class="noindent" >A famous partial differential equation is an exactly soluble equation for a soliton, the nonlinear
Schrödinger equation (NLSE): \begin {equation}  \frac {da}{dt}=\frac {i}{2}\left [\nabla ^{2}a-a\right ]+ia\left |a\right |^{2}.  \end {equation}
<!--l. 2377--><p class="indent" >  Together with the initial condition that \(a(0,x)=sech(x)\), this has a soliton, an exact solution that doesn’t
change in time: <div class="eqnarray">\begin {eqnarray}  a(t,x) &amp; = &amp; sech(x).  \end {eqnarray}
</div>
<!--l. 2382--><p class="indent" >  The spatial integral is simply: <div class="eqnarray">\begin {eqnarray}  \int sech(x)dx &amp; = &amp; \pi .  \end {eqnarray}
</div>
<!--l. 2387--><p class="indent" >  An xSPDE code that solves this is given below, together with code that compares the
numerical solution with the exact solutions for the soliton and the integral:
<div class="center" 
>
<!--l. 2390--><p class="noindent" >
                                                                                
                                                                                
<div class="doublebox"><div class="minipage"><span 
class="ec-lmtt-10x-x-109">p.name = ’NLS soliton’;</span>
<!--l. 2394--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.dimensions = 2;</span>
<!--l. 2396--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.initial = @(v,p) sech(p.x);</span>
<!--l. 2398--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.deriv = @(a,</span><span 
class="ec-lmtt-10x-x-109">~,p) 1i*a.*(conj(a).*a);</span>
<!--l. 2400--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.linear = @(p) 0.5*1i*(p.Dx.</span><span 
class="ec-lmtt-10x-x-109">^2-1.0);</span>
<!--l. 2402--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.olabels = </span><span 
class="ec-lmtt-10x-x-109">{’a(x)’,’</span><span 
class="ec-lmtt-10x-x-109">\int a(x) dx’</span><span 
class="ec-lmtt-10x-x-109">};</span>
<!--l. 2404--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.observe</span><span 
class="ec-lmtt-10x-x-109">{2</span><span 
class="ec-lmtt-10x-x-109">} = @(a,p) Int(a, p);</span>
<!--l. 2406--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.compare</span><span 
class="ec-lmtt-10x-x-109">{1</span><span 
class="ec-lmtt-10x-x-109">} = @(p) sech(p.x);</span>
<!--l. 2408--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.compare</span><span 
class="ec-lmtt-10x-x-109">{2</span><span 
class="ec-lmtt-10x-x-109">} = @(p) pi;</span>
<!--l. 2410--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">e = xspde(p);</span>                                              </div></div>
</div>
<!--l. 2414--><p class="indent" >  Due to finite boundaries and discrete spatial lattice, the agreement is not perfect. The errors
can be reduced by increasing the range of the integration domain and improving the resolution
with more points.
<!--l. 2418--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">5.4.4</span>  <a 
 id="x1-750005.4.4"></a>Two space-dimensional example</h4>
<!--l. 2420--><p class="noindent" >As another example, consider the two-dimensional nonlinear stochastic equation, with periodic
boundary conditions:
<div class="eqnarray">\begin {eqnarray}  \frac {\partial a}{\partial t} &amp; = &amp; \nabla ^{2}a\left (\mathbf {x},t\right )+a\left (\mathbf {x},t\right )-a\left (\mathbf {x},t\right )^{3}+\eta \left (\mathbf {x},t\right ).\label {eq:Nonlinear-SPDE-example}  \end {eqnarray}
</div>
<!--l. 2427--><p class="indent" >  Using the interaction picture allows for the absorption of both the Laplacian and the
first-order term by the <span 
class="ec-lmri-10x-x-109">p.linear </span>parameter, which results in
<div class="center" 
>
<!--l. 2430--><p class="noindent" >
<div class="doublebox"><div class="minipage"><span 
class="ec-lmtt-10x-x-109">...</span>
<!--l. 2435--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.linear = @(p) (p.Dx.</span><span 
class="ec-lmtt-10x-x-109">^2+p.Dy.</span><span 
class="ec-lmtt-10x-x-109">^2) + 1;</span>
<!--l. 2438--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.deriv = @(a,w,</span><span 
class="ec-lmtt-10x-x-109">~) -a.</span><span 
class="ec-lmtt-10x-x-109">^3 + w;</span>
<!--l. 2440--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">xspde(p);</span>                                                  </div></div>
</div>
<!--l. 2444--><p class="indent" >  With this input, Matlab produces two output graphs:
<!--l. 2446--><p class="indent" >  <figure class="figure"> 

                                                                                
                                                                                
<a 
 id="x1-75001r3"></a>
                                                                                
                                                                                
<!--l. 2447--><p class="noindent" ><img 
src="xFIGURES/TwoD-example.svg" alt="pict"  
 style="width:20.91278em;" > <img 
src="xFIGURES/TwoD-example1.svg" alt="pict"  
 style="width:20.91278em;" >
<figcaption class="caption" ><span class="id">Figure 5.3: </span><span  
class="content">Two space-dimensional example graphs</span></figcaption><!--tex4ht:label?: x1-75001r3 -->
                                                                                
                                                                                
<!--l. 2448--><p class="indent" >  </figure>
  
<h3 class="sectionHead"><span class="titlemark">5.5</span>  <a 
 id="x1-760005.5"></a>Finite differences </h3>
<!--l. 2453--><p class="noindent" >Instead of using the interaction picture, xSPDE also has finite difference methods for
direct differentiation. These derivatives are obtained through function calls \(D1\)and
\(D2\) respectively for first and second derivatives, which use a fixed grid spacing. As
elsewhere, they can be replaced by user-written functions if preferred. Generally
they require smaller steps in time than spectral methods, when used to define the
derivative.
<!--l. 2461--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">5.5.1</span>  <a 
 id="x1-770005.5.1"></a>Finite difference first derivatives</h4>
<!--l. 2463--><p class="noindent" >The code to take a first order spatial derivative with finite difference methods is carried out
using the xSPDE function <span 
class="ec-lmri-10x-x-109">D1() </span>with arguments <span 
class="ec-lmri-10x-x-109">(o, [dir, ] p)</span>.
<!--l. 2467--><p class="indent" >  This takes a scalar or vector <span 
class="ec-lmri-10x-x-109">o </span>and returns a first derivative in an axis direction <span 
class="ec-lmri-10x-x-109">dir</span>. Set <span 
class="ec-lmri-10x-x-109">dir</span>
<span 
class="ec-lmri-10x-x-109">= 2 </span>for an x-derivative, <span 
class="ec-lmri-10x-x-109">dir = 3 </span>for a y-derivative, and so on. Time derivatives are ignored at
present. Derivatives are returned at all lattice locations.
<!--l. 2472--><p class="indent" >  If the direction is omitted, an <span 
class="ec-lmri-10x-x-109">x</span>-derivative is returned. These derivatives can be used both in
calculating propagation and in calculating observables. The boundary condition is set by the
<span 
class="ec-lmri-10x-x-109">boundaries </span>input. It can be made periodic, which is the default, or Neumann with zero
derivative, or Dirichlet with zero field.
<!--l. 2478--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">5.5.2</span>  <a 
 id="x1-780005.5.2"></a>Finite difference second derivatives</h4>
<!--l. 2480--><p class="noindent" >The code to take a second order spatial derivative with finite difference methods is carried out
using the xSPDE <span 
class="ec-lmri-10x-x-109">D2 </span>function with arguments <span 
class="ec-lmri-10x-x-109">(o, [dir, ] p)</span>.
<!--l. 2484--><p class="indent" >  This takes a scalar or vector <span 
class="ec-lmri-10x-x-109">o </span>and returns the second derivative in axis direction <span 
class="ec-lmri-10x-x-109">dir</span>. Set <span 
class="ec-lmri-10x-x-109">dir</span>
<span 
class="ec-lmri-10x-x-109">= 2 </span>for an x-derivative, <span 
class="ec-lmri-10x-x-109">dir = 3 </span>for a y-derivative and so on. All other properties are exactly
the same as <span 
class="ec-lmri-10x-x-109">D1</span>.
<!--l. 2489--><p class="indent" >  Without using the interaction picture, the stochastic equation of Eq
\eqref{eq:Nonlinear-SPDE-example} is specified in xSPDE using finite differences
as
<div class="center" 
>
<!--l. 2492--><p class="noindent" >
                                                                                
                                                                                
<div class="doublebox"><div class="minipage"><span 
class="ec-lmtt-10x-x-109">p.dimensions = 3;</span>
<!--l. 2496--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.steps = 50;</span>
<!--l. 2499--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.deriv = @(a,w,p) D2(a,2,p)+D2(a,3,p)+a - a.</span><span 
class="ec-lmtt-10x-x-109">^3 +</span>
<span 
class="ec-lmtt-10x-x-109">w/10;</span>
<!--l. 2501--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">xspde(p);</span>                                                  </div></div>
</div>
<!--l. 2505--><p class="indent" >  This gives the same result as with the linear propagator, although requiring smaller
step-sizes for numerical stability, with an output graph shown in Fig (<a 
href="#x1-78001r4">5.4<!--tex4ht:ref: fig:Two-space-dimensional-example-direct-diff --></a>). Note that the
parameters and noises are slightly different!
<!--l. 2510--><p class="indent" >  <figure class="figure"> 

                                                                                
                                                                                
<a 
 id="x1-78001r4"></a>
                                                                                
                                                                                
<!--l. 2511--><p class="noindent" ><img 
src="xFIGURES/TwoD-example-direct.svg" alt="pict"  
 style="width:20.91278em;" > <img 
src="xFIGURES/TwoD-example-direct1.svg" alt="pict"  
 style="width:20.91278em;" >
<figcaption class="caption" ><span class="id">Figure 5.4: </span><span  
class="content">Two space-dimensional example graphs, direct differentiation.</span></figcaption><!--tex4ht:label?: x1-78001r4 -->
                                                                                
                                                                                
<!--l. 2512--><p class="indent" >  </figure>
  
<h3 class="sectionHead"><span class="titlemark">5.6</span>  <a 
 id="x1-790005.6"></a>Boundary conditions</h3>
<!--l. 2517--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">5.6.1</span>  <a 
 id="x1-800005.6.1"></a>Transverse boundaries</h4>
<!--l. 2519--><p class="noindent" >Transverse boundary conditions must be given for all partial differential equations. Common
transverse <span 
class="ec-lmri-10x-x-109">boundary types </span>are of three types: Neumann (specified derivative), periodic, or
Dirichlet (specified field). These are obtained using \(boundaries\{d\}=-1,0,1\), which is specified for each space
dimension \(d&gt;1\), field index and boundary.
<!--l. 2525--><p class="indent" >  If <span 
class="ec-lmri-10x-x-109">boundaries </span>are omitted for any dimension the default is \(0\), which gives periodic boundaries
in that dimension for all field indices, and permits the use of Fourier transforms and an
interaction picture as described above.
<!--l. 2530--><p class="indent" >  The value of \(boundaries\{d\}\) is a matrix whose column index \((i)\) is the field index, and whose row index (j) is
given by \(j=1,2\) for the lower and upper boundary type respectively.
<!--l. 2534--><p class="indent" >  Spatial derivatives or other functions linking different spatial points can be specified either
in the functionals \(\boldsymbol {A}\left [\mathbf {a},\mathbf {r}\right ]\), \(\underline {\mathbf {B}}\left [\mathbf {a},\mathbf {r}\right ]\) or else in the \(linear\) function, provided the derivative terms are linear
functions of the fields. Use of the \(linear\) function allows an interaction picture algorithm, with
increased efficiency. The \(linear\) function is currently only available with periodic boundary
conditions.
<!--l. 2542--><p class="indent" >  The default boundary conditions are periodic. The implicit setting of this is that
periodicity is enforced such that \(a\left (o_{i}-dx_{i}/2\right )=a\left (o_{i}+r_{i}+dx_{i}/2\right )\) , which is the usual discrete Fourier transform
requirement.
<!--l. 2546--><p class="indent" >  Otherwise, the differential equation boundaries are specified at \(a\left (o_{i}\right )\), \(a\left (o_{i}+r_{i}\right )\), using the cell-array input \(boundaries\{d\}(i,j)\),
which is defined per space dimension (\(d=2,3..\)), field index (\(i=1,2..\)) and boundary \(j=(1,2)\). Here \(d&gt;1\) is the transverse
dimension, not including time, which only has an initial condition.
<!--l. 2552--><p class="indent" >  In summary the available boundary types are:
<dl class="description"><dt class="description">     
<!--l. 2554--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Neumann:</span> 
</dt><dd 
class="description">
<!--l. 2554--><p class="noindent" >For specified <span 
class="ec-lmri-10x-x-109">derivative </span>boundaries, \(boundaries\{d\}(i,j)=-1\)
</dd>     
<dt class="description">
<!--l. 2555--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Periodic:</span> 
</dt><dd 
class="description">
<!--l. 2555--><p class="noindent" >For <span 
class="ec-lmri-10x-x-109">periodic </span>boundaries, \(boundaries\{d\}(i,j)=0\)
</dd>     
<dt class="description">
                                                                                
                                                                                
     
<!--l. 2556--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Dirichlet:</span> 
</dt><dd 
class="description">
<!--l. 2556--><p class="noindent" >For specified <span 
class="ec-lmri-10x-x-109">field </span>boundaries, \(boundaries\{d\}(i,j)=1\)</dd></dl>
<!--l. 2558--><p class="noindent" >These are specified in a cell array: \(boundaries\{d\}(i,1)\) sets the lower boundary type in dimension <span 
class="ec-lmri-10x-x-109">d</span>, for the <span 
class="ec-lmri-10x-x-109">i</span>
<span 
class="ec-lmri-10x-x-109">-th </span>field component while \(boundaries\{d\}(i,2)\) gives the upper boundary type. Each space dimension,
variable and boundary is set independently. In xSPDE, the equations are always initial
value problems in time, so the time dimension boundary specification for \(d=1\) is not
included.
<!--l. 2566--><p class="indent" >  <a 
 id="paragraph*.5"></a>
<!--l. 2566--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-810005.6.1"></a>Example: boundary types in a 2-dimensional PDE</span>
Suppose there are two fields, and we wish to set mixed boundaries in space, with Dirichlet in
the past and Neumann in the future for the first field \(a(1,:)\), with the opposite combination in the
second field component, \(a(2,:)\):
<div class="center" 
>
<!--l. 2572--><p class="noindent" >
<div class="doublebox"><div class="minipage"><span 
class="ec-lmtt-10x-x-109">p.boundaries</span><span 
class="ec-lmtt-10x-x-109">{2</span><span 
class="ec-lmtt-10x-x-109">} = [1,-1;-1,1];</span>                           </div></div>
</div>
<!--l. 2578--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">5.6.2</span>  <a 
 id="x1-820005.6.2"></a>Transverse boundary values</h4>
<!--l. 2580--><p class="noindent" >For non-vanishing, specified boundary conditions, the boundary function \(boundfun(a,d,p)\) is called. This
returns the boundary values used for the fields or derivatives in a particular dimension \(d&gt;1\) as an
array of dimension \(b(\mathbf {j},e))\), where \(\mathbf {j}=i,\mathbf {k}\).
<!--l. 2585--><p class="indent" >  Here \(i=j_{1}\) is the field index, and \(\mathbf {k}\) is the space index, where \(j_{d}\) is the index of the dimension whose
boundary values are specified. For this dimension, only two values are needed: \(j_{d}=1,2\) for the lower
and upper boundary values, which could either be field values or their derivatives. An
ensemble index \(e\) is also needed if the boundary values are stochastic.
<!--l. 2592--><p class="indent" >  Boundary values can be a function of both the fields (\(a\)) and internal variables like the
current time (\(t\)). These may have stochastic initial values at \(t=0\) which are calculated only once. In
such cases the boundary values must first be initialized, so the routine \(boundfun(a,d,p)\) is first internally
initialized with time \(t&lt;origin(1)\), and with random Gaussian values in the input field \(a\). These are
delta-correlated in space, i.e., with the same definition as “inrandoms”. The xSDPE program
stores the returned values \(b\) for the boundaries in an internal cell array, \(boundval\{d\}\), for later use if
required.
<!--l. 2602--><p class="indent" >  The default boundary value is zero, set by the default boundary function \(xboundfun(a,d,p)\).
<!--l. 2607--><p class="indent" >  <span 
class="ec-lmbx-10x-x-109">NOTE: Current xSPDE code requires finite-difference methods to be used with</span>
\(boundfun\)<span 
class="ec-lmbx-10x-x-109">. Spectral methods use the default boundary conditions.</span>
                                                                                
                                                                                
<!--l. 2609--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">5.6.3</span>  <a 
 id="x1-830005.6.3"></a>Example: boundaries in a 2-dimensional PDE</h4>
<!--l. 2611--><p class="noindent" >Suppose there are two fields, and we wish to set boundary values.
<!--l. 2613--><p class="indent" >  We take boundary values as Dirichlet for \(x=0\) and Neumann for \(x=1\) in field variable 1, and
Neumann for \(x=0\) and Dirichlet for \(x=1\) in field variable 2, that are different from the default values of
\(a=0\), \(\partial _{x}a=0\), so that: \begin {align}  a_{1}\left (x=0\right ) &amp; =1,\nonumber \\ \partial _{x}a_{1}\left (x=1\right ) &amp; =a_{1}\left (x=1\right ).\nonumber \\ \partial _{x}a_{2}\left (x=0\right ) &amp; =-a_{2}\left (x=0\right )\nonumber \\ a_{2}\left (x=1\right ) &amp; =-1.  \end {align}
<!--l. 2624--><p class="indent" >  These are set in the following code:
<div class="center" 
>
<!--l. 2625--><p class="noindent" >
<div class="doublebox"><div class="minipage"><span 
class="ec-lmtt-10x-x-109">p.boundfun = @mybfun</span>
<!--l. 2629--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.boundaries</span><span 
class="ec-lmtt-10x-x-109">{2</span><span 
class="ec-lmtt-10x-x-109">} = [1,-1;-1,1];</span>
<!--l. 2631--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">...</span>
<!--l. 2633--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">function b = mybfun(a,d,p)</span>
<!--l. 2635--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">% b = mybfun(a,d,p) calculates boundary values</span>
<!--l. 2637--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">b(1,2,:) = a(1,end,:);</span>
<!--l. 2639--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">b(2,1,:) = -a(2,end,:);</span>
<!--l. 2641--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">b(1,1,:) = 1;</span>
<!--l. 2643--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">b(2,2,:) = -1;</span>
<!--l. 2645--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">end</span>                                                        </div></div>
</div>
<!--l. 2649--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">5.6.4</span>  <a 
 id="x1-840005.6.4"></a>Transverse plots</h4>
<!--l. 2651--><p class="noindent" >A number of plots at equally spaced points in time can be generated through \(p.transverse\) (see section <a 
href="#x1-22200010">10<!--tex4ht:ref: sec:xGRAPH-reference --></a>).
For example, adding the line below creates 3 time-sliced plots at \(t=0,5,10\):
<div class="center" 
>
<!--l. 2655--><p class="noindent" >
<div class="doublebox"><div class="minipage"><span 
class="ec-lmtt-10x-x-109">p.transverse</span><span 
class="ec-lmtt-10x-x-109">{1</span><span 
class="ec-lmtt-10x-x-109">} = 3;</span>                                      </div></div>
</div>
                                                                                
                                                                                
<!--l. 2661--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">5.7</span>  <a 
 id="x1-850005.7"></a>Output transforms</h3>
<!--l. 2663--><p class="noindent" >For graphical output, Fourier transforms involve a sum over the lattice points using a discrete
Fourier transform at the lattice points \(x_{i}\), so that:
<!--l. 2669--><p class="indent" >  \begin {equation}  \tilde {a}(\omega _{i},\mathbf {k}_{i})=\frac {dtd\mathbf {x}}{\left [2\pi \right ]^{d/2}}\sum _{j_{1}\ldots j_{d}}\exp \left [i\left (\omega _{i_{1}}t_{j_{1}}-\mathbf {k}_{\mathbf {i}}\cdot \mathbf {x}_{\mathbf {j}}\right )\right ]a(t_{j_{1}},\mathbf {x}_{\mathbf {j}})\,  \end {equation}
The momenta \(k_{i}\) have an interval of \begin {equation}  dk_{i}=\frac {2\pi }{n_{i}dx_{i}}  \end {equation}
with \(k_{i}\) values given for even n by: \begin {equation}  k_{i}=\left (1-\frac {n_{i}}{2}\right )dk_{i},\ldots \frac {n_{i}}{2}dk_{i}  \end {equation}
and for odd n by: \begin {equation}  k_{i}=\frac {1-n_{i}}{2}dk_{i},\ldots \frac {n_{i}-1}{2}dk_{i}  \end {equation}
<!--l. 2683--><p class="indent" >  Once Fourier transformed, the \(observe\) function can be used to take any further functions or
combinations of Fourier transformed fields prior to averaging. Important points to keep in
mind are as follows:
<ul class="itemize1">     
<li class="itemize">
<!--l. 2687--><p class="noindent" >Fourier transforms are specified for the k-th <span 
class="ec-lmri-10x-x-109">observe </span>function independently of all
other functions, by specifying \(transforms\{k\}=\left [\ell _{1,}\ldots \ell _{d,}\right ]\).
</li>     
<li class="itemize">
<!--l. 2689--><p class="noindent" >Here \(\ell _{j}=0,1\) is a logical switch, set to to \(\ell _{j}=1\) if the \(j-th\) dimension requires a Fourier transform,
and \(\ell _{j}=0\) if there is no Fourier transform.
</li>     
<li class="itemize">
<!--l. 2692--><p class="noindent" >The internal fields \(p.k\{1\},\ldots p.k\{d\}\) are available for use in making functions of momentum for use
with observations.
</li>     
<li class="itemize">
<!--l. 2694--><p class="noindent" >In propagation calculations, the momentum lattice values start with \(k=0,\ldots \), following
standard Matlab and FFT conventions.
</li>     
<li class="itemize">
<!--l. 2696--><p class="noindent" >For storing and graphing, momentum lattice values are reordered to start with \(k=-k_{max},\ldots \),
following standard graphics and mathematical conventions.</li></ul>
<!--l. 2701--><p class="noindent" >
                                                                                
                                                                                
  
<h3 class="sectionHead"><span class="titlemark">5.8</span>  <a 
 id="x1-860005.8"></a>Initial random fields</h3>
<!--l. 2703--><p class="noindent" >Fourier transforms are available for use both on initial random values and on noise fields
during time-evolution. This is controlled by the second element of \(randoms\) and \(noises\), respectively.
<!--l. 2707--><p class="indent" >  When \(randoms(1)&gt;0\), an initial random field \(\mathbf {v}^{x}\) is generated with delta-correlations in \(x\)-space. When \(randoms(2)&gt;0\), an
initial random field \(\tilde {\mathbf {v}}^{k}\) is generated with delta-correlations in \(k\)-space. This can be filtered with a
user-specified filter function to give \(\tilde {\mathbf {v}}^{kf}\), then inverse Fourier transformed to give \(v^{k}\). Both random
fields are passed to the \(initial\) function as an extended vector \(\left [v^{x},v^{k}\right ]\), for field <span 
class="ec-lmri-10x-x-109">initialization </span>in
space.
<!--l. 2716--><p class="indent" >  There is a user specified filter function available, to modify random fields \(\tilde {v}^{k}\), that are
delta-correlated in momentum space using a filter function, ’<span 
class="ec-lmri-10x-x-109">rfilter</span>’ so that \(v_{i}^{kf}\left (\mathbf {k}\right )=f_{i}^{(r)}\left (\mathbf {v}^{k}\left (\mathbf {k}\right )\right )\), before being used.
The corresponding correlations are: <div class="eqnarray">\begin {eqnarray}  \left \langle v_{i}^{x}\left (\mathbf {x}\right )v_{j}^{x}\left (\mathbf {x}'\right )\right \rangle &amp; = &amp; \delta \left (\mathbf {x}-\mathbf {x}'\right )\delta _{ij}\sim \frac {1}{\Delta V}\delta _{\mathbf {x},\mathbf {x}'}\delta _{ij}\nonumber \\ \left \langle \tilde {v}_{i}^{k}\left (\mathbf {k}\right )\tilde {v}_{j}^{k}\left (\mathbf {k}'\right )\right \rangle &amp; = &amp; \delta \left (\mathbf {k}-\mathbf {k}'\right )\delta _{ij}\sim \frac {1}{\Delta K}\delta _{\mathbf {k},\mathbf {k}'}\delta _{ij}\nonumber \\ \left \langle \tilde {v}_{i}^{kf}\left (\mathbf {k}\right )\tilde {v}_{j}^{kf}\left (\mathbf {k}'\right )\right \rangle &amp; = &amp; \left \langle f_{i}^{(r)}\left (\tilde {\mathbf {v}}^{k}\left (\mathbf {k}\right )\right )f_{j}^{(r)}\left (\tilde {\mathbf {v}}^{k}\left (\mathbf {k}'\right )\right )\right \rangle .  \end {eqnarray}
</div>
<!--l. 2726--><p class="indent" >  Note that on a lattice, we replace the Dirac continuous delta-function by a discrete
Kronecker delta function scaled by an inverse volume element either in space (\(\Delta V\)) or momentum
(\(\Delta K\)) . The xSPDE Fourier transforms are given by a symmetric Fourier transform, so
that if we inverse Fourier-transform the \(k-\)space <span 
class="ec-lmri-10x-x-109">inrandoms</span>, without filtering, then: \begin {equation}  v^{k}(\mathbf {x})=\frac {1}{\left [2\pi \right ]^{(d-1)/2}}\int e^{i\mathbf {k}\cdot \mathbf {x}}\tilde {v}^{k}(\mathbf {k})d\mathbf {k}\,  \end {equation}
<!--l. 2736--><p class="indent" >  These have random initial values that are real and delta-correlated in space, so that:
\begin {equation}  \left \langle v^{x}\left (\mathbf {x}\right )v^{x}\left (\mathbf {x}'\right )\right \rangle =\delta \left (\mathbf {x}-\mathbf {x}'\right ).  \end {equation}
The corresponding noises in position space are correlated according to:
<!--l. 2748--><p class="indent" >  \begin {align}  \left \langle v^{k}\left (\mathbf {x}\right )\left (v^{k}\left (\mathbf {x}'\right )\right )^{*}\right \rangle &amp; =\frac {1}{\left [2\pi \right ]^{(d-1)}}\int e^{i(\mathbf {k}\cdot \mathbf {x}-\mathbf {k}'\cdot \mathbf {x}')}\left \langle \tilde {v}^{k}\left (\mathbf {k}\right )\tilde {v}^{k}\left (\mathbf {k}'\right )\right \rangle d\mathbf {k}d\mathbf {k}'\nonumber \\ &amp; =\frac {1}{\left [2\pi \right ]^{(d-1)}}\int e^{i(\mathbf {x}-\mathbf {x}')\cdot \mathbf {k}}d\mathbf {k}\nonumber \\ &amp; =\delta \left (\mathbf {x}-\mathbf {x}'\right ).  \end {align}
<!--l. 2749--><p class="indent" >  Similarly, if we don’t conjugate the k-noise, then: \begin {equation}  \left \langle v^{k}\left (\mathbf {x}\right )v^{k}\left (\mathbf {x}'\right )\right \rangle =\delta \left (\mathbf {x}+\mathbf {x}'\right ).  \end {equation}
<!--l. 2754--><p class="indent" >  However, if we define \(\tilde {v}^{c}\left (\mathbf {k}\right )=\left [\tilde {v}_{1}^{k}\left (\mathbf {k}\right )+i\tilde {v}_{2}^{k}\left (\mathbf {k}\right )\right ]/\sqrt {2}\) , then we obtain complex noise that is only delta correlated when
conjugated. \begin {align}  \left \langle v^{c}\left (\mathbf {x}\right )\left (v^{c}\left (\mathbf {x}'\right )\right )^{*}\right \rangle &amp; =\delta \left (\mathbf {x}-\mathbf {x}'\right )\nonumber \\ \left \langle v^{c}\left (\mathbf {x}\right )v^{c}\left (\mathbf {x}'\right )\right \rangle &amp; =0.  \end {align}
<!--l. 2761--><p class="indent" >  This is obtainable with the x-space noise as well, but the utility of the k-space noise is that
it can be filtered to have nonlocal correlations in space if required.
<!--l. 2765--><p class="indent" >  During propagation in time, \(\mathbf {w}=\left [\mathbf {w}^{x},\mathbf {w}^{k}\right ]\) are real noise fields that are delta-correlated in space-time.
They are calculated in an analogies way, except with an additional factor of \(1/\sqrt {dt}\) because they are
delta correlated in time as well.There is a user specified scaling function available, to take
random noises \(w^{k}\) in momentum space that are then scaled using a filter function, ’<span 
class="ec-lmri-10x-x-109">nfilter</span>’ so that
\(w_{i}^{kf}\left (\mathbf {k}\right )=f_{i}^{(n)}\left (\mathbf {w}^{k}\left (\mathbf {k}\right )\right )\), before being used:
<div class="eqnarray">\begin {eqnarray}  \left \langle w_{i}^{x}\left (t,\mathbf {x}\right )w_{j}^{x}\left (t,\mathbf {x}'\right )\right \rangle &amp; = &amp; \delta \left (\mathbf {x}-\mathbf {x}'\right )\delta \left (t-t'\right )\delta _{ij}\nonumber \\ \left \langle \tilde {w}_{i}^{k}\left (t,\mathbf {k}\right )\tilde {w}_{j}^{k}\left (t,\mathbf {k}'\right )\right \rangle &amp; = &amp; \delta \left (\mathbf {k}-\mathbf {k}'\right )\delta \left (t-t'\right )\delta _{ij}\nonumber \\ \left \langle \tilde {w}_{i}^{kf}\left (t,\mathbf {k}\right )\tilde {w}_{j}^{kf}\left (t',\mathbf {k}'\right )\right \rangle &amp; = &amp; \left \langle f_{i}^{(n)}\left (\tilde {\mathbf {w}}^{k}\left (t,\mathbf {k}\right )\right )f_{j}^{(n)}\left (\tilde {\mathbf {w}}^{k}\left (t',\mathbf {k}'\right )\right )\right \rangle .  \end {eqnarray}
</div>
<!--l. 2781--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">5.9</span>  <a 
 id="x1-870005.9"></a>PDE and SPDE examples</h3>
                                                                                
                                                                                
<!--l. 2783--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">5.9.1</span>  <a 
 id="x1-880005.9.1"></a>Stochastic Ginzburg-Landau</h4>
<!--l. 2785--><p class="noindent" >Including two space dimensions, or space-time dimensions of \(d=3\), an example of a SPDE is the
stochastic Ginzburg-Landau equation. This describes symmetry breaking. The system
develops a spontaneous phase which varies spatially as well. The model is used to
describe lasers, magnetism, superconductivity, superfluidity and particle physics:
\begin {equation}  \dot {a}=\left (1-\left |a\right |^{2}\right )a+bw(t)+c\nabla ^{2}a  \end {equation}
where \begin {equation}  \left \langle w(x)w^{*}(x')\right \rangle =2\delta \left (t-t'\right )\delta \left (x-x'\right ).  \end {equation}
<!--l. 2798--><p class="indent" >  The following new ideas are introduced for this problem:
<ol  class="enumerate1" >
<li 
  class="enumerate" id="x1-88002x1">     
<!--l. 2800--><p class="noindent" >\(\mathtt {dimensions}\) <span 
class="ec-lmbx-10x-x-109">is the space-time dimension.</span>
</li>
<li 
  class="enumerate" id="x1-88004x2">     
<!--l. 2801--><p class="noindent" ><span 
class="ec-lmbx-10x-x-109">The </span>’dot’ <span 
class="ec-lmbx-10x-x-109">notation used for parallel operations over lattices</span>.
</li>
<li 
  class="enumerate" id="x1-88006x3">     
<!--l. 2803--><p class="noindent" >\(\mathtt {linear}\) <span 
class="ec-lmbx-10x-x-109">is the linear operator - a Laplacian in these cases.</span>
</li>
<li 
  class="enumerate" id="x1-88008x4">     
<!--l. 2805--><p class="noindent" >\(\mathtt {images}\) <span 
class="ec-lmbx-10x-x-109">produces movie-style images at discrete time slices.</span>
</li>
<li 
  class="enumerate" id="x1-88010x5">     
<!--l. 2807--><p class="noindent" >\(\mathtt {Dx}\) <span 
class="ec-lmbx-10x-x-109">indicates a derivative operation,</span> \(\partial /\partial x\)<span 
class="ec-lmbx-10x-x-109">.</span>
</li>
<li 
  class="enumerate" id="x1-88012x6">     
<!--l. 2808--><p class="noindent" >\(-5&lt;x&lt;5\) <span 
class="ec-lmbx-10x-x-109">is the default xSPDE coordinate range in space.</span></li></ol>
                                                                                
                                                                                
<!--l. 2811--><p class="noindent" >  
<h4 class="likesubsectionHead"><a 
 id="x1-890005.9.1"></a>Exercises</h4>
<!--l. 2812--><p class="noindent" >     
<ol  class="enumerate1" >
<li 
  class="enumerate" id="x1-89002x1">     
<!--l. 2813--><p class="noindent" ><span 
class="ec-lmbx-10x-x-109">Solve the stochastic G-L equation for</span> \(b=0.001\) <span 
class="ec-lmbx-10x-x-109">and</span> \(c=0.01i\)<span 
class="ec-lmbx-10x-x-109">.</span>
</li>
<li 
  class="enumerate" id="x1-89004x2">     
<!--l. 2814--><p class="noindent" ><span 
class="ec-lmbx-10x-x-109">Change to a real diffusion so that</span> \(c=0.1\)<span 
class="ec-lmbx-10x-x-109">.</span></li></ol>
<!--l. 2816--><p class="noindent" >In the first case, you should get the output graphed in Fig (<a 
href="#x1-89005r5">5.5<!--tex4ht:ref: fig:Symmetry-breaking --></a>) .
<div class="center" 
>
<!--l. 2818--><p class="noindent" >
<div class="doublebox"><div class="minipage"><span 
class="ec-lmtt-10x-x-109">clear;</span>
<!--l. 2822--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.name = ’Extended laser gain equation’;</span>
<!--l. 2824--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.noises = 2;</span>
<!--l. 2826--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.dimensions = 3;</span>
<!--l. 2828--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.steps = 10;</span>
<!--l. 2830--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.linear = @(p) 1i*0.01*(p.Dx.</span><span 
class="ec-lmtt-10x-x-109">^2+p.Dy.</span><span 
class="ec-lmtt-10x-x-109">^2);</span>
<!--l. 2832--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.observe = @(a,</span><span 
class="ec-lmtt-10x-x-109">~) abs(a).</span><span 
class="ec-lmtt-10x-x-109">^2;</span>
<!--l. 2834--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.images = 6;</span>
<!--l. 2836--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.olabels = ’</span><span 
class="ec-lmtt-10x-x-109">|a</span><span 
class="ec-lmtt-10x-x-109">|</span><span 
class="ec-lmtt-10x-x-109">^2’;</span>
<!--l. 2838--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.deriv = @(a,w,</span><span 
class="ec-lmtt-10x-x-109">~) (1-abs(a(1,:).</span><span 
class="ec-lmtt-10x-x-109">^2)).*a(1,:)+...</span>
<!--l. 2840--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109"> </span><span 
class="ec-lmtt-10x-x-109"> </span><span 
class="ec-lmtt-10x-x-109"> </span><span 
class="ec-lmtt-10x-x-109"> </span><span 
class="ec-lmtt-10x-x-109"> </span><span 
class="ec-lmtt-10x-x-109"> </span><span 
class="ec-lmtt-10x-x-109"> </span><span 
class="ec-lmtt-10x-x-109"> </span><span 
class="ec-lmtt-10x-x-109"> </span><span 
class="ec-lmtt-10x-x-109"> </span><span 
class="ec-lmtt-10x-x-109"> </span><span 
class="ec-lmtt-10x-x-109"> </span><span 
class="ec-lmtt-10x-x-109"> </span><span 
class="ec-lmtt-10x-x-109"> </span><span 
class="ec-lmtt-10x-x-109"> </span><span 
class="ec-lmtt-10x-x-109"> </span><span 
class="ec-lmtt-10x-x-109"> 0.001*(w(1,:)+1i*w(2,:));</span>
<!--l. 2842--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">xspde(p)</span>                                                   </div></div>
</div>
<!--l. 2846--><p class="indent" >  Here the notation \(a(1,:)\) means that the operation is repeated over all values of the subsequent
indices, which are the two spatial lattice indices in this case.
<!--l. 2850--><p class="indent" >  <figure class="figure"> 

                                                                                
                                                                                
<a 
 id="x1-89005r5"></a>
                                                                                
                                                                                
<!--l. 2851--><p class="noindent" ><img 
src="xFIGURES/GinzLand.svg" alt="pict"  
 style="width:31.36917em;" >
<figcaption class="caption" ><span class="id">Figure 5.5: </span><span  
class="content">Simulation of the stochastic equation describing symmetry breaking in two
dimensions. Spatial fluctuations are caused by the different phase-domains that interfere.
The graph obtained here is projected onto the \(y=0\) plane.</span></figcaption><!--tex4ht:label?: x1-89005r5 -->
                                                                                
                                                                                
<!--l. 2855--><p class="indent" >  </figure>
  
<h4 class="subsectionHead"><span class="titlemark">5.9.2</span>  <a 
 id="x1-900005.9.2"></a>NLS soliton</h4>
<!--l. 2860--><p class="noindent" >The famous nonlinear Schrödinger equation (NLSE) is: \begin {equation}  \frac {da}{dt}=\frac {i}{2}\left [\nabla ^{2}a-a\right ]+ia\left |a\right |^{2}.  \end {equation}
<!--l. 2865--><p class="indent" >  Together with the initial condition that \(a(0,x)=sech(x)\), this has a soliton, an exact solution that doesn’t
change in time: <div class="eqnarray">\begin {eqnarray}  a(t,x) &amp; = &amp; sech(x).  \end {eqnarray}
</div>
<!--l. 2870--><p class="indent" >  The Fourier transform at \(k=0\) is simply: <div class="eqnarray">\begin {eqnarray}  \tilde {a}(t,0) &amp; = &amp; \frac {1}{\sqrt {2\pi }}\int sech(x)dx=\sqrt {\frac {\pi }{2}}.  \end {eqnarray}
</div>
<!--l. 2876--><p class="noindent" >  
<h4 class="likesubsectionHead"><a 
 id="x1-910005.9.2"></a>Exercises</h4>
<ul class="itemize1">     
<li class="itemize">
<!--l. 2878--><p class="noindent" ><span 
class="ec-lmbx-10x-x-109">Solve the NLSE for a soliton using a function instead of a script, then</span>
<span 
class="ec-lmbx-10x-x-109">include an additive complex noise of</span> \(0.01(w_{1}+iw_{2}\)<span 
class="ec-lmbx-10x-x-109">) to the differential equation, and</span>
<span 
class="ec-lmbx-10x-x-109">plot again with an average over</span> \(1000\) <span 
class="ec-lmbx-10x-x-109">samples.</span></li></ul>
<!--l. 2883--><p class="noindent" >
                                                                                
                                                                                
  
<h4 class="subsectionHead"><span class="titlemark">5.9.3</span>  <a 
 id="x1-920005.9.3"></a>Planar noise</h4>
<!--l. 2887--><p class="noindent" >The next example is growth of thermal noise of a two-component complex field in a plane,
given by the equation \begin {equation}  \frac {d\mathbf {a}}{dt}=\frac {i}{2}\nabla ^{2}\mathbf {a}+\mathbf {w}(t,x).  \end {equation}
where \(\mathbf {\zeta }\) is a delta-correlated complex noise vector field: \begin {equation}  w_{j}(t,\mathbf {x})=\left [w_{j}^{re}(t,\mathbf {x})+i\zeta _{j}^{im}(t,\mathbf {x})\right ]/\sqrt {2},  \end {equation}
with the initial condition that the initial noise is delta-correlated in position space
\begin {equation}  a(0,\mathbf {x})=\mathbf {\zeta }^{(in)}(\mathbf {x})  \end {equation}
where: \begin {equation}  \mathbf {\zeta }^{(in)}(\mathbf {x})=\left [\mathbf {\zeta }^{re(in)}(\mathbf {x})+i\mathbf {\zeta }^{im(in)}(\mathbf {x})\right ]/\sqrt {2}  \end {equation}
<!--l. 2907--><p class="indent" >  This has an exact solution for the noise intensity in either ordinary space or momentum
space: <div class="eqnarray">\begin {eqnarray}  \left \langle \left |a_{j}\left (t,\mathbf {x}\right )\right |^{2}\right \rangle &amp; = &amp; (1+t)/dV\nonumber \\ \left \langle \left |\tilde {a}_{j}\left (t,\mathbf {k}\right )\right |^{2}\right \rangle &amp; = &amp; (1+t)/dV_{k}\nonumber \\ \left \langle \tilde {a}_{1}\left (t,\mathbf {k}\right )\tilde {a}_{2}^{*}\left (t,\mathbf {k}\right )\right \rangle &amp; = &amp; 0.  \end {eqnarray}
</div>
<!--l. 2915--><p class="indent" >  Here, the noise is delta-correlated, and \(dV\), \(dV_{k}\) are the cartesian space and momentum space
lattice cell volumes, respectively. Suppose that \(n=n_{x}n_{y}\) is the total number of spatial points, and there
are \(n_{x(y)}\) points in the x(y)-direction, so then: <div class="eqnarray">\begin {eqnarray}  dV &amp; = &amp; dxdy\\ dV_{k} &amp; = &amp; dk_{x}dk_{y}=\frac {(2\pi )^{2}}{ndV}.\nonumber  \end {eqnarray}
</div>
<!--l. 2924--><p class="indent" >  In the simulations, two planar noise fields are propagated, one using delta-correlated noise,
the other with noise transformed to momentum space to allow filtering. This allows use of
finite correlation lengths when needed, by including a frequency filter function that is used to
multiply the noise in Fourier-space. The Fourier-space noise variance is the square of the filter
function.
<!--l. 2931--><p class="indent" >  The first noise index, \(p.noises(1)\), indicates how many noise fields are generated, while \(p.noises(2)\) indicates how
many of these are spatially correlated, via Fourier transform, filter and inverse Fourier
transform. These appear to the user as additional noises, so the total is \(p.noises(1)+p.noises(2)\). The filtered noises
have a finite correlation length. They are correlated with the first \(p.noises(1)\) x-space noises they are
generated from, as this can be useful.
<!--l. 2939--><p class="noindent" >  
<h4 class="likesubsectionHead"><a 
 id="x1-930005.9.3"></a>Exercises</h4>
<ul class="itemize1">     
<li class="itemize">
<!--l. 2941--><p class="noindent" ><span 
class="ec-lmbx-10x-x-109">Solve the planar noise growth equation</span></li></ul>
<div class="center" 
>
<!--l. 2943--><p class="noindent" >
                                                                                
                                                                                
<div class="doublebox"><div class="minipage"><span 
class="ec-lmtt-10x-x-109">function [e] = Planar()</span>
<!--l. 2947--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.name = ’Planar noise growth’;</span>
<!--l. 2949--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.dimensions = 3;</span>
<!--l. 2951--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.fields = 2;</span>
<!--l. 2953--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.ranges = [1,5,5];</span>
<!--l. 2955--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.steps = 2;</span>
<!--l. 2957--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.noises = [2,2];</span>
<!--l. 2959--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.ensembles = [10,4,4];</span>
<!--l. 2961--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.initial = @Initial;</span>
<!--l. 2963--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.deriv = @Da;</span>
<!--l. 2965--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.linear = @Linear;</span>
<!--l. 2967--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.observe = @(a,p) a(1,:).*conj(a(1,:));</span>
<!--l. 2970--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.olabels = ’</span><span 
class="ec-lmtt-10x-x-109">&#x003C;</span><span 
class="ec-lmtt-10x-x-109">|a</span><span 
class="ec-lmtt-10x-x-109">_1(x)</span><span 
class="ec-lmtt-10x-x-109">|</span><span 
class="ec-lmtt-10x-x-109">^2</span><span 
class="ec-lmtt-10x-x-109">&#x003E;’;</span>
<!--l. 2972--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.compare = @(p) [1+p.t]/p.dv;</span>
<!--l. 2974--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.images = 4;</span>
<!--l. 2976--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">e = xspde(p);</span>
<!--l. 2978--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">end </span> <br 
class="newline" /> 
<!--l. 2981--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">function a0 = Initial(v,p)</span>
<!--l. 2983--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">a0(1,:) = (v(1,:)+1i*v(2,:))/sqrt(2);</span>
<!--l. 2985--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">a0(2,:) = (v(3,:)+1i*v(4,:))/sqrt(2);</span>
<!--l. 2987--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">end </span> <br 
class="newline" /> 
<!--l. 2990--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">function da = Da(a,w,p)</span>
<!--l. 2992--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">da(1,:) = (w(1,:)+1i*w(2,:))/sqrt(2);</span>
<!--l. 2994--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">da(2,:) = (w(3,:)+1i*w(4,:))/sqrt(2);</span>
<!--l. 2996--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">end </span> <br 
class="newline" /> 
<!--l. 2999--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">function L = Linear(p)</span>
<!--l. 3001--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">lap = p.Dx.</span><span 
class="ec-lmtt-10x-x-109">^2+p.Dy.</span><span 
class="ec-lmtt-10x-x-109">^2;</span>
<!--l. 3003--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">L(1,:) = 1i*0.5*lap(:);</span>
<!--l. 3005--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">L(2,:) = 1i*0.5*lap(:);</span>
<!--l. 3007--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">end</span>                                                        </div></div>
</div>     
<ul class="itemize1">
<li class="itemize">     
<!--l. 3011--><p class="noindent" ><span 
class="ec-lmbx-10x-x-109">Add a decay rate of</span> \(-a\) <span 
class="ec-lmbx-10x-x-109">to the differential equation, then plot again</span>
</li>     
<li class="itemize">
<!--l. 3013--><p class="noindent" ><span 
class="ec-lmbx-10x-x-109">Add growth and nonlinear saturation terms</span></li></ul>
                                                                                
                                                                                
<!--l. 3016--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">5.9.4</span>  <a 
 id="x1-940005.9.4"></a>Gross-Pitaevskii equation</h4>
<!--l. 3018--><p class="noindent" >The next example is a complex Gross-Pitaevskii (GP) equation in two dimensions,
\begin {equation}  \frac {da}{dt}=\frac {i}{2}\nabla ^{2}a-ia(V(r)-i\kappa (r)+\left |a\right |^{2})+\epsilon \eta \label {eq:Stochastic GPE}  \end {equation}
where \(\eta \) is a correlated complex noise vector field: \begin {equation}  \eta (t,\mathbf {x})=w_{1}(t,\mathbf {x})+iw_{2}(t,\mathbf {x}),  \end {equation}
with the initial condition that the initial random field and the noise are both filtered in
momentum space \begin {equation}  a(0,\mathbf {x})=a_{0}(\mathbf {x})+\epsilon \zeta ^{(in)}(\mathbf {x})  \end {equation}
where: \begin {equation}  \zeta ^{(in)}(\mathbf {x})=v_{1}(\mathbf {x})+iv_{2}(\mathbf {x})  \end {equation}
<!--l. 3037--><p class="indent" >  We add a Gaussian filter in momentum space for both the initial random field and noise so
that, if \(\tilde {w}\left (\mathbf {k}\right )\) is a delta-correlated noise in momentum space: \begin {align}  w\left (\mathbf {k}\right ) &amp; =\tilde {w}\left (\mathbf {k}\right )\exp \left (-\left |\mathbf {k}\right |^{2}\right )\nonumber \\ v\left (\mathbf {k}\right ) &amp; =\tilde {v}\left (\mathbf {k}\right )\exp \left (-\left |\mathbf {k}\right |^{2}\right )  \end {align}
<!--l. 3045--><p class="indent" >  This allows use of finite correlation lengths when needed, by including a frequency filter
function that is used to multiply the noise in Fourier-space. The Fourier-space noise variance is
the square of the filter function.
<!--l. 3050--><p class="indent" >  The first noise index, \(p.noises(1)\), indicates how many noise fields are generated that are
delta-correlated in \(x\), while \(p.noises(2)\) indicates how many of these are spatially correlated, via
Fourier transform, filter and inverse Fourier transform. These appear to the user
as additional noises, so the total is \(p.noises(1)+p.noises(2)\). The filtered noises have a finite correlation
length.
<!--l. 3057--><p class="noindent" >  
<h4 class="likesubsectionHead"><a 
 id="x1-950005.9.4"></a>Exercises</h4>
<ul class="itemize1">     
<li class="itemize">
<!--l. 3059--><p class="noindent" ><span 
class="ec-lmbx-10x-x-109">Solve the stochastic GP equation </span>\eqref{eq:Stochastic GPE}<span 
class="ec-lmbx-10x-x-109">, with a</span>
<span 
class="ec-lmbx-10x-x-109">noise coefficient of</span> \(b=0.1\)<span 
class="ec-lmbx-10x-x-109">,</span> \(V=0.01\left |\mathbf {x}\right |^{2},\) \(\kappa =0.001\left |\mathbf {x}\right |^{4}\)<span 
class="ec-lmbx-10x-x-109">, and a stored output data file.</span></li></ul>
<div class="center" 
>
<!--l. 3064--><p class="noindent" >
                                                                                
                                                                                
<div class="doublebox"><div class="minipage"><span 
class="ec-lmtt-10x-x-109">function [e] = GPE()</span>
<!--l. 3068--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.name = ’GPE’;</span>
<!--l. 3070--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.dimensions = 3;</span>
<!--l. 3072--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.points = [101,64,64];</span>
<!--l. 3074--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.ranges = [1,20,20];</span>
<!--l. 3076--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.noises = [0,2];</span>
<!--l. 3078--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.rfilter = @(w,p) w.*exp(-p.kx.</span><span 
class="ec-lmtt-10x-x-109">^2-p.ky.</span><span 
class="ec-lmtt-10x-x-109">^2);</span>
<!--l. 3080--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.nfilter = @(v,p) v.*exp(-p.kx.</span><span 
class="ec-lmtt-10x-x-109">^2-p.ky.</span><span 
class="ec-lmtt-10x-x-109">^2);</span>
<!--l. 3082--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">b = @(xi) .1*(xi(1,:,:)+1i*xi(2,:,:));</span>
<!--l. 3085--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.initial = @(v,p) (p.x+1i*p.y)./(1+10*(p.x.</span><span 
class="ec-lmtt-10x-x-109">^2 +</span>
<span 
class="ec-lmtt-10x-x-109">p.y.</span><span 
class="ec-lmtt-10x-x-109">^2))+b(v);</span>
<!--l. 3088--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">V = @(p) 0.01*(p.x.</span><span 
class="ec-lmtt-10x-x-109">^2 + p.y.</span><span 
class="ec-lmtt-10x-x-109">^2)-0.001*1i*(p.x.</span><span 
class="ec-lmtt-10x-x-109">^2 +</span>
<span 
class="ec-lmtt-10x-x-109">p.y.</span><span 
class="ec-lmtt-10x-x-109">^2).</span><span 
class="ec-lmtt-10x-x-109">^2;</span>
<!--l. 3090--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.deriv = @(a,w,p) -1i*a.*(V(p)+conj(a).*a)+b(w);</span>
<!--l. 3092--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.linear = @(p) 0.5*1i*(p.Dx.</span><span 
class="ec-lmtt-10x-x-109">^2+p.Dy.</span><span 
class="ec-lmtt-10x-x-109">^2);</span>
<!--l. 3094--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.observe</span><span 
class="ec-lmtt-10x-x-109">{1</span><span 
class="ec-lmtt-10x-x-109">} = @(a,p) a.*conj(a);</span>
<!--l. 3096--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.images = </span><span 
class="ec-lmtt-10x-x-109">{2</span><span 
class="ec-lmtt-10x-x-109">};</span>
<!--l. 3098--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.imagetype = </span><span 
class="ec-lmtt-10x-x-109">{2</span><span 
class="ec-lmtt-10x-x-109">};</span>
<!--l. 3100--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.olabels = </span><span 
class="ec-lmtt-10x-x-109">{’</span><span 
class="ec-lmtt-10x-x-109">|a</span><span 
class="ec-lmtt-10x-x-109">|</span><span 
class="ec-lmtt-10x-x-109">^2’</span><span 
class="ec-lmtt-10x-x-109">};</span>
<!--l. 3102--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.file = ’GPE.mat’;</span>
<!--l. 3104--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">e = xsim(p);</span>
<!--l. 3106--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">xgraph(p.file,p);</span>
<!--l. 3108--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">end</span>                                                        </div></div>
</div>
<!--l. 3112--><p class="noindent" >
                                                                                
                                                                                
  
<h4 class="subsectionHead"><span class="titlemark">5.9.5</span>  <a 
 id="x1-960005.9.5"></a>Characteristic equation</h4>
<!--l. 3116--><p class="noindent" >The next example is the characteristic equation for a traveling wave at constant velocity. It is
included to illustrate what happens at periodic boundaries, when Fourier-transform methods
are used for propagation. There are a number of methods known to prevent this effect,
including addition of absorbers - called apodization - at the boundaries. The equation is: \begin {equation}  \frac {da}{dt}+\frac {da}{dx}=0.  \end {equation}
<!--l. 3126--><p class="indent" >  Together with the initial condition that \(a(0,x)=sech(2x+5)\), this has an exact solution that propagates at a
constant velocity: <div class="eqnarray">\begin {eqnarray}  a(t,x) &amp; = &amp; sech(2(x-t)+5).  \end {eqnarray}
</div>
<!--l. 3131--><p class="indent" >  The time evolution at \(x=0\) is simply: <div class="eqnarray">\begin {eqnarray}  a(t,0) &amp; = &amp; sech(2(t-5/2)).  \end {eqnarray}
</div>
<!--l. 3137--><p class="noindent" >  
<h4 class="likesubsectionHead"><a 
 id="x1-970005.9.5"></a>Exercises</h4>
<ul class="itemize1">     
<li class="itemize">
<!--l. 3139--><p class="noindent" ><span 
class="ec-lmbx-10x-x-109">Solve  the  characteristic  equation  given  above,  noting  the  effects  of</span>
<span 
class="ec-lmbx-10x-x-109">periodic boundaries.</span></li></ul>
<div class="center" 
>
<!--l. 3142--><p class="noindent" >
<div class="doublebox"><div class="minipage"><span 
class="ec-lmtt-10x-x-109">function [e] = Characteristic()</span>
<!--l. 3146--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.name = ’Characteristic’;</span>
<!--l. 3148--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.dimensions = 2;</span>
<!--l. 3150--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.initial = @(v,p) sech(2.*(p.x+2.5));</span>
<!--l. 3152--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.deriv = @(a,z,p) 0*a;</span>
<!--l. 3154--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.linear = @(p) -p.Dx;</span>
<!--l. 3156--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.olabels = </span><span 
class="ec-lmtt-10x-x-109">{’a</span><span 
class="ec-lmtt-10x-x-109">_1(x)’</span><span 
class="ec-lmtt-10x-x-109">};</span>
<!--l. 3158--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.compare = @(p) sech(2.*(p.t-2.5));</span>
<!--l. 3160--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">e = xspde(p);</span>
<!--l. 3162--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">end</span>                                                        </div></div>
</div>     
<ul class="itemize1">
<li class="itemize">     
<!--l. 3166--><p class="noindent" ><span 
class="ec-lmbx-10x-x-109">Recalculate with the opposite velocity, and a new exact solution.</span></li></ul>
                                                                                
                                                                                
<!--l. 3169--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">5.10</span>  <a 
 id="x1-980005.10"></a>Challenge problem #2</h3>
<!--l. 3171--><p class="noindent" >A random potential <span 
class="ec-lmri-10x-x-109">prevents </span>normal wave-packet spreading in quantum-mechanics. This is
Anderson localization: a famous property of quantum mechanics in a random potential. A
typical experimental method is to confine an ultra-cold Bose-Einstein condensate
(BEC) in a trap, then release the BEC in a random external potential produced by a
laser. The expansion rate of the BEC is reduced by the Anderson localization due to
the random potential. Physically, the observable quantity is the particle density
\(n=\left |\psi \right |^{2}\).
<!--l. 3180--><p class="indent" >  This can be treated either using a Schrodinger equation with a random potential, at low
density, or using the Gross-Pitaevskii (GP) equation to include atom-atom interactions at the
mean field level. In this example of a problem where strong localization occurs, the general
equations are:
<!--l. 3188--><p class="indent" >  \begin {equation}  \frac {\partial \psi }{\partial t}=\frac {1}{i\hbar }\left [-\frac {\hbar ^{2}}{2m}\nabla ^{2}+V\left (\mathbf {r}\right )+g\left |\psi \right |^{2}\right ]\psi .  \end {equation}
<!--l. 3190--><p class="indent" >  In calculations, it is best to use a dimensionless form by rescaling coordinates and fields. A
simple way to simulate this with xSPDE is to treat \(\psi \) as a scaled field \(a(1),\) and to assume the
random potential field \(V\left (\mathbf {r}\right )\) as caused by interactions with second random field \(\left |a(2)\right |^{2}\). This has the
advantage that it is similar to the actual experiment and allows one to treat time-dependent
potentials as well, if desired.
<!--l. 3198--><p class="indent" >  With the rescaling, this simplifies to: \begin {equation}  \frac {\partial a_{1}}{\partial \tau }=i\left [\frac {\partial }{\partial \zeta ^{2}}^{2}-\left |a_{2}\right |^{2}-\left |a_{1}\right |^{2}\right ]a_{1}.  \end {equation}
<!--l. 3203--><p class="indent" >  A convenient initial condition is to use: <div class="eqnarray">\begin {eqnarray}  a_{1} &amp; = &amp; a_{0}\exp (-\zeta ^{2})\nonumber \\ \left \langle a_{2}(\zeta )a_{2}(\zeta ')\right \rangle &amp; = &amp; v\delta \left (\zeta -\zeta '\right ).  \end {eqnarray}
</div>
<!--l. 3210--><p class="noindent" >  
<h4 class="likesubsectionHead"><a 
 id="x1-990005.10"></a>Exercise</h4>
<ul class="itemize1">     
<li class="itemize">
<!--l. 3212--><p class="noindent" ><span 
class="ec-lmbx-10x-x-109">Solve Schrodinger’s equation without a random potential, to observe</span>
<span 
class="ec-lmbx-10x-x-109">expansion.</span>
</li>     
<li class="itemize">
<!--l. 3214--><p class="noindent" ><span 
class="ec-lmbx-10x-x-109">Include a random potential</span> \(v\)<span 
class="ec-lmbx-10x-x-109">, to observe localization.</span>
</li>     
<li class="itemize">
<!--l. 3215--><p class="noindent" ><span 
class="ec-lmbx-10x-x-109">Experiment with nonlinear terms and higher dimensions.</span></li></ul>
                                                                                
                                                                                
<!--l. 3217--><p class="noindent" >Note that the GP equation is a mean field approximation; this is still not a full solution of the
many-body problem! Also, the experiments are somewhat more complicated than this, and
actually observe the momentum distribution.
<!--l. 3222--><p class="indent" >
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
  
<h2 class="chapterHead"><span class="titlemark">6</span>  <a 
 id="x1-1000006"></a>xSIM and xGRAPH</h2>
<!--l. 3228--><p class="noindent" ><span 
class="ec-lmbxi-10x-x-109">This section describes how to use xSPDE to run in a batch mode, as well as</span>
<span 
class="ec-lmbxi-10x-x-109">details of data storage and methods for graphing scanned parameters.</span>
  
<h3 class="sectionHead"><span class="titlemark">6.1</span>  <a 
 id="x1-1010006.1"></a>Batch job workflow</h3>
<!--l. 3232--><p class="noindent" >An xSPDE session can either run simulations interactively, described in section <a 
href="#x1-420004">4<!--tex4ht:ref: sec:Simulating-an-SDE --></a>, or else using
a function file called a project file. In either case, the Matlab path must include the xSPDE
folder. For generating graphs automatically, the script input or project function should end
with the combined function <span 
class="ec-lmbx-10x-x-109">xspde</span>.
<!--l. 3238--><p class="indent" >  Alternatively, it can be useful to divide xSPDE into its simulation function, xSIM, and its
graphics function, xGRAPH, to allow graphs to be made at a later time from the
simulation. In this case the function \(xsim\) runs the simulation, and \(xgraph\) makes the graphs. The
two-stage option is better for running batch jobs which you can graph at a later
time.
<!--l. 3245--><p class="indent" >  To create a data file, you must enter the filename when running the simulation, using the \(p.file=filename\)
input. A typical xSPDE project function of this type is as follows:
<div class="center" 
>
<!--l. 3248--><p class="noindent" >
<div class="doublebox"><div class="minipage"><span 
class="ec-lmtt-10x-x-109">function [e,ec] = project.m</span>
<!--l. 3252--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.[label1] = [parameter1];</span>
<!--l. 3254--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.[label2] = ...;</span>
<!--l. 3256--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.file = ’[my file].mat’</span>
<!--l. 3258--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">[e,p] = xsim(p);</span>
<!--l. 3260--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">ex = xgraph(p.file);</span>
<!--l. 3262--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">end</span>                                                        </div></div>
</div>
<!--l. 3266--><p class="indent" >  After preparing a project file using the editor, click on the Run arrow above the editor
window.
<!--l. 3269--><p class="indent" >  A batch job workflow is as follows:
<ul class="itemize1">     
<li class="itemize">
<!--l. 3271--><p class="noindent" >Create the metadata \(p\), with a file name, \(p.file\).
</li>     
<li class="itemize">
<!--l. 3272--><p class="noindent" >Change the Matlab directory path to your preferred directory.
</li>     
<li class="itemize">
<!--l. 3273--><p class="noindent" >Run the simulation with <span 
class="ec-lmbx-10x-x-109">[e,p] = xsim(</span>p), or just <span 
class="ec-lmbx-10x-x-109">xsim(</span>p).
                                                                                
                                                                                
     
</li>
<li class="itemize">     
<!--l. 3274--><p class="noindent" >Run <span 
class="ec-lmbx-10x-x-109">xgraph(</span>p.<span 
class="ec-lmbx-10x-x-109">file)</span>, and the data will be graphed.
</li>     
<li class="itemize">
<!--l. 3275--><p class="noindent" >Alternatively, <span 
class="ec-lmbx-10x-x-109">xgraph(</span>p.<span 
class="ec-lmbx-10x-x-109">file,</span>p) allows you to change the inputs in the structure \(p\).
</li>     
<li class="itemize">
<!--l. 3277--><p class="noindent" >Graph outputs can be stored using the <span 
class="ec-lmri-10x-x-109">saveeps </span>and/or <span 
class="ec-lmri-10x-x-109">savefig </span>options</li></ul>
<!--l. 3280--><p class="noindent" >You can use either Matlab (.mat) or standard HDF5 (.h5) file-types for data storage. If raw data
is generated it will be stored too, but the files can be large. For graphics files the options are
Matlab (.fig) or encapsulated postscript (.eps) files.
<!--l. 3285--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">6.2</span>  <a 
 id="x1-1020006.2"></a>Graphical data</h3>
<!--l. 3287--><p class="noindent" >The following table show how xSPDE output data is stored, which helps customize and extend
the code. There are several different types of arrays used. The observed averages are generated
internally from the observe functions, <span 
class="ec-lmri-10x-x-109">p.observe</span>. These are then modified by user functions
<span 
class="ec-lmri-10x-x-109">p.function</span>, and exported as graphics data.
<!--l. 3293--><p class="indent" >  These are as follows:
<div class="center" 
>
<!--l. 3294--><p class="noindent" >
<div class="tabular"> <table id="TBL-5" class="tabular" 
 
><colgroup id="TBL-5-1g"><col 
id="TBL-5-1"></colgroup><colgroup id="TBL-5-2g"><col 
id="TBL-5-2"></colgroup><colgroup id="TBL-5-3g"><col 
id="TBL-5-3"></colgroup><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-5-1-"><td  style="white-space:nowrap; text-align:center;" id="TBL-5-1-1"  
class="td11">Label</td>
        <td  style="white-space:nowrap; text-align:center;" id="TBL-5-1-2"  
class="td11">Indices</td>
                <td  style="white-space:nowrap; text-align:center;" id="TBL-5-1-3"  
class="td11">   Description     </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-5-2-"><td  style="white-space:nowrap; text-align:center;" id="TBL-5-2-1"  
class="td11">  av   </td><td  style="white-space:nowrap; text-align:center;" id="TBL-5-2-2"  
class="td11">   \(\{n\}(\ell ,\mathbf {j})\)   </td><td  style="white-space:nowrap; text-align:center;" id="TBL-5-2-3"  
class="td11">Observed averages</td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-5-3-"><td  style="white-space:nowrap; text-align:center;" id="TBL-5-3-1"  
class="td11">  d   </td><td  style="white-space:nowrap; text-align:center;" id="TBL-5-3-2"  
class="td11">   \(\{s\}\{n\}(\ell ,\mathbf {j},c)\)   </td><td  style="white-space:nowrap; text-align:center;" id="TBL-5-3-3"  
class="td11">   Graph data    </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-5-4-"><td  style="white-space:nowrap; text-align:center;" id="TBL-5-4-1"  
class="td11">     </td></tr></table></div>
</div>
<!--l. 3307--><p class="indent" >  Here:
<ul class="itemize1">     
<li class="itemize">
<!--l. 3309--><p class="noindent" >\(s\) is the sequence index
</li>     
<li class="itemize">
<!--l. 3310--><p class="noindent" >\(n\) is the graph index
                                                                                
                                                                                
     
</li>
<li class="itemize">     
<!--l. 3311--><p class="noindent" >\(\ell \) is the graphics line index
</li>     
<li class="itemize">
<!--l. 3312--><p class="noindent" >\(j_{1}\) is the time index
</li>     
<li class="itemize">
<!--l. 3313--><p class="noindent" >\(\mathbf {j}=j_{1},j_{2},\dots j_{d}\) is the <span 
class="ec-lmri-10x-x-109">d</span>-dimensional space-time index
</li>     
<li class="itemize">
<!--l. 3315--><p class="noindent" >\(c\) is the check index</li></ul>
<!--l. 3317--><p class="noindent" >There are multiple uses for the check index, <span 
class="ec-lmri-10x-x-109">c</span>. The index values are defined as follows:
<dl class="description"><dt class="description">     
<!--l. 3320--><p class="noindent" >
\(c=1\) 
</dt><dd 
class="description">    
<!--l. 3320--><p class="noindent" >for the average of the <span 
class="ec-lmri-10x-x-109">n</span>-th output function
</dd>     
<dt class="description">
<!--l. 3321--><p class="noindent" >
\(c=2\) 
</dt><dd 
class="description">    
<!--l. 3321--><p class="noindent" >for the time-step error,
</dd>     
<dt class="description">
<!--l. 3322--><p class="noindent" >
\(c=3\) 
</dt><dd 
class="description">    
<!--l. 3322--><p class="noindent" >for the sampling error.
</dd>     
<dt class="description">
<!--l. 3323--><p class="noindent" >
\(c=4\) 
</dt><dd 
class="description">    
<!--l. 3323--><p class="noindent" >for (optional) comparisons
</dd>     
<dt class="description">
<!--l. 3324--><p class="noindent" >
\(c=5\) 
</dt><dd 
class="description">    
<!--l. 3324--><p class="noindent" >for (optional) systematic comparison errors
                                                                                
                                                                                
     
</dd>
<dt class="description">     
<!--l. 3325--><p class="noindent" >
\(c=6\) 
</dt><dd 
class="description">    
<!--l. 3325--><p class="noindent" >for (optional) statistical comparison errors</dd></dl>
<!--l. 3328--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">6.3</span>  <a 
 id="x1-1030006.3"></a>Scanned parameter plots</h3>
<!--l. 3330--><p class="noindent" >Since xSIM is a function that can be called, plots of results against simulation parameters are
possible. This requires repeated calls to xSIM with different parameter values, together with
data storage in an xGRAPH compatible form, and a call to xGRAPH. If different
random seeds are required, the seed needs to be reset in each call. The relevant
axes points plotted, labels and the values of scanned parameters also need to be
input.
<!--l. 3338--><p class="indent" >  The simulation function xSIM uses the last data array index, \(c\), to store the data values and
up to two corresponding errors. This takes up three index values. A value of \(c=4\) is used to store
comparison data, and its errors if there are any in \(c=5,6\). This can be used for exact results,
approximations, or experimental data.
<!--l. 3344--><p class="indent" >  <figure class="figure"> 

                                                                                
                                                                                
<a 
 id="x1-103001r1"></a>
                                                                                
                                                                                
<!--l. 3345--><p class="noindent" ><img 
src="xFIGURES/Scan.svg" alt="pict"  
 style="width:31.36917em;" >
<figcaption class="caption" ><span class="id">Figure 6.1: </span><span  
class="content">Scanned parameter output with a variable diffusion, for the case of a pure
Wiener process, \(\dot {a}=Bw(t)\). Exact value is the dashed line.</span></figcaption><!--tex4ht:label?: x1-103001r1 -->
                                                                                
                                                                                
<!--l. 3348--><p class="indent" >  </figure>
  
<h4 class="subsectionHead"><span class="titlemark">6.3.1</span>  <a 
 id="x1-1040006.3.1"></a>Example: Scanned diffusion</h4>
<!--l. 3353--><p class="noindent" >As an example, consider the simplest possible stochastic equation, with a scanned diffusion: \begin {equation}  \dot {a}=Bw(t)\,.  \end {equation}
<!--l. 3359--><p class="indent" >  The equation is integrated over the interval \(t=0:10\), with \(a=0\) initially, using \(10^{4}\) trajectories to give an
expected error of around \(\pm 1\%\). The variance of \(a\) at \(t=10\) is plotted as a function of \(D=B^{2}\), then compared
to an exact value. The result is in Fig (<a 
href="#x1-103001r1">6.1<!--tex4ht:ref: fig:Scanned-diffusion --></a>). The corresponding code is given as
well.
<div class="center" 
>
<!--l. 3365--><p class="noindent" >
<div class="doublebox"><div class="minipage"><span 
class="ec-lmtt-10x-x-109">function e = WienerScan()</span>
<!--l. 3369--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.name = ’Wiener process’;</span>
<!--l. 3371--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.ensembles = [1000,10];</span>
<!--l. 3373--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.points = 12;</span>
<!--l. 3375--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.deriv = @(a,z,p) z*p.B;</span>
<!--l. 3377--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.observe = @(a,p) a.</span><span 
class="ec-lmtt-10x-x-109">^2;</span>
<!--l. 3380--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.olabels = </span><span 
class="ec-lmtt-10x-x-109">{’</span><span 
class="ec-lmtt-10x-x-109">&#x003C;a</span><span 
class="ec-lmtt-10x-x-109">^2</span><span 
class="ec-lmtt-10x-x-109">&#x003E;’</span><span 
class="ec-lmtt-10x-x-109">};</span>
<!--l. 3382--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.glabels</span><span 
class="ec-lmtt-10x-x-109">{1</span><span 
class="ec-lmtt-10x-x-109">} = </span><span 
class="ec-lmtt-10x-x-109">{’D’</span><span 
class="ec-lmtt-10x-x-109">};</span>
<!--l. 3384--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">scanpoints = 25;</span>
<!--l. 3386--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">data</span><span 
class="ec-lmtt-10x-x-109">{1</span><span 
class="ec-lmtt-10x-x-109">}</span><span 
class="ec-lmtt-10x-x-109">{1</span><span 
class="ec-lmtt-10x-x-109">} = zeros(1,scanpoints,4);</span>
<!--l. 3388--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">for j = 1:scanpoints</span>
<!--l. 3390--><p class="noindent" >  <span 
class="ec-lmtt-10x-x-109">p.seed = j;</span>
<!--l. 3392--><p class="noindent" >  <span 
class="ec-lmtt-10x-x-109">p.B = sqrt((j-1)*0.1);</span>
<!--l. 3394--><p class="noindent" >  <span 
class="ec-lmtt-10x-x-109">[e,data1,input,</span><span 
class="ec-lmtt-10x-x-109">~] = xsim(p);</span>
<!--l. 3396--><p class="noindent" >  <span 
class="ec-lmtt-10x-x-109">data</span><span 
class="ec-lmtt-10x-x-109">{1</span><span 
class="ec-lmtt-10x-x-109">}</span><span 
class="ec-lmtt-10x-x-109">{1</span><span 
class="ec-lmtt-10x-x-109">}(1,j,1:3) = data1</span><span 
class="ec-lmtt-10x-x-109">{1</span><span 
class="ec-lmtt-10x-x-109">}</span><span 
class="ec-lmtt-10x-x-109">{1</span><span 
class="ec-lmtt-10x-x-109">}(1,p.points,:);</span>
<!--l. 3398--><p class="noindent" >  <span 
class="ec-lmtt-10x-x-109">xk</span><span 
class="ec-lmtt-10x-x-109">{1</span><span 
class="ec-lmtt-10x-x-109">}</span><span 
class="ec-lmtt-10x-x-109">{1</span><span 
class="ec-lmtt-10x-x-109">}(j) = p.B</span><span 
class="ec-lmtt-10x-x-109">^2;</span>
<!--l. 3400--><p class="noindent" >  <span 
class="ec-lmtt-10x-x-109">D(j) = p.B</span><span 
class="ec-lmtt-10x-x-109">^2;</span>
<!--l. 3402--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">end</span>
<!--l. 3404--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">data</span><span 
class="ec-lmtt-10x-x-109">{1</span><span 
class="ec-lmtt-10x-x-109">}</span><span 
class="ec-lmtt-10x-x-109">{1</span><span 
class="ec-lmtt-10x-x-109">}(1,:,4) = input.ranges(1)*D(:);</span>
<!--l. 3406--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">input.xk = xk;</span>
<!--l. 3408--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">input.axes</span><span 
class="ec-lmtt-10x-x-109">{1</span><span 
class="ec-lmtt-10x-x-109">}</span><span 
class="ec-lmtt-10x-x-109">{1</span><span 
class="ec-lmtt-10x-x-109">} = 1:scanpoints;</span>
<!--l. 3410--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">xgraph(data,input);</span>
<!--l. 3412--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">end</span>                                                        </div></div>
</div>
<!--l. 3416--><p class="indent" >  Here \(p.deriv\) defines the time derivative function \(\dot {a}\), with \(w\) being the delta-correlated Gaussian noise
that is generated internally.
                                                                                
                                                                                
<!--l. 3419--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">6.4</span>  <a 
 id="x1-1050006.4"></a>Project examples</h3>
<!--l. 3421--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">6.4.1</span>  <a 
 id="x1-1060006.4.1"></a>Kubo project</h4>
<!--l. 3423--><p class="noindent" >To get started on more complex programs, we next simulate the Kubo oscillator, which is an
oscillator with a random frequency: \begin {equation}  \dot {a}=iaw.  \end {equation}
<!--l. 3430--><p class="noindent" >  
<h4 class="likesubsectionHead"><a 
 id="x1-1070006.4.1"></a>Exercises</h4>
<ul class="itemize1">     
<li class="itemize">
<!--l. 3432--><p class="noindent" >Simulate  the  Kubo  oscillator  using  a  file,  \(Kubo.m\),  with  two  ensemble  levels  to  allow
sampling error estimates. The error vector \(error\) gives the total time-step error plus the
sampling error.
</li>     
<li class="itemize">
<!--l. 3435--><p class="noindent" >Increase the first ensemble size to check how it modifies the sampling errors.</li></ul>
<div class="center" 
>
<!--l. 3438--><p class="noindent" >
<div class="doublebox"><div class="minipage"><span 
class="ec-lmtt-10x-x-109">function [error] = Kubo()</span>
<!--l. 3442--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.name = ’Kubo oscillator’;</span>
<!--l. 3444--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.ensembles = [400,16];</span>
<!--l. 3446--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.initial = @(v,p) 1;</span>
<!--l. 3448--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.deriv = @(a,w,</span><span 
class="ec-lmtt-10x-x-109">~) 1i*a.*w;</span>
<!--l. 3450--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.olabels = </span><span 
class="ec-lmtt-10x-x-109">{’</span><span 
class="ec-lmtt-10x-x-109">&#x003C;a</span><span 
class="ec-lmtt-10x-x-109">_1</span><span 
class="ec-lmtt-10x-x-109">&#x003E;’</span><span 
class="ec-lmtt-10x-x-109">};</span>
<!--l. 3452--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.file = ’kubo.mat’;</span>
<!--l. 3455--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">[error,</span><span 
class="ec-lmtt-10x-x-109">~,</span><span 
class="ec-lmtt-10x-x-109">~,</span><span 
class="ec-lmtt-10x-x-109">~] = xsim(p);</span>
<!--l. 3457--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">xgraph(p.file);</span>
<!--l. 3459--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">end</span>                                                        </div></div>
</div>
                                                                                
                                                                                
<!--l. 3463--><p class="noindent" >This function generates a data file, <span 
class="ec-lmtt-10x-x-109">kubo.mat</span>. If you run this twice without deleting the earlier
file, you will get a warning and the old file will be moved to a backup file-name, <span 
class="ec-lmtt-10x-x-109">kubo</span><span 
class="ec-lmtt-10x-x-109">_1.mat</span>,
to protect the earlier data. Note that xGRAPH will graph the data in the most recent file
saved.
<!--l. 3469--><p class="indent" >  You can also include modified graphics parameters as a second input when running <span 
class="ec-lmtt-10x-x-109">xGRAPH,</span>
just in case the first graphs you generate need further changes.
<!--l. 3473--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">6.4.2</span>  <a 
 id="x1-1080006.4.2"></a>Gaussian diffraction</h4>
<!--l. 3475--><p class="noindent" >Free diffraction and absorption of a Gaussian wave-function in \(d-1=s\) space dimensions, is given by
the partial differential equation (PDE): \begin {equation}  \frac {da}{dt}=-\frac {\gamma }{2}a+\frac {i}{2}D\nabla ^{2}a.  \end {equation}
<!--l. 3481--><p class="indent" >  The corresponding stochastic partial differential equation (SPDE) includes additional noise,
so that:
<!--l. 3486--><p class="indent" >  \begin {equation}  \frac {da}{dt}=-\frac {\gamma }{2}a+\frac {i}{2}D\nabla ^{2}a+bw(t,x).  \end {equation}
<!--l. 3488--><p class="indent" >  The xSPDE spectral definition in space is: \begin {equation}  \tilde {a}(t,\mathbf {k})=\frac {1}{\left [2\pi \right ]^{s/2}}\int e^{i\mathbf {k}\cdot \mathbf {x}}a(t,\mathbf {x})d\mathbf {x}\,.  \end {equation}
<!--l. 3493--><p class="indent" >  Together with the initial condition that \(a(0,x)=exp(-\left |\mathbf {x}\right |^{2}/2)\), this has an exact solution for the diffracted
intensity with \(b=0\), in either ordinary space or momentum space: <div class="eqnarray">\begin {eqnarray}  \left |a\left (t,\mathbf {x}\right )\right |^{2} &amp; = &amp; \frac {1}{\left (1+\left (Dt\right )^{2}\right )^{s/2}}exp\left (-\left |\mathbf {x}\right |^{2}/\left (1+\left (Dt\right )^{2}\right )-\gamma t\right )\nonumber \\ \left |\tilde {a}\left (t,\mathbf {k}\right )\right |^{2} &amp; = &amp; exp\left (-\left |\mathbf {k}\right |^{2}-\gamma t\right ).  \end {eqnarray}
</div>
<!--l. 3502--><p class="noindent" >  
<h4 class="likesubsectionHead"><a 
 id="x1-1090006.4.2"></a>Exercises</h4>
<ul class="itemize1">     
<li class="itemize">
<!--l. 3504--><p class="noindent" >Simulate Gaussian diffraction in three dimensions using an xSPDE function
</li>     
<li class="itemize">
<!--l. 3505--><p class="noindent" >Check your results against the exact solution
</li>     
<li class="itemize">
<!--l. 3506--><p class="noindent" >The example below stores data in a standard HDF5 file.</li></ul>
                                                                                
                                                                                
<div class="center" 
>
<!--l. 3508--><p class="noindent" >
<div class="doublebox"><div class="minipage"><span 
class="ec-lmtt-10x-x-109">function [e] = Gaussian()</span>
<!--l. 3512--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.dimensions = 4;</span>
<!--l. 3514--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.initial = @(v,p) exp(-0.5*(p.x.</span><span 
class="ec-lmtt-10x-x-109">^2+p.y.</span><span 
class="ec-lmtt-10x-x-109">^2+p.z.</span><span 
class="ec-lmtt-10x-x-109">^2));</span>
<!--l. 3516--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.linear = @(p) 1i*0.05*(p.Dx.</span><span 
class="ec-lmtt-10x-x-109">^2+p.Dy.</span><span 
class="ec-lmtt-10x-x-109">^2+p.Dz.</span><span 
class="ec-lmtt-10x-x-109">^2);</span>
<!--l. 3518--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.observe = @(a,p) a.*conj(a);</span>
<!--l. 3520--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.olabels = ’</span><span 
class="ec-lmtt-10x-x-109">|a(x)</span><span 
class="ec-lmtt-10x-x-109">|</span><span 
class="ec-lmtt-10x-x-109">^2’;</span>
<!--l. 3522--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.file = ’Gaussian.h5’;</span>
<!--l. 3524--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.images = 4;</span>
<!--l. 3526--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">e = xsim(p);</span>
<!--l. 3528--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">xgraph(p.file);</span>
<!--l. 3530--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">end</span>                                                        </div></div>
</div>     
<ul class="itemize1">
<li class="itemize">     
<!--l. 3534--><p class="noindent" ><span 
class="ec-lmbx-10x-x-109">Add an additive complex noise of</span> \(0.01(w_{1}+iw_{2}\)<span 
class="ec-lmbx-10x-x-109">) to the Gaussian differential equation,</span>
<span 
class="ec-lmbx-10x-x-109">then replot with an average over</span> \(100\) <span 
class="ec-lmbx-10x-x-109">samples.</span>
</li>     
<li class="itemize">
<!--l. 3537--><p class="noindent" >Work out the exact solution and repeat the comparisons.</li></ul>
<!--l. 3539--><p class="noindent" >Note that for this, you’ll need to add: \(p.deriv=@(a,w,p)\,\,..+0.01*(w(1,:)+i*w(2,:))\)
<!--l. 3541--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">6.5</span>  <a 
 id="x1-1100006.5"></a>Hints</h3>
<ul class="itemize1">     
<li class="itemize">
<!--l. 3543--><p class="noindent" >When first using xSPDE, it is a good idea to run the batch test script, <span 
class="ec-lmri-10x-x-109">Batchtest</span>.
</li>     
<li class="itemize">
<!--l. 3545--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">Batchtest </span>uses the Matlab parallel toolbox installation. If you have no license for
this, omit the third ensemble setting.
</li>     
<li class="itemize">
                                                                                
                                                                                
     
<!--l. 3547--><p class="noindent" >To create a project file, it is often easiest to start with an existing example function
using a similar equation: see the xAMPLES folder.
</li>     
<li class="itemize">
<!--l. 3549--><p class="noindent" >Graphics parameters can be included in the xSIM inputs to modify graphs.
</li>     
<li class="itemize">
<!--l. 3550--><p class="noindent" >Comparison functions can be included if you want to compare with analytic results.
</li>     
<li class="itemize">
<!--l. 3552--><p class="noindent" >Sections <a 
href="#x1-1520009">9<!--tex4ht:ref: sec:xSIM-reference --></a> and <a 
href="#x1-22200010">10<!--tex4ht:ref: sec:xGRAPH-reference --></a> list the input parameters.</li></ul>
<!--l. 3555--><p class="noindent" >
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
  
<h2 class="chapterHead"><span class="titlemark">7</span>  <a 
 id="x1-1110007"></a>Algorithms</h2>
<!--l. 3561--><p class="noindent" ><span 
class="ec-lmbxi-10x-x-109">This section describes the general background to the choices of algorithms</span>
<span 
class="ec-lmbxi-10x-x-109">available, and how to add custom numerical algorithms if required.</span>
  
<h3 class="sectionHead"><span class="titlemark">7.1</span>  <a 
 id="x1-1120007.1"></a>Introduction to algorithms</h3>
<!--l. 3565--><p class="noindent" >Stochastic, partial and ordinary differential equations are central to numerical mathematics.
Ordinary differential equations have been known in some form ever since calculus
was invented. There are a truly extraordinary number of algorithms used to solve
these equations. One program cannot possibly provide all of them. This section
provides an overview of the included algorithms, for the more advanced and expert
user.<br 
class="newline" />xSPDE has six built-in choices of algorithm, with defaults. All built-in methods have an
interaction picture and can be used with any space dimension, including \(dimensions=1\), which is an ordinary
stochastic equation. All can be used with stochastic or with non-stochastic equations, and with
order extrapolation. <br 
class="newline" />For stochastic equations, the Euler method requires an Ito form of stochastic equation, the
implicit Euler method requires an implicit Ito form, while the others should be used with the
Stratonovich form of calculus. Each uses the interaction picture to take care of exactly soluble
linear terms.
<!--l. 3583--><p class="indent" >  The standard xSIM algorithms given below are available for ODEs, PDEs, SDEs and
SPDEs. More advanced algorithms for specialized cases are described in section
<a 
href="#x1-1110007">7<!--tex4ht:ref: sec:Algorithms --></a>.
<!--l. 3587--><p class="indent" >  For stochastic differential equations, which are non-differentiable, the usual rules of
calculus do not apply because stochastic noise is non-differentiable. It has fluctuations
proportional to \(1/\sqrt {dtdV}\), for noise defined on a lattice with temporal cell-size \(dt\) and spatial
cell-size \(dV\). Hence, the usual differentiability and smoothness properties required to give
high-order convergence for standard Runge-Kutta methods are simply not present.
Instead, xSPDE has a built-in extrapolation to zero step-size for high-order stochastic
convergence.
<!--l. 3596--><p class="indent" >  Many more complex higher order algorithms for stochastic integration exist but are not
included in the current xSPDE distribution, and users are encouraged to contribute their
favorite methods.
<!--l. 3600--><p class="indent" >  We note here that there are multiple error sources possible. SDE/SPDE errors are often
dominated by the sampling error, not discretization. In addition, all convergence theorems
only apply to the limit of zero step-size. One may be very far from this regime in a given
practical calculation. Analytic error estimates also have prefactors which are hard to calculate.
However, xSPDE can numerically estimate both the discretization and sampling error for any
given average observable.
<!--l. 3608--><p class="noindent" >
                                                                                
                                                                                
  
<h3 class="sectionHead"><span class="titlemark">7.2</span>  <a 
 id="x1-1130007.2"></a>General differential form</h3>
<!--l. 3610--><p class="noindent" >The general equation treated is given in differential form as \begin {equation}  \begin {split}\frac {\partial \boldsymbol {a}}{\partial t}=\boldsymbol {A}\left [\boldsymbol {\nabla },\boldsymbol {a},t\right ]+\underline {\mathbf {B}}\left [\boldsymbol {\nabla },\boldsymbol {a},t\right ]\cdot \boldsymbol {\zeta }(t)+\underline {\mathbf {L}}\left [\boldsymbol {\nabla }\right ]\cdot \boldsymbol {a}.\end {split} \label {eq:Standard xspde SDE}  \end {equation}
It is convenient for the purposes of describing interaction picture methods, to introduce an
abbreviated notation as: \begin {equation}  \begin {split}\begin {aligned}\mathcal {D}\left [\mathbf {a},t\right ]=\boldsymbol {A}\left [\boldsymbol {a},t\right ]+\underline {\mathbf {B}}\left [\boldsymbol {a},t\right ]\cdot \boldsymbol {\zeta }(t).\end {aligned} \end {split}  \end {equation}
Hence, we can rewrite the differential equation in the form: \begin {equation}  \begin {split}\frac {\partial \boldsymbol {a}}{\partial t}=\mathcal {D}\left [\mathbf {a},t\right ]+\underline {\mathbf {L}}\left [\boldsymbol {\nabla }\right ]\cdot \boldsymbol {a}.\end {split}  \end {equation}
Next, we define a linear propagator. This is given formally by: \begin {equation}  \begin {split}\mathcal {P}\left (\Delta t\right )=\exp \left (\Delta t\underline {\mathbf {L}}\left [\boldsymbol {\nabla }\right ]\right )\end {split} .  \end {equation}
Typically, but not necessarily, this is evaluated in Fourier space, where it should be just a
diagonal term in the momentum vector conjugate to the transverse space coordinate. It will
then involve a Fourier transform, multiplication by an appropriate function of the momentum,
and then an inverse Fourier transform afterwards. For simplicity, the stochastic noise is
assumed constant throughout the interval \(dt\). The reader is referred to the literature for more
details.
<!--l. 3638--><p class="indent" >  It is simple to add your own algorithm if you prefer a different one. Note that if they use an
interaction picture, then <span 
class="ec-lmri-10x-x-109">ipsteps </span>must be given explicitly to specify the interaction picture
duration.
<!--l. 3642--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">7.3</span>  <a 
 id="x1-1140007.3"></a>Standard methods</h3>
<!--l. 3644--><p class="noindent" >The standard methods are listed below. All of these can be used with any equation: ODE,
SDE, PDE or SPDE, either with or without a linear interaction picture term.
<!--l. 3648--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">7.3.1</span>  <a 
 id="x1-1150007.3.1"></a><span 
class="ec-lmri-10x-x-109">Euler</span>: Ito-Euler</h4>
<!--l. 3650--><p class="noindent" >This is an explicit Ito-Euler method using an interaction picture. While traditional, it is not
generally recommended. If it is used, very small step-sizes will generally be necessary to reduce
errors to a usable level. This is because it is is only convergent to first order deterministically
and tends to have large errors.
<!--l. 3656--><p class="indent" >  It is designed for use with an Ito form of stochastic equation. It requires one IP transform
per step (\(p.ipsteps=1\)). Starting from time \(t=t_{n}\), to get the next time point at \(t=t_{n+1}=t_{n}+\Delta t\), one calculates: \begin {equation}  \begin {split}\begin {aligned}\Delta \mathbf {a}_{n} &amp; =\Delta t\mathcal {D}\left [\mathbf {a}_{n},t_{n}\right ]\\ \mathbf {a}_{n+1} &amp; =\mathcal {P}\left (\Delta t\right )\cdot \left [\mathbf {a}_{n}+\Delta \mathbf {a}_{n}\right ] \end {aligned} \end {split}  \end {equation}
<!--l. 3668--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">7.3.2</span>  <a 
 id="x1-1160007.3.2"></a><span 
class="ec-lmri-10x-x-109">Implicit</span>: implicit Ito-Euler</h4>
<!--l. 3670--><p class="noindent" >This is a fully implicit Ito-Euler method using an interaction picture. It is more robust, though
slower, than the explicit form. If it is used, very small step-sizes will generally be necessary to
                                                                                
                                                                                
reduce errors to a usable level.
<!--l. 3675--><p class="indent" >  This is because it is is only convergent to first order, and therefore tends to have large
errors. It is designed for use with an implicit Ito form of stochastic equation. Note that this
implies double the usual Stratonovich correction!
<!--l. 3680--><p class="indent" >  It requires one IP transform per step (\(p.ipsteps=1\)). Starting from time \(t=t_{n}\), to get the next
time point at \(t=t_{n+1}=t_{n}+\Delta t\), one calculates, using iteration to get the implicit result of the next
time-point:
<!--l. 3691--><p class="indent" >  \begin {equation}  \begin {split}\begin {aligned}\bar {\mathbf {a}}^{(0)} &amp; =\mathcal {P}\left (\Delta t\right )\cdot \left [\mathbf {a}_{n}\right ]\\ \bar {\mathbf {a}}^{(i)} &amp; =\bar {\mathbf {a}}^{(0)}+\Delta t\mathcal {D}\left [\bar {\mathbf {a}}^{(i-1)},t_{n+1}\right ]\\ \mathbf {a}_{n+1} &amp; =\bar {\mathbf {a}}^{(iter)} \end {aligned} \end {split}  \end {equation}
\begin {equation}  \begin {split}\begin {aligned}\tilde {\mathbf {a}}_{n} &amp; =\mathcal {P}\left (\Delta t\right )\cdot \left [\mathbf {a}_{n}\right ]\\ \Delta \mathbf {a}_{n} &amp; =\Delta t\mathcal {D}\left [\tilde {\mathbf {a}}_{n}+\Delta \mathbf {a}_{n},t_{n}\right ]\\ \mathbf {a}_{n+1} &amp; =\tilde {\mathbf {a}}_{n}+\Delta \mathbf {a}_{n} \end {aligned} \end {split}  \end {equation}
<!--l. 3701--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">7.3.3</span>  <a 
 id="x1-1170007.3.3"></a><span 
class="ec-lmri-10x-x-109">MP</span>: Midpoint</h4>
<!--l. 3703--><p class="noindent" >This is a semi-implicit midpoint method using an interaction picture. It gives good results for
stochastic and stochastic partial differential equations. It is convergent to second order in time
for deterministic equations and for stochastic equations with commuting noise. It is
strongly convergent and robust. It requires two half-length IP transforms per step
(\(p.ipsteps=2\)).
<!--l. 3710--><p class="indent" >  To get the next time point, one calculates a midpoint derivative iteratively at time to get
the next time point at \(t=t_{n+1/2}=t_{n}+\Delta t/2\), to give an estimated midpoint field \(\bar {\mathbf {a}}^{(i)}\), usually with four iterations. The
number of iterations can be changed: \begin {equation}  \begin {split}\begin {aligned}\bar {\mathbf {a}}^{(0)} &amp; =\mathcal {P}\left (\frac {\Delta t}{2}\right )\cdot \left [\mathbf {a}_{n}\right ]\\ \bar {\mathbf {a}}^{(i)} &amp; =\bar {\mathbf {a}}^{(0)}+\frac {\Delta t}{2}\mathcal {D}\left [\bar {\mathbf {a}}^{(i-1)},t_{n+1/2}\right ]\\ \mathbf {a}_{n+1} &amp; =\mathcal {P}\left (\frac {\Delta t}{2}\right )\cdot \left [2\bar {\mathbf {a}}^{(iter)}-\bar {\mathbf {a}}^{(0)}\right ] \end {aligned} \end {split}  \end {equation}
<!--l. 3722--><p class="indent" >  This is the default method for stochastic cases.
<!--l. 3724--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">7.3.4</span>  <a 
 id="x1-1180007.3.4"></a><span 
class="ec-lmri-10x-x-109">MPadap</span>t: adaptive midpoint</h4>
<!--l. 3726--><p class="noindent" >This is an implicit midpoint method using an interaction picture, together with an
adaptive technique for integrating highly nonlinear equations. At low amplitudes it is
identical to the standard midpoint method. For amplitudes \(|a_{i}|^{2}\) above a critical value,
\(r.adapt\), the amplitude is inverted and propagated using the differential equation for its
inverse.
<!--l. 3733--><p class="indent" >  Initially a switch \(p\) is set to \(1\) for low amplitudes, and \(-1\) for high amplitudes. To get the next
time point, one calculates a midpoint derivative iteratively at time to get the next time point
at \(t=t_{n+1/2}=t_{n}+\Delta t/2\), to give an estimated midpoint field \(\bar {\mathbf {a}}^{(i)}\), as above, but with the derivative modified to give the
derivative of \(a_{i}^{p}\): \begin {equation}  \begin {split}\begin {aligned}\bar {\mathbf {a}}^{(0)} &amp; =\mathcal {P}\left (\frac {\Delta t}{2}\right )\cdot \left [\mathbf {a}_{n}\right ]\\ \tilde {\mathbf {a}}^{(0)} &amp; =\mathbf {a}_{n}^{p}\\ \tilde {\mathbf {a}}^{(i)} &amp; =\tilde {\mathbf {a}}^{(0)}+\frac {\Delta t}{2}p\left [\tilde {\mathbf {a}}^{(i-1)}\right ]{}^{1-p}\left (\mathcal {D}\left [[\tilde {\mathbf {a}}^{(i-1)}]^{p},t_{n+1/2}\right ]\right )\\ \mathbf {a}_{n+1} &amp; =\mathcal {P}\left (\frac {\Delta t}{2}\right )\cdot \left [2\tilde {\mathbf {a}}^{(iter)}-\tilde {\mathbf {a}}^{(0)}\right ]^{p} \end {aligned} \end {split}  \end {equation}
                                                                                
                                                                                
<!--l. 3749--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">7.3.5</span>  <a 
 id="x1-1190007.3.5"></a><span 
class="ec-lmri-10x-x-109">RK2</span>: second order Runge-Kutta</h4>
<!--l. 3751--><p class="noindent" >This is a second order Runge-Kutta method using an interaction picture. It is convergent to
second order in time for non-stochastic equations, and for stochastic equations with
additive noise, but otherwise it is first order. It often has higher errors than midpoint
methods. It requires two IP transforms per step, but each is a full time-step long
(\(p.ipsteps=1\)).
<!--l. 3758--><p class="indent" >  To get the next time point, one calculates: \begin {equation}  \begin {split}\begin {aligned}\bar {\mathbf {a}} &amp; =\mathcal {P}\left (\Delta t\right )\cdot \left [\mathbf {a}_{n}\right ]\\ \mathbf {d}^{(1)} &amp; =\Delta t\mathcal {P}\left (\Delta t\right )\cdot \mathcal {D}\left [\mathbf {a}_{n},t_{n}\right ]\\ \mathbf {d}^{(2)} &amp; =\Delta t\mathcal {D}\left [\bar {\mathbf {a}}+\mathbf {d}^{(1)},t_{n+1}\right ]\\ \mathbf {a}_{n+1} &amp; =\bar {\mathbf {a}}+\left (\mathbf {d}^{(1)}+\mathbf {d}^{(2)}\right )/2. \end {aligned} \end {split}  \end {equation}
<!--l. 3769--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">7.3.6</span>  <a 
 id="x1-1200007.3.6"></a><span 
class="ec-lmri-10x-x-109">RK4</span>: fourth order Runge-Kutta</h4>
<!--l. 3771--><p class="noindent" >This is a fourth order Runge-Kutta method using an interaction picture. It is convergent to
fourth order in time for non-stochastic equations, but for stochastic equations it can be more
slowly convergent than the midpoint method. It requires four half-length IP transforms per
step (<span 
class="ec-lmri-10x-x-109">ipsteps </span>= 2). To get the next time point, one calculates four derivatives sequentially:
\begin {equation}  \begin {split}\begin {aligned}\bar {\mathbf {a}} &amp; =\mathcal {P}\left (\frac {\Delta t}{2}\right )\cdot \left [\mathbf {a}_{n}\right ]\\ \mathbf {d}^{(1)} &amp; =\frac {\Delta t}{2}\mathcal {P}\left (\frac {\Delta t}{2}\right )\cdot \mathcal {D}\left [\mathbf {a}_{n},t_{n}\right ]\\ \mathbf {d}^{(2)} &amp; =\frac {\Delta t}{2}\mathcal {D}\left [\bar {\mathbf {a}}+\mathbf {d}^{(1)},t_{n+1/2}\right ]\\ \mathbf {d}^{(3)} &amp; =\frac {\Delta t}{2}\mathcal {D}\left [\bar {\mathbf {a}}+\mathbf {d}^{(2)},t_{n+1/2}\right ]\\ \mathbf {d}^{(4)} &amp; =\frac {\Delta t}{2}\mathcal {D}\left [\mathcal {P}\left (\frac {\Delta t}{2}\right )\left [\bar {\mathbf {a}}+2\mathbf {d}^{(3)},t_{n+1}\right ]\right ]\\ \mathbf {a}_{n+1} &amp; =\mathcal {P}\left (\frac {\Delta t}{2}\right )\cdot \left [\bar {\mathbf {a}}+\left (\mathbf {d}^{(1)}+2\left (\mathbf {d}^{(2)}+\mathbf {d}^{(3)}\right )\right )/3\right ]+\mathbf {d}^{(4)}/3 \end {aligned} \end {split}  \end {equation}
This might seem the obvious choice, having the highest order. However, it can converge at a
range of apparent rates, depending on the relative importance of stochastic and
non-stochastic terms. Due to its use of differentiability, it may converge more slowly than the
midpoint method with stochastic terms present. It is the default for ODE and PDE
cases.
<!--l. 3795--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">7.4</span>  <a 
 id="x1-1210007.4"></a>Advanced method libraries</h3>
<!--l. 3797--><p class="noindent" >Three more advanced method libraries are included here, namely <span 
class="ec-lmri-10x-x-109">weighted</span>, <span 
class="ec-lmri-10x-x-109">projected </span>and
<span 
class="ec-lmri-10x-x-109">forward-backward </span>stochastic differential equations. If you have a favorite algorithm that is not
included, user-defined algorithms and libraries can be added. The existing methods are listed
below, and the corresponding .m-files can be used as a model.
<!--l. 3804--><p class="indent" >  Define the routine, for example &#x0022;myalgorithm.m&#x0022;, set \(p.method=@myalgorithm\), then adjust the value of <span 
class="ec-lmri-10x-x-109">ipsteps </span>and
<span 
class="ec-lmri-10x-x-109">order </span>if these must be changed to a new value. The interaction-picture transform, <span 
class="ec-lmri-10x-x-109">prop</span>, can
also be changed if the built-in choice is not sufficient.The xSPDE algorithms available
currently treat
<ul class="itemize1">     
<li class="itemize">
<!--l. 3810--><p class="noindent" >ordinary (and partial) differential equations
                                                                                
                                                                                
     
</li>
<li class="itemize">     
<!--l. 3811--><p class="noindent" >stochastic differential equations
</li>     
<li class="itemize">
<!--l. 3812--><p class="noindent" >stochastic partial differential equations
</li>     
<li class="itemize">
<!--l. 3813--><p class="noindent" >weighted stochastic differential equations
</li>     
<li class="itemize">
<!--l. 3814--><p class="noindent" >projected stochastic differential equations,
</li>     
<li class="itemize">
<!--l. 3815--><p class="noindent" >forward-backward stochastic differential equations</li></ul>
<!--l. 3817--><p class="noindent" >The first three have already been treated. In this section, we explain the last three cases, which
involve more specialized libraries of functions.
<!--l. 3821--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">7.4.1</span>  <a 
 id="x1-1220007.4.1"></a>Additional inputs</h4>
<!--l. 3823--><p class="noindent" >Some of the more advanced features of the libraries require additional input parameters. In
particular:
<dl class="description"><dt class="description">     
<!--l. 3826--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">backfields</span> 
</dt><dd 
class="description">
<!--l. 3826--><p class="noindent" >is  used  for  forward-backward  stochastic  equations,  describing  backward  time
components. These are described in the <span 
class="ec-lmri-10x-x-109">Forward-backward </span>section. Note that <span 
class="ec-lmbx-10x-x-109">fields</span>
is still used, and it gives the total number of forward+backward fields.
</dd>     
<dt class="description">
<!--l. 3830--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">auxfields</span> 
</dt><dd 
class="description">
<!--l. 3830--><p class="noindent" >gives the number of auxiliary fields. These have a functional definition (<span 
class="ec-lmri-10x-x-109">defines</span>)
that includes both a field and noise variable, as needed for spectral observables.
Field  index  numbers  \(i\)  greater  than  \(fields\)  access  the  auxiliary  fields  in  the  <span 
class="ec-lmri-10x-x-109">observe</span>
function.</dd></dl>
                                                                                
                                                                                
<!--l. 3837--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">7.5</span>  <a 
 id="x1-1230007.5"></a>Weighted library</h3>
<!--l. 3839--><p class="noindent" >In some types of stochastic equation, there is a weight associated with each trajectory, which is
used to weight the probability of the trajectory. These equations still have the standard form
of Eq \eqref{eq:SDE}, with an extra weight equation, Eq \eqref{eq:SDE-2}. However, the
results for all mean values are weighted by a term \(\exp \left (\Omega \left (t\right )\right )\), so that: \begin {equation}  \left \langle \mathbf {O}\right \rangle _{\Omega }=\frac {\sum _{n}\mathbf {O}\left (\mathbf {a}^{\left (n\right )}\right )\exp \left (\Omega ^{\left (n\right )}\left (t\right )\right )}{\sum _{n}\exp \left (\Omega ^{\left (n\right )}\left (t\right )\right )}.\label {eq:Weighted-averages}  \end {equation}
<!--l. 3849--><p class="indent" >  This reduces to the standard expression of Eq \eqref{eq:averages-1} in the case that \(\Omega \left (t\right )=0\). To
simulate these equations automatically, the weight exponent \(\Omega \) is integrated as the <span 
class="ec-lmri-10x-x-109">last </span>field in
the vector \(\mathbf {a}\), which must have at least two components. A nonzero threshold weight, \(thresholdw\), must be
entered to allow calculation of breeding.
<!--l. 3856--><p class="indent" >  With these changes, averages in each vector ensemble are calculated using Eq
\eqref{eq:Weighted-averages}. Before each plotted step in the calculation, a breeding
calculation is carried out. There are \(p.steps(1)-1\) of these in total. During breeding, any weight such that \(\exp \left (\Omega ^{(n)}\right )&lt;thresholdw/\left \langle \exp \left (\Omega \right )\right \rangle \)
is removed.
<!--l. 3863--><p class="indent" >  The most probable trajectory is then duplicated to replace the low-weight trajectory. Both
exponential weights are halved, so the total weight of the remaining trajectories is unchanged.
If they are complex, weights such that \(\exp \left (Re\left (\Omega ^{(n)}\right )\right )&lt;thresholdw/\left \langle \exp \left (Re\left (\Omega \right )\right )\right \rangle \) are removed, and the real weight of the bred trajectory
is reduced, which removes any low-weight trajectories that don’t contribute. When used, the
internal variable <span 
class="ec-lmri-10x-x-109">p.breedw </span>is set to allow the fraction of trajectories that are bred per step to
be monitored.
<!--l. 3872--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">7.5.1</span>  <a 
 id="x1-1240007.5.1"></a>Example</h4>
<!--l. 3874--><p class="noindent" >The following example shows how weights are implemented.
<div class="center" 
>
<!--l. 3875--><p class="noindent" >
                                                                                
                                                                                
<div class="doublebox"><div class="minipage"><span 
class="ec-lmtt-10x-x-109">function [e] = Weightcheck()</span>
<!--l. 3879--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.name = ’Weightcheck’;</span>
<!--l. 3881--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.ensembles = [10000,10,1];</span>
<!--l. 3883--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.fields = 2;</span>
<!--l. 3885--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.points = 6;</span>
<!--l. 3887--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.order = 2;</span>
<!--l. 3889--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.thresholdw = 0.1;</span>
<!--l. 3891--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.diffplot = 1;</span>
<!--l. 3893--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.initial = @(w,p) [1+w(1,:);0*w(2,:)];</span>
<!--l. 3895--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.deriv = @(a,z,p) [-a(1,:)+ z(1,:);-a(2,:)+ z(2,:)];</span>
<!--l. 3897--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.observe</span><span 
class="ec-lmtt-10x-x-109">{1</span><span 
class="ec-lmtt-10x-x-109">} = @(a,p) a(1,:);</span>
<!--l. 3899--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.observe</span><span 
class="ec-lmtt-10x-x-109">{2</span><span 
class="ec-lmtt-10x-x-109">} = @(a,p) p.breedfrac;</span>
<!--l. 3901--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.compare</span><span 
class="ec-lmtt-10x-x-109">{1</span><span 
class="ec-lmtt-10x-x-109">} = @(p) exp(-p.t);</span>
<!--l. 3903--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.olabels</span><span 
class="ec-lmtt-10x-x-109">{1</span><span 
class="ec-lmtt-10x-x-109">} = ’</span><span 
class="ec-lmtt-10x-x-109">&#x003C;a</span><span 
class="ec-lmtt-10x-x-109">&#x003E;’;</span>
<!--l. 3906--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.olabels</span><span 
class="ec-lmtt-10x-x-109">{2</span><span 
class="ec-lmtt-10x-x-109">} = ’</span><span 
class="ec-lmtt-10x-x-109">&#x003C;fractional breeds per step</span><span 
class="ec-lmtt-10x-x-109">&#x003E;’;</span>
<!--l. 3908--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">e = xcheck(2,p);</span>
<!--l. 3910--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">end</span>                                                        </div></div>
</div>
<!--l. 3914--><p class="indent" >  This algorithm converges with second-order accuracy for this exercise, due to the structure
of the equation. The example also demonstrates how to use the <span 
class="ec-lmri-10x-x-109">xcheck </span>function instead of
<span 
class="ec-lmri-10x-x-109">xspde</span>, to check convergence.
<!--l. 3919--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">7.6</span>  <a 
 id="x1-1250007.6"></a><span 
class="ec-lmri-10x-x-109">Enproj</span>, <span 
class="ec-lmri-10x-x-109">MPproj</span>, <span 
class="ec-lmri-10x-x-109">MPnproj</span>: projection library</h3>
<!--l. 3921--><p class="noindent" >It is sometimes necessary to constrain an equation to a sub-manifold, with an equation of
form: \begin {equation}  \mathbf {f}\left (\mathbf {a}\right )=0,  \end {equation}
where \(\mathbf {f}\left (\mathbf {a}\right )\) is a scalar or vector function that defines the relevant manifold in Euclidean space. The
projected SDE then has the form of a Stratonovich SDE, where: \begin {equation}  \frac {\partial \mathbf {a}}{\partial t}=\mathcal {P}_{\mathbf {a}}^{\parallel }\left [\mathbf {A}\left [\mathbf {a}\right ]+\underline {\mathbf {B}}\left [\mathbf {a}\right ]\cdot \mathbf {w}(t)\right ]\,,  \end {equation}
where \(\mathcal {P}_{\mathbf {a}}^{\parallel }\) is a tangential projection operator at location \(\mathbf {a}\) on the sub-manifold, and as usual, \(\mathbf {A}\) is a
vector, \(\underline {\mathbf {B}}\) a matrix and \(\mathbf {w}\) is a real Gaussian noise vector, delta-correlated in time. Similarly, the
general stochastic partial differential equation can be written in projected form
as
<!--l. 3941--><p class="indent" >  \begin {equation}  \frac {\partial \mathbf {a}}{\partial t}=\mathcal {P}_{\mathbf {a}}^{\parallel }\left [\mathbf {A}\left [\mathbf {a}\right ]+\underline {\mathbf {B}}\left [\mathbf {a}\right ]\cdot \mathbf {w}(t,\mathbf {x})+\underline {\mathbf {L}}\left [\mathbf {\nabla },\mathbf {a}\right ]\,\right ].  \end {equation}
<!--l. 3943--><p class="indent" >  When numerically integrating these, it is also useful to have a normal projection \(\mathcal {P}^{\perp }\)available.
This is used to normally project to the nearest point on the manifold, to eliminate constraint
errors. These are solved using functions collected in a projection library, to provide the
specialized methods that are needed for this purpose.
<!--l. 3950--><p class="indent" >  The projection library has three predefined algorithms,
<ul class="itemize1">     
<li class="itemize">
                                                                                
                                                                                
     
<!--l. 3952--><p class="noindent" ><span 
class="ec-lmbxi-10x-x-109">Enproj</span>,
</li>     
<li class="itemize">
<!--l. 3953--><p class="noindent" ><span 
class="ec-lmbxi-10x-x-109">MPproj</span>,
</li>     
<li class="itemize">
<!--l. 3954--><p class="noindent" ><span 
class="ec-lmbxi-10x-x-109">MPnproj</span>.</li></ul>
<!--l. 3956--><p class="noindent" >Here the capital E stands for Euler, MP for midpoint. All usd tangential projection. The letter
<span 
class="ec-lmri-10x-x-109">n=normal </span>indicates if an additional normal projection is used. In all cases, if it is present, a
normal projection is used last. The recommended type is <span 
class="ec-lmbxi-10x-x-109">MPnproj</span>, due to its much lower
errors.
<!--l. 3962--><p class="indent" >  Tangential and normal projections are needed to define the geometry of any sub-manifold.
These are input by setting the variable <span 
class="ec-lmri-10x-x-109">project </span>equal to a function handle that defines the
projection. These can be user provided if required. There are three different predefined
manifold geometry types, which need different inputs, given below.
<!--l. 3968--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">7.6.1</span>  <a 
 id="x1-1260007.6.1"></a>Calling the <span 
class="ec-lmri-10x-x-109">project </span>function</h4>
<!--l. 3970--><p class="noindent" >The calling arguments for <span 
class="ec-lmri-10x-x-109">project </span>are: <span 
class="ec-lmri-10x-x-109">(d,a,n,p)</span>, where d is a vector to be tangentially
projected at location a, a is the current (near)-manifold location, n is an option switch, and p
is the parameter structure. The options available in any <span 
class="ec-lmri-10x-x-109">project </span>implementation
are:  
<ul class="itemize1">
<li class="itemize">     
<!--l. 3976--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">n = 0 </span>returns the tangent vector for testing
</li>     
<li class="itemize">
<!--l. 3977--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">n = 1 </span>returns the tangential projection of <span 
class="ec-lmri-10x-x-109">d </span>at <span 
class="ec-lmri-10x-x-109">a</span>
</li>     
<li class="itemize">
<!--l. 3978--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">n = 2 </span>returns the normal projection of <span 
class="ec-lmri-10x-x-109">a</span>, where <span 
class="ec-lmri-10x-x-109">d </span>is not used
</li>     
<li class="itemize">
<!--l. 3980--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">n = 4 </span>returns the constraint function at <span 
class="ec-lmri-10x-x-109">a </span>for testing</li></ul>
                                                                                
                                                                                

<!--l. 3982--><p class="noindent" >The projections defined in an xSPDE <span 
class="ec-lmri-10x-x-109">project </span>function can be of any type. Arbitrary
dimension reduction and manifold geometry is possible. Currently in the examples,
dimensionality is reduced by 1, and normal projections use fixed point iterations, defined by
<span 
class="ec-lmri-10x-x-109">iterproj</span>.
<!--l. 3987--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">7.6.2</span>  <a 
 id="x1-1270007.6.2"></a>The predefined manifold geometries</h4>
<!--l. 3989--><p class="noindent" >The current manifolds, by setting p.project = @Quadproj ..., are as follows:
<ol  class="enumerate1" >
<li 
  class="enumerate" id="x1-127002x1">     
<!--l. 3992--><p class="noindent" >Quadratic - <span 
class="ec-lmri-10x-x-109">Quadproj </span>- needs: <span 
class="ec-lmri-10x-x-109">qcproj </span>defined by \(f=\sum q{}_{ij}x^{i}x^{j}-1=0\)
</li>
<li 
  class="enumerate" id="x1-127004x2">     
<!--l. 3993--><p class="noindent" >Polynomial - <span 
class="ec-lmri-10x-x-109">Polproj </span>- needs: <span 
class="ec-lmri-10x-x-109">vcproj </span>defined by \(f=\sum v_{i}(x^{i})^{p}-1=0\)
</li>
<li 
  class="enumerate" id="x1-127006x3">     
<!--l. 3994--><p class="noindent" >Catenoid - <span 
class="ec-lmri-10x-x-109">Catproj </span>- uses fixed coefficients defined by \(f=(x_{1})^{2}+(x_{2})^{2}-(sinh(x_{3}))^{2}-1=0\)</li></ol>
<!--l. 3996--><p class="noindent" >Any other manifold can be used by replacing these predefined manifolds with an appropriate
<span 
class="ec-lmri-10x-x-109">project </span>function.
<!--l. 3999--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">7.7</span>  <a 
 id="x1-1280007.7"></a><span 
class="ec-lmri-10x-x-109">MPfb</span>: Forward-backward library</h3>
<!--l. 4001--><p class="noindent" >The xSPDE forward-backward library implements an iterative forward-backward stochastic
method which propagates an SDE or PSDE forward and backward in time. The iteration will
converge in simple cases, typically with no cross-coupling outside of the boundary conditions.
It uses the algorithm <span 
class="ec-lmri-10x-x-109">MPfb.</span>
<!--l. 4007--><p class="indent" >  The general FB equations have the following structure, written as an integral equation to
make it clear what the relevant boundary conditions are:
<!--l. 4014--><p class="indent" >  \begin {align}  \mathbf {p}\left (t\right ) &amp; =\mathbf {p}\left (0,\mathbf {q}\left (0\right )\right )+\int _{0}^{t}\left \{ \mathbf {A}^{p}\left [\mathbf {a}\left (t'\right )\right ]dt'+\underline {\mathbf {B}}^{p}\left [\mathbf {a}\left (t'\right )\right ]\cdot d\mathbf {w}^{p}(t')\right \} \nonumber \\ \mathbf {q}\left (t\right ) &amp; =\mathbf {q}\left (T,\mathbf {p}\left (T\right )\right )+\int _{t}^{T}\left \{ \mathbf {A}^{q}\left [\mathbf {a}\left (t'\right )\right ]dt'+\underline {\mathbf {B}}^{q}\left [\mathbf {a}\left (t'\right )\right ]\cdot d\mathbf {w}^{q}(t')\right \} .  \end {align}
<!--l. 4015--><p class="indent" >  Here, \(\mathbf {a}=\left [\mathbf {p},\mathbf {q}\right ]\) includes forward components \(\mathbf {p}\) and backwards components \(\mathbf {q}\). These have “initial”
conditions in the past and the future, respectively, and can depend on random inputs, just as
with ordinary stochastic equations.
                                                                                
                                                                                
<!--l. 4021--><p class="indent" >  The library includes the <span 
class="ec-lmri-10x-x-109">xpathfb </span>function which replaces the <span 
class="ec-lmri-10x-x-109">xpath </span>function, which is used
automatically. However, the user must specify a modified step integrator, either <span 
class="ec-lmri-10x-x-109">Eulerfb </span>or
<span 
class="ec-lmri-10x-x-109">MPfb</span>. The <span 
class="ec-lmri-10x-x-109">initial </span>and deriv routines require additional arguments, which are described in the
table below, and are used during the iteration scheme.
<!--l. 4028--><p class="indent" >  The noise terms \(\mathbf {w}=\left [\mathbf {w}^{p},\mathbf {w}^{q}\right ]\) are uncorrelated real Gaussian noises: \begin {equation}  \left \langle dw_{i}^{\alpha }\left (\mathbf {x}\right )dw_{j}^{\beta }\left (\mathbf {x}'\right )\right \rangle =\delta _{ij}\delta _{\alpha \beta }dt.  \end {equation}
This is solved in differential form, where \(t_{-}=T-t\), as: \begin {align}  \frac {\partial \mathbf {p}}{\partial t} &amp; =\mathbf {A}^{p}\left [\mathbf {a}\right ]+\underline {\mathbf {B}}^{p}\left [\mathbf {a}\right ]\cdot \mathbf {w}^{p}(t)\,\nonumber \\ \frac {\partial \mathbf {q}}{\partial t_{-}} &amp; =\mathbf {A}^{q}\left [\mathbf {a}\right ]+\underline {\mathbf {B}}^{q}\left [\mathbf {a}\right ]\cdot \mathbf {w}^{q}(t)\,.  \end {align}
<!--l. 4039--><p class="indent" >  Each equation is solved by iteration. The previous value of the counter-propagating field, ie \(\mathbf {a}^{(n-1)}\),
is used to solve for \(\mathbf {a}^{(n)}\) in step \(n\), since the current value is not yet known. That is, the algorithm is:
\begin {align}  \frac {\partial \mathbf {p}^{(n)}}{\partial t} &amp; =\mathbf {A}^{p}\left [\mathbf {p}^{(n)}\left (t\right ),\mathbf {q}^{(n-1)}\left (t\right )\right ]+\underline {\mathbf {B}}^{p}\left [\mathbf {p}^{(n)}\left (t\right ),\mathbf {q}^{(n-1)}\left (t\right )\right ]\cdot \mathbf {w}^{p}\left (t\right )\,\\ \frac {\partial \mathbf {q}^{(n)}}{\partial t_{-}} &amp; =\mathbf {A}^{q}\left [\mathbf {p}^{(n-1)}\left (t_{-}\right ),\mathbf {q}^{(n)}\left (t_{-}\right )\right ]+\underline {\mathbf {B}}^{q}\left [\mathbf {p}^{(n-1)}\left (t_{-}\right ),\mathbf {q}^{(n)}\left (t_{-}\right )\right ]\cdot \mathbf {w}^{q}\left (t_{-}\right )\,,\nonumber  \end {align}
<!--l. 4047--><p class="indent" >  Convergence is the responsibility of the user, and the algorithm has a fixed number of
iterations. The starting point of the iteration is the path function \(fbfirst\). The simulation requires the
following additional inputs, including \(backfields\), defining the backward components.
<div class="center" 
>
<!--l. 4052--><p class="noindent" >
<div class="tabular"> <table id="TBL-6" class="tabular" 
 
><colgroup id="TBL-6-1g"><col 
id="TBL-6-1"></colgroup><colgroup id="TBL-6-2g"><col 
id="TBL-6-2"></colgroup><colgroup id="TBL-6-3g"><col 
id="TBL-6-3"></colgroup><colgroup id="TBL-6-4g"><col 
id="TBL-6-4"></colgroup><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-6-1-"><td  style="white-space:nowrap; text-align:center;" id="TBL-6-1-1"  
class="td11"> Label  </td>
           <td  style="white-space:nowrap; text-align:center;" id="TBL-6-1-2"  
class="td11">    Type       </td>
                           <td  style="white-space:nowrap; text-align:center;" id="TBL-6-1-3"  
class="td11">Typical value</td>
                                         <td  style="white-space:nowrap; text-align:center;" id="TBL-6-1-4"  
class="td11">        Description            </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-6-2-"><td  style="white-space:nowrap; text-align:center;" id="TBL-6-2-1"  
class="td11"><span 
class="ec-lmri-10x-x-109">backfields</span></td>
           <td  style="white-space:nowrap; text-align:center;" id="TBL-6-2-2"  
class="td11"> integer vector </td>
                           <td  style="white-space:nowrap; text-align:center;" id="TBL-6-2-3"  
class="td11">      \(1\)      </td>
                                         <td  style="white-space:nowrap; text-align:center;" id="TBL-6-2-4"  
class="td11">Number of backward variables</td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-6-3-"><td  style="white-space:nowrap; text-align:center;" id="TBL-6-3-1"  
class="td11"> <span 
class="ec-lmri-10x-x-109">initialfb </span></td>
           <td  style="white-space:nowrap; text-align:center;" id="TBL-6-3-2"  
class="td11">function handle</td>
                           <td  style="white-space:nowrap; text-align:center;" id="TBL-6-3-3"  
class="td11">      \(@(a0,a1,w,p)\)      </td>
                                         <td  style="white-space:nowrap; text-align:center;" id="TBL-6-3-4"  
class="td11">      Initial value for \(a\)         </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-6-4-"><td  style="white-space:nowrap; text-align:center;" id="TBL-6-4-1"  
class="td11"> <span 
class="ec-lmri-10x-x-109">firstfb  </span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-6-4-2"  
class="td11">function handle</td><td  style="white-space:nowrap; text-align:center;" id="TBL-6-4-3"  
class="td11">      \(@(a0,nc,p)\)      </td><td  style="white-space:nowrap; text-align:center;" id="TBL-6-4-4"  
class="td11">  First trajectory estimate    </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-6-5-"><td  style="white-space:nowrap; text-align:center;" id="TBL-6-5-1"  
class="td11">  <span 
class="ec-lmri-10x-x-109">iterfb   </span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-6-5-2"  
class="td11">    integer      </td><td  style="white-space:nowrap; text-align:center;" id="TBL-6-5-3"  
class="td11">     2        </td><td  style="white-space:nowrap; text-align:center;" id="TBL-6-5-4"  
class="td11"> Forward-backward iterations </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-6-6-"><td  style="white-space:nowrap; text-align:center;" id="TBL-6-6-1"  
class="td11"> <span 
class="ec-lmri-10x-x-109">method </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-6-6-2"  
class="td11">function handle</td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-6-6-3"  
class="td11">      \(@xMPfb\)      </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-6-6-4"  
class="td11"> Forward-backward algorithm </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-6-7-"><td  style="white-space:nowrap; text-align:center;" id="TBL-6-7-1"  
class="td11">  <span 
class="ec-lmri-10x-x-109">deriv   </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-6-7-2"  
class="td11">function handle</td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-6-7-3"  
class="td11">      \(@(a,a_{-},w,p)\)      </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-6-7-4"  
class="td11">     Derivative function       </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-6-8-"><td  style="white-space:nowrap; text-align:center;" id="TBL-6-8-1"  
class="td11">        </td></tr></table></div><br />
</div>
<!--l. 4074--><p class="indent" >  In <span 
class="ec-lmri-10x-x-109">initialfb</span>, the \(a0\) fields from the previous iteration are at the <span 
class="ec-lmri-10x-x-109">first </span>times computed previously,
so \(\mathbf {a}0=\left [\mathbf {p}^{(n-1)}\left (0\right ),\mathbf {q}^{(n-1)}\left (T\right )\right ]\), while the \(a1\) fields are evaluated at the <span 
class="ec-lmri-10x-x-109">last </span>times computed from the previous iteration, so
\(\mathbf {a}1=\left [\mathbf {p}^{(n-1)}\left (T\right ),\mathbf {q}^{(n-1)}\left (0\right )\right ]\).
<!--l. 4079--><p class="indent" >  On the first call to <span 
class="ec-lmri-10x-x-109">initialfb, with</span> \(p.iter=1\), a startup procedure is used. In the startup procedure, <span 
class="ec-lmri-10x-x-109">a0</span>
is generated internally by <span 
class="ec-lmri-10x-x-109">initialfb. </span>However, <span 
class="ec-lmri-10x-x-109">a1 </span>is obtained in the internal calling function
<span 
class="ec-lmri-10x-x-109">xpathfb </span>using the output of <span 
class="ec-lmri-10x-x-109">firstfb, </span>which gives an initial iterative path estimate of \(a\). It returns
a default path equal to the initial boundary value \(a0\), if not defined by the user. More
generally, it should be set to a value to allow iterations to converge. The calling
arguments of <span 
class="ec-lmri-10x-x-109">firstfb </span>include the initial boundaries <span 
class="ec-lmri-10x-x-109">a0 </span>and the usual check index
(\(nc=1,2\)).
<!--l. 4089--><p class="indent" >  The <span 
class="ec-lmri-10x-x-109">initial </span>function returns \(a0\), giving the current initial values. On the first iteration <span 
class="ec-lmri-10x-x-109">initial</span>
returns an internally defined \(a0\). Subsequently it requires \(a0\), the stored first iteration boundaries as
well as <span 
class="ec-lmri-10x-x-109">a1</span>, the previous iteration end-points. The estimate for the previous path in the deriv
function is obtained from the iteration starter function <span 
class="ec-lmri-10x-x-109">firstfb </span>on the first iteration, and
subsequently from a stored value.
<!--l. 4097--><p class="indent" >  Internally, the raw fields \(\mathbf {a}=\left [\mathbf {p},\mathbf {q}\right ]\) are stored in complementary time-orders, with \(\mathbf {p}\) solved normally in
forward time, and \(\mathbf {q}\) solved in reverse temporal order.
<!--l. 4102--><p class="indent" >  When the previous iteration field is passed to \(deriv\), the time-orders of the previous iteration are
reversed so that previous iteration \(\mathbf {q}\) times are the same as \(\mathbf {p}\) times, and vice-versa. The previous
                                                                                
                                                                                
fields are therefore at the same time as those of the complementary present field<span 
class="ec-lmri-10x-x-109">.</span>
When passed to \(observe\), both \(\mathbf {p},\mathbf {q}\) are given in time-increasing order to allow synchronized
observations.
<!--l. 4110--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">7.7.1</span>  <a 
 id="x1-1290007.7.1"></a>Example:</h4>
<!--l. 4112--><p class="noindent" >This is a trivial example, to illustrate the code structure. It has two counter-propagating
stochastic processes, one decaying in the forward time direction, and one decaying in the
backward time direction.
<div class="center" 
>
<!--l. 4115--><p class="noindent" >
<div class="doublebox"><div class="minipage"><span 
class="ec-lmtt-10x-x-109">function [e] = Fbcheck()</span>
<!--l. 4119--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.ranges = 1;</span>
<!--l. 4121--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.fields = 2;</span>
<!--l. 4123--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.backfields = 1;</span>
<!--l. 4125--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.initialfb = @(</span><span 
class="ec-lmtt-10x-x-109">~,</span><span 
class="ec-lmtt-10x-x-109">~,w,p) 1+0.5*w;</span>
<!--l. 4127--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.ensembles = [400,1,1];</span>
<!--l. 4129--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.method = @MPfb;</span>
<!--l. 4131--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.deriv = @(a,</span><span 
class="ec-lmtt-10x-x-109">~,w,p) -a + w;</span>
<!--l. 4133--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">e = xspde(p);</span>
<!--l. 4135--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">end</span>                                                        </div></div>
</div>
<!--l. 4139--><p class="indent" >
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
  
<h2 class="chapterHead"><span class="titlemark">8</span>  <a 
 id="x1-1300008"></a>Integration errors</h2>
<!--l. 4145--><p class="noindent" ><span 
class="ec-lmbxi-10x-x-109">This section describes how xSPDE estimates errors from time discretization and</span>
<span 
class="ec-lmbxi-10x-x-109">statistical sampling. Other numerical errors require manual checks.</span>
<!--l. 4147--><p class="indent" >  Errors and the need for error-checking are an integral part of numerical calculations. This
is more subtle in stochastic equations, because there are both multiple sources of
errors and multiple outputs. The xSPDE philosophy is to compute the most relevant
errors for every average output, since each output average may have quiute different
errors.
  
<h3 class="sectionHead"><span class="titlemark">8.1</span>  <a 
 id="x1-1310008.1"></a>Discretization errors</h3>
<!--l. 4156--><p class="noindent" >To check convergence, xSPDE repeats the calculations at least twice for checking step-sizes,
and many times more in stochastic cases to estimate sampling errors. These checks can be
turned on and off. <span 
class="ec-lmri-10x-x-109">If you think the checks make xSPDE slow, turn them off - but you won’t get</span>
<span 
class="ec-lmri-10x-x-109">any error-estimates. </span>Whatever the application, you will find the error-estimates
useful.
<!--l. 4163--><p class="indent" >  If the errors are too large relative to the application, you should decrease the
time-steps or increase the number of samples. Which is needed depends on the type of
error.
<!--l. 4167--><p class="indent" >  Errors caused by the finite time-domain step-size are checked automatically provided that \(checks=1\)
is specified, which is the default option. If \(checks=0\) is used, there is no time-domain error
check.
<!--l. 4171--><p class="indent" >  Errors due to a finite step-size are estimated by running a check simulations with half the
initial step-size and the same random sequence, extrapolating to zero step-size if \(order&gt;0\) is specified,
then returning an error bound as the difference of the two most accurate results. Any 2D
output graphs plot error-bars if \(checks=1\) was specified, provided they are large enough to plot. RMS
output errors are also reported. Individual error bounds \(e\left (o\right )\) are given in the output data, and the
plots give \(\bar {o}\pm e\left (o\right )\).
<!--l. 4180--><p class="indent" >  Error-bars below a minimum relative size compared to the vertical range of the
plot, specified by the graphics variable \(minbar\), are not plotted. The default for this is \(minbar=0.01\). All
error bars are calculated individually for each type of data average. Minbar is a cell
array that can can be set for each type of average or graph. If the cell argument is
omitted, it applies globally. Error estimates are also given for functional transforms of
averages.
<!--l. 4188--><p class="indent" >  If the errors are too large, one can either increase the <span 
class="ec-lmri-10x-x-109">points</span>, which gives more plotted
points and lower errors, or increase the <span 
class="ec-lmri-10x-x-109">steps, </span>which reduces the step size without
changing the data resolution. The default algorithm and extrapolation order can
also be changed. Error bars on graphs can be removed by setting \(checks=0\) or increasing
\(minbar\).
<!--l. 4195--><p class="indent" >  Discretization errors caused by the finite spatial lattice are not currently checked in the
xSIM code. They must be checked by comparing results with different transverse lattice ranges
and step-size. Similarly, errors from probability binning are not checked.
                                                                                
                                                                                
<!--l. 4200--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">8.1.1</span>  <a 
 id="x1-1320008.1.1"></a>Discretization error outputs</h4>
<!--l. 4202--><p class="noindent" >In xSPDE, the discretization or step-size error due to finite time-step sizes is called the “step”
error. For checking step errors, xSPDE allows the user to specify \(checks=1\), which is the default
option. This gives one integration at the specified step-size, and one at half the
specified step-size. The data is plotted using the more accurate fine step-size results,
but with the coarse time lattice in order to calculate the estimated discretization
errors.
<!--l. 4210--><p class="indent" >  The RMS value of the step error for each computed function, normalized by the maximum
modulus of the observable, is printed out after each xSPDE simulation. If the expected
comparison value is zero, the absolute value is given.
<!--l. 4215--><p class="indent" >  Both fine and coarse time-step results employ identical underlying random noise
processes, from the same initial random seed. To compensate for the grid size, the coarse
time-step uses a sum of two successive fine noise increments. This has the advantage
that any differences are only from the effects of the time-step on the integration
accuracy.
<!--l. 4221--><p class="indent" >  If different noises were used, part of the measured error-bar would be from sampling errors.
Where there is 2D graphical output, the error bars give the step error, if you set \(p.checks=1\). The
standard error-bar, with no extrapolation, has a half-size equal to the difference of the two
most accurate results.
<!--l. 4227--><p class="indent" >  If computed, the discretization error is included in the graphical data outputs for all
observables. It is accessed by setting the last index for the output data equal 2. The raw
discretization error is generally a very cautious estimate, and may overestimate the errors.
This estimate can be improved using extrapolation, explained next.
<!--l. 4233--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">8.2</span>  <a 
 id="x1-1330008.2"></a>Higher order convergence</h3>
<!--l. 4237--><p class="noindent" >xSPDE uses extrapolation to improve convergence, which requires an input of the <span 
class="ec-lmri-10x-x-109">order</span>. If this
is non-zero, and <span 
class="ec-lmri-10x-x-109">checks </span>are set to 1 to allow successive integration with two different step-sizes,
the output of all data graphed will be extrapolated by assuming the method has the specified
order.
<!--l. 4243--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">8.2.1</span>  <a 
 id="x1-1340008.2.1"></a>Extrapolation</h4>
<!--l. 4247--><p class="noindent" >Extrapolation is valuable for improving the accuracy of a differential equation solver. It is
valid for small time-steps. Suppose an algorithm has a correct solution \(R_{0}\), but returns a
numerical result \(R\) with an error order \(n\). For small step-size, integration results \(R\left (dt\right )\) with step-size \(dt\)
                                                                                
                                                                                
have an error of order \(dt^{n}\), that is: \begin {equation}  \begin {split}R\left (dt\right )=R_{0}+e\left (R\right )=R_{0}+k.dt^{n}.\end {split}  \end {equation}
Hence, from two results at different values of \(dt,\) differing by a factor of \(2\), one would obtain
\begin {equation}  \begin {split}\begin {aligned}R_{1} &amp; =R\left (dt\right )=R_{0}+k.dt^{n}\\ R_{2} &amp; =R\left (2dt\right )=R_{0}+2^{n}k.dt^{n}. \end {aligned} \end {split}  \end {equation}
The true result, extrapolated to the small-step size limit, is obtained by giving more weight to
the fine step-size result, while <span 
class="ec-lmri-10x-x-109">subtracting </span>from this a correction due to the coarse step-size
calculation, to cancel the leading error term: \begin {equation}  \begin {split}R_{0}=\frac {\left [R_{1}-R_{2}2^{-n}\right ]}{\left [1-2^{-n}\right ]}.\end {split}  \end {equation}
Thus, if we define a factor \(\epsilon \) as \begin {equation}  \begin {split}\epsilon \left (n\right )=\frac {1}{\left [2^{n}-1\right ]}=\left (1,\frac {1}{3},\frac {1}{7}\ldots \right ),\end {split}  \end {equation}
the true results are obtained from extrapolation to zero step-size as: \begin {equation}  \begin {split}R_{0}=\left (1+\epsilon \right )R_{1}-\epsilon R_{2}.\end {split}  \end {equation}
The built-in algorithms have an order as ordinary differential equation integrators of 1, 1, 2,
2, 2, 4 respectively and will converge to this order at small step-sizes. Weak first
order convergence is always obtainable for these single noise-step SDE methods <span class="cite">[<a 
href="#Xburrage2006comment">10</a>]</span><a 
 id="x1-134001"></a>.
Second order convergence is obtained in some cases with midpoint, RK2 and RK4
algorithms.
<!--l. 4287--><p class="indent" >  Higher order convergence for the raw data is not guaranteed for the built-in SDE
algorithms. The algorithms used do <span 
class="ec-lmbx-10x-x-109">not </span>always converge to the standard ODE order when
used for stochastic equations. Hence extrapolation higher than first order should be
used with caution in stochastic calculations, unless more complex methods are used
<span class="cite">[<a 
href="#XKloeden1992">8</a>]</span><a 
 id="x1-134002"></a>.
<!--l. 4293--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">8.2.2</span>  <a 
 id="x1-1350008.2.2"></a>Extrapolated error-bars</h4>
<!--l. 4295--><p class="noindent" >If extrapolation is used, the error bar half-size is the difference of the best raw estimate and
the extrapolation. Extrapolated results are usually inside those given by the error-bars,
however, note that:
<ul class="itemize1">     
<li class="itemize">
<!--l. 4299--><p class="noindent" ><span 
class="ec-lmbx-10x-x-109">extrapolation with too high an order may under-estimate error bars</span>
</li>     
<li class="itemize">
<!--l. 4301--><p class="noindent" ><span 
class="ec-lmbx-10x-x-109">extrapolation with too low an order reduces the accuracy</span></li></ul>
<!--l. 4303--><p class="noindent" >Hence, xSPDE assumes a default order of <span 
class="ec-lmri-10x-x-109">order </span>= 1 for all SDE and SPDE cases. This gives an
extrapolated weak order of \(2\) for stochastic cases. One can set <span 
class="ec-lmri-10x-x-109">order </span>= 0 to remove the default,
or use a higher order if preferred, although, as explained above, it requires some caution. For
an ODE or PDE the default order is the usual deterministic order. For the default RK4
deterministic method, the default is <span 
class="ec-lmri-10x-x-109">order </span>= 4. All orders are improved by one with
extrapolation.
<!--l. 4312--><p class="indent" >  High-order convergence <span 
class="ec-lmri-10x-x-109">without </span>extrapolation can also be obtained, either in special cases
using the xSPDE methods, or by adding user-specified techniques. The xSPDE libraries can be
readily extended by the user to include these, through defining a modified <span 
class="ec-lmri-10x-x-109">method </span>function
appropriately.
                                                                                
                                                                                
<!--l. 4318--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">8.3</span>  <a 
 id="x1-1360008.3"></a>Statistical errors</h3>
<!--l. 4320--><p class="noindent" >Sampling error estimation in xSIM uses three different techniques.
<ul class="itemize1">     
<li class="itemize">
<!--l. 4322--><p class="noindent" >xSIM uses sub-ensemble averaging, requiring high-level ensembles.
</li>     
<li class="itemize">
<!--l. 4323--><p class="noindent" >For probability estimates, a Poissonian sampling error is used, based on counts.
</li>     
<li class="itemize">
<!--l. 4325--><p class="noindent" >If there is a comparison probability, this is used for sampling error estimates.</li></ul>
<!--l. 4328--><p class="noindent" >This procedure leads to reliable sampling error estimates, and makes efficient use of the vector
instruction sets used by Matlab. Ensembles are specified in three levels. The first,
<span 
class="ec-lmri-10x-x-109">ensembles(1)</span>, is called the number of samples for brevity. All computed quantities returned by
the <span 
class="ec-lmbxi-10x-x-109">observe </span>functions are first averaged over the samples, which are calculated
efficiently using a parallel vector of trajectories. By the central limit theorem, these
low-level sample averages are distributed as a normal distribution at large sample
number.
<!--l. 4338--><p class="indent" >  Next, the sample averages are averaged again over the two higher level ensembles, if
specified. This time, the variance is accumulated. The variance of these distributions is used to
estimate a standard deviation in the mean, since each computed quantity is now a normally
distributed result. This method is applied to all the observables. The two lines generated
represent \(\bar {o}\pm \sigma \left (o\right )\), where \(o\) is the observe function output, and \(\sigma \) is the standard deviation in the
mean.
<!--l. 4347--><p class="indent" >  Here, <span 
class="ec-lmri-10x-x-109">ensembles(2) </span>specifies ensembles computed in series. The highest level ensemble,
<span 
class="ec-lmri-10x-x-109">ensembles(3), </span>is used for parallel simulations. This is faster for a multiple core CPU or when
the codes are run in a supercomputing environment, which requires the Matlab parallel
toolbox. Either type of high-level ensemble, or both together, can be used to calculate
sampling errors.
<!--l. 4354--><p class="indent" >  If \(ensembles(2)&gt;1\) or \(ensembles(3)&gt;1\), which allows xSPDE to calculate sampling errors, it will plot upper and lower limits
of one standard deviation. If the sampling errors are too large, try increasing \(ensembles(1)\)<span 
class="ec-lmri-10x-x-109">, </span>which increases
the trajectories in a single thread. An alternative is to increase \(ensembles(2)\), which is slower, but
is only limited by the compute time, or else to increase \(ensembles(3)\), which gives higher level
parallelization.
<!--l. 4362--><p class="indent" >  Each is limited in different ways: the first by memory, the second by time, the third by the
number of cores. Sampling error control helps ensures accuracy.
                                                                                
                                                                                
<!--l. 4366--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">8.3.1</span>  <a 
 id="x1-1370008.3.1"></a>Sampling error</h4>
<!--l. 4368--><p class="noindent" >Quantitative sampling error estimation in xSPDE uses sub-ensemble averaging. Ensembles are
specified in three levels, using vector, serial and parallel methods, respectively. The vector
ensemble length, <span 
class="ec-lmri-10x-x-109">p.ensemble(1)</span>, is called the number of samples for brevity. All quantities
returned by the observe functions are averaged over the samples, which are calculated
efficiently using a vector of trajectories.
<!--l. 4375--><p class="indent" >  By the central limit theorem, the sample averages are distributed as a normal distribution
at large sample number. Next, the sample averages are averaged over the two higher level
ensembles, if specified. The variance of this data is used to estimate a standard deviation in
the mean, since each is normally distributed.
<!--l. 4381--><p class="indent" >  The highest level ensemble, \(p.ensemble(3)\), is used for parallel simulations. This requires the Matlab
parallel toolbox. Either type of high-level ensemble, or both together, can be used to calculate
sampling errors.
<!--l. 4386--><p class="indent" >  Note that one standard deviation is not a strong bound; errors are expected to exceed this
value in \(32\%\) of observed measurements. Another point to remember is that stochastic errors are
often correlated, so that a group of points may all have similar errors due to statistical
sampling.
<!--l. 4392--><p class="indent" >  The statistical error due to finite samples of trajectories is called the sampling
error. The RMS value of the relative sampling error for each computed function,
normalized by the maximum modulus of the observable, is printed out after each
xSPDE simulation. If the expected comparison value is zero, the absolute value is
given.
<!--l. 4398--><p class="indent" >  Averages over stochastic ensembles are the specialty of xSPDE, which requires
specification of the ensemble size. A hierarchy of ensemble specifications in three
levels allows maximum resource utilization, so that: \[ p.ensembles=[ensembles(1),ensembles(2),ensembles(3)]\,. \] The local ensemble, \(ensembles\left (1\right )\), gives
within-thread parallelism, allowing vector instruction use for single-core efficiency. The serial
ensemble, \(ensembles\left (2\right )\), gives the number of independent sub-ensembles of trajectories calculated
serially.
<!--l. 4410--><p class="indent" >  The parallel ensemble, \(ensembles\left (3\right )\), gives multi-core parallelism, and requires the Matlab parallel
toolbox. This improves speed when there are multiple cores. One should optimally put \(ensembles\left (3\right )\) equal
to the available number of CPU cores.
<!--l. 4415--><p class="indent" >  The <span 
class="ec-lmri-10x-x-109">total </span>number of stochastic trajectories or samples is \[ ensembles(1)\times ensembles(2)\times ensembles(3)\,. \]
<!--l. 4420--><p class="indent" >  Either \(ensembles(2)\) or \(ensembles(3)\) are required if sampling error-bars are to be calculated, owing to the
sub-ensemble averaging method used in xSPDE to calculate sampling errors accurately.
<!--l. 4424--><p class="indent" >  Two lines are graphed for an upper and lower standard deviation departure from the mean.
This is only plotted if the total number of serial or parallel ensembles is greater than one,
preferably at least 10–20 to give reliable estimates. The sampling error is reasonably
accurate, but may underestimate errors for unusual distributions. These estimates are
available for all observables in any dimension. The two lines generated in the graphs
                                                                                
                                                                                
represent \(\bar {o}\pm \sigma \), where \(o\) is the mean output, and \(\sigma \) is the computed standard deviation in the
mean.
<!--l. 4436--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">8.4</span>  <a 
 id="x1-1380008.4"></a><span 
class="ec-lmri-10x-x-109">Convergence tests</span></h3>
<!--l. 4438--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">8.4.1</span>  <a 
 id="x1-1390008.4.1"></a>Comparisons: <span 
class="ec-lmri-10x-x-109">compare</span></h4>
<!--l. 4440--><p class="noindent" >Every <span 
class="ec-lmri-10x-x-109">observe </span>function can be accompanied by a comparison function, with a function handle \(compare\{n\}\).
This generates a vector of analytic solutions or experimental data-points which is compared to
the average of the stochastic results. Results are plotted as additional lines on the
two-dimensional graphical outputs, and a summary of comparison differences is
printed.
<!--l. 4447--><p class="indent" >  <span 
class="ec-lmri-10x-x-109">A </span>cell array of functions is used to obtain comparison results. These are calculated from the
user-specified <span 
class="ec-lmbxi-10x-x-109">compare</span><span 
class="ec-lmbxi-10x-x-109">{n</span><span 
class="ec-lmbxi-10x-x-109">}(p) </span>handle where the function argument is the parameter structure
p, giving a extra dashed line on the two-dimensional graphs. Other graphics options are
available as well. These optional comparisons can be input in all dimensions. When there are
error estimates, a chi-squared test is carried out to determine if the difference is within
the expected step-size and sampling error bars. If the comparison has errors, for
example from experimental data, the chi-squared test will include the experimental
errors.
<!--l. 4458--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">8.4.2</span>  <a 
 id="x1-1400008.4.2"></a>Convergence: <span 
class="ec-lmri-10x-x-109">xcheck</span></h4>
<!--l. 4460--><p class="noindent" >The convergence checker, <span 
class="ec-lmri-10x-x-109">xcheck(checks,p), </span>is designed for use where there are analytic results
available for comparisons. This will automatically run xSIM a total of <span 
class="ec-lmri-10x-x-109">checks </span>times,
increasing the initial <span 
class="ec-lmri-10x-x-109">steps </span>by 2 after each run, to reduce the step-size by 2. It then runs
xGRAPH to display the most accurate result. It prints the time-step, the maximum
difference with an input <span 
class="ec-lmri-10x-x-109">compare </span>and the estimated errors found at the relevant
point.
<!--l. 4468--><p class="noindent" >  
<h4 class="likesubsectionHead"><a 
 id="x1-1410008.4.2"></a>Exercise</h4>
                                                                                
                                                                                
     
<ul class="itemize1">
<li class="itemize">     
<!--l. 4470--><p class="noindent" ><span 
class="ec-lmbx-10x-x-109">Simulate the Kubo oscillator using the file,</span> \(Kubocheck.m\)<span 
class="ec-lmbx-10x-x-109">, with xcheck.</span></li></ul>
<div class="center" 
>
<!--l. 4473--><p class="noindent" >
<div class="doublebox"><div class="minipage"><span 
class="ec-lmtt-10x-x-109">function [e] = Kubocheck()</span>
<!--l. 4477--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.name = ’Kubo with convergence checks’;</span>
<!--l. 4479--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.ensembles = [1000,10];</span>
<!--l. 4481--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.initial = @(w,p) 1;</span>
<!--l. 4483--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.range = 2;</span>
<!--l. 4485--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.deriv = @(a,xi,p) 1i*xi.*a;</span>
<!--l. 4487--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.observe</span><span 
class="ec-lmtt-10x-x-109">{1</span><span 
class="ec-lmtt-10x-x-109">} = @(a,p) real(a(1,:));</span>
<!--l. 4489--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.observe</span><span 
class="ec-lmtt-10x-x-109">{2</span><span 
class="ec-lmtt-10x-x-109">} = @(a,p) a(1,:).*conj(a(1,:));</span>
<!--l. 4492--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.olabels = </span><span 
class="ec-lmtt-10x-x-109">{’</span><span 
class="ec-lmtt-10x-x-109">&#x003C;a</span><span 
class="ec-lmtt-10x-x-109">&#x003E; ’,’</span><span 
class="ec-lmtt-10x-x-109">&#x003C; a</span><span 
class="ec-lmtt-10x-x-109">^2</span><span 
class="ec-lmtt-10x-x-109">&#x003E; ’</span><span 
class="ec-lmtt-10x-x-109">};</span>
<!--l. 4494--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.xlabels = </span><span 
class="ec-lmtt-10x-x-109">{’</span><span 
class="ec-lmtt-10x-x-109">\tau’</span><span 
class="ec-lmtt-10x-x-109">};</span>
<!--l. 4496--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.compare</span><span 
class="ec-lmtt-10x-x-109">{1</span><span 
class="ec-lmtt-10x-x-109">} = @(p) exp(-p.t/2);</span>
<!--l. 4498--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.compare</span><span 
class="ec-lmtt-10x-x-109">{2</span><span 
class="ec-lmtt-10x-x-109">} = @(p) 1;</span>
<!--l. 4500--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">e = xcheck(2,p);</span>
<!--l. 4502--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">end</span>                                                        </div></div>
</div>
<!--l. 4506--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">8.5</span>  <a 
 id="x1-1420008.5"></a>Chi-squared estimates</h3>
<!--l. 4508--><p class="noindent" >Chi-squared error estimates are reported in cases that have statistical sampling errors and
comparison functions. These allow estimates of goodness of fit for probabilities. For \(N_{p}\)
independent points graphed or measured, if \(O_{i}\) is an observable with measured mean \(\bar {O}_{i}\) and
statistical fluctuations \(\Delta O_{i},\) one has that: \begin {equation}  \chi ^{2}/N_{p}=\frac {1}{N_{p}}\sum _{i}\frac {\left \langle \left [\left (\bar {O}_{i}+\Delta O_{i}\right )-O_{i}^{a}\right ]^{2}\right \rangle }{\sigma _{i}^{2}}  \end {equation}
<!--l. 4518--><p class="indent" >  Here \(\sigma _{i}^{2}\) is an estimated variance. Provided that \(\left \langle \Delta O_{i}^{2}\right \rangle =\sigma _{i}^{2}\) and \(\bar {O}_{i}=O_{i}^{a}\), one should obtain the expected result of
\(\chi ^{2}/N_{p}\approx 1\). The exact distribution is known in special cases, but this requires that all data is
independent and has a Gaussian distribution, which is not the case for stochastic
trajectories.
<!--l. 4524--><p class="indent" >  Because of the variety of error-sources, and the lack of independence from point to point,
these error sums are not identical to Pearson’s original definition of \(\chi ^{2}\), and therefore should be
used with caution. Nevertheless, the definition provides a way of evaluating goodness of fit
that is useful.
<!--l. 4530--><p class="indent" >  Here, the value of \(\sigma _{i}^{2}\) is obtained by including <span 
class="ec-lmri-10x-x-109">all </span>known error sources, so \begin {equation}  \sigma _{i}^{2}=\sum _{n=1}^{4}\left (\sigma _{i}^{(n)}\right )^{2}.  \end {equation}
These are:
                                                                                
                                                                                
     
<ol  class="enumerate1" >
<li 
  class="enumerate" id="x1-142002x1">     
<!--l. 4537--><p class="noindent" >If sub-ensemble measures are used, the estimated \(\sigma _{i}^{2}\) includes sampling errors.
</li>
<li 
  class="enumerate" id="x1-142004x2">     
<!--l. 4539--><p class="noindent" >If checks are included, the estimated \(\sigma _{i}^{2}\) includes discretization errors.
</li>
<li 
  class="enumerate" id="x1-142006x3">     
<!--l. 4541--><p class="noindent" >If comparisons have systematic errors, e.g. from experimental data,
</li>
<li 
  class="enumerate" id="x1-142008x4">     
<!--l. 4542--><p class="noindent" >If comparisons have known statistical errors.</li></ol>
<!--l. 4544--><p class="noindent" >In the case of sampled probabilities where there is a comparison probability, the estimated
statistical variance in the data is obtained following Pearson’s original method. That is, from
<span 
class="ec-lmri-10x-x-109">estimated counts given the comparison probability</span>, rather than a computed variance. This
allows the use of standard \(\chi ^{2}\) comparisons.
<!--l. 4550--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">8.5.1</span>  <a 
 id="x1-1430008.5.1"></a>Probability comparisons</h4>
<!--l. 4552--><p class="noindent" >Comparisons of trajectory probabilities and analytic probabilities do not always result in
perfect agreement. This is because the limitations of memory and simulation time mean that
trajectories have to be binned, which leads to an additional discretization error. Note that
xSPDE approximates the comparison analytic probability of a bin by the central bin value of
the probability, which is the simplest procedure.
<!--l. 4559--><p class="indent" >  To explain this, comparisons of probabilities ought to use the average probability density
over the bin, which is different from the central value. Suppose one has a comparison
distribution \(p^{a}\left (x\right )\). Using Simpson’s rule, the average analytic probability density integrated over a
bin size \(\Delta x\) is approximately: \begin {align}  p_{o}^{a} &amp; =\frac {1}{\Delta x}\int _{x_{0}-\Delta x/2}^{x_{0}+\Delta x/2}p^{a}(x)dx\\ &amp; \approx \frac {1}{6}\left [4p^{a}(x_{0})+p^{a}\left (x_{0}+\frac {\Delta x}{2}\right )+p^{a}\left (x_{0}-\frac {\Delta x}{2}\right ).\right ]\nonumber  \end {align}
<!--l. 4569--><p class="indent" >  This is equivalent to a cubic polynomial fit. It can be used to improve the analytic binning
comparisons. It is especially important for multi-dimensional comparisons. It results in \(9\)
distinct terms for two dimensions. This correction must be inserted manually in the
comparison functions.
                                                                                
                                                                                
<!--l. 4575--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">8.5.2</span>  <a 
 id="x1-1440008.5.2"></a>Scaling of \(\chi ^{2}\) errors</h4>
<!--l. 4577--><p class="noindent" >Because chi-squared probability tests are sensitive, it helps to understand how they
scale with bin-size. With \(N_{s}\) total samples, the estimated probability \(P_{i}\) in a bin with
probability density \(p\left (\mathbf {a}\right )\) and sampled counts of \(N_{i}\) is given by \(P_{i}=N_{i}/N_{s}=p_{i}A\) for a bin \(b_{i}\) with area \(A\), where:
\begin {equation}  p_{i}=\frac {1}{A}\int _{b_{i}}p\left (\mathbf {a}\right )dA  \end {equation}
The Poissonian variance of the counts in the bin is \(\left \langle \Delta N_{i}\right \rangle =\left \langle N_{i}\right \rangle \). The expected probability variance is
therefore \begin {equation}  \left \langle \Delta P^{2}\right \rangle =\left \langle \Delta N_{i}^{2}/N_{s}^{2}\right \rangle =\left \langle N_{i}\right \rangle /N_{s}^{2}.  \end {equation}
<!--l. 4591--><p class="indent" >  Let \(\left \langle N_{i}\right \rangle =N_{i}^{a}\), the analytic or expected count number. The expected probability density variance at a
point is therefore \begin {equation}  \left \langle \Delta p_{i}^{2}\right \rangle =\left \langle \Delta N_{i}^{2}/A^{2}N_{s}^{2}\right \rangle =N_{i}^{a}/A^{2}N_{s}^{2}=p_{i}^{a}/AN_{s}.  \end {equation}
Here \(p_{i}^{a}\) is the analytic or comparison probability density, and \(\left \langle \Delta p_{i}^{2}\right \rangle ^{a}=p_{i}^{a}/AN_{s}\) is the expected analytic variance.
The \(\chi ^{2}\) variable, that follows the Pearson \(\chi ^{2}\) distribution, is defined as follows:
<!--l. 4604--><p class="indent" >  \begin {equation}  \chi ^{2}/N_{p}=\frac {1}{N_{p}}\sum _{i}\frac {\left \langle \left [p_{i}-p_{i}^{a}\right ]^{2}\right \rangle }{\left \langle \Delta p_{i}^{2}\right \rangle }  \end {equation}
<!--l. 4606--><p class="indent" >  Here, \(p_{i}^{a}\) is obtained by integrating over the \(i\)-th probability bin. It can be estimated by using
the central value, \(p_{i}^{a}\approx p\left (\mathbf {a}_{i}\right )\), although cubic interpolation is more precise.
<!--l. 4610--><p class="indent" >  This could lead to a fixed error in the analytic probability density \(p_{i}^{a}\), so \(p_{i}^{a}\rightarrow p_{i}^{a}+\epsilon _{i}\), possibly localized to
some fraction of bins \(f\) which may change with the bin size. Suppose, for simplicity, that \(\epsilon \) is
due to an integration error in integrating the exact distribution or any other error
in the ’exact’ distribution, and it does not change with changes to the bin area
\(A\).
<!--l. 4618--><p class="indent" >  From the definition of \(\chi ^{2}\), if the generated samples have negligible step-size errors:
<!--l. 4623--><p class="indent" >  \begin {equation}  \chi ^{2}/N_{p}=\frac {1}{N_{p}}\sum _{i}\frac {\left \langle \left [\left (p_{i}^{a}+\Delta p_{i}\right )-p_{i}^{a}-\epsilon _{i}\right ]^{2}\right \rangle }{\left \langle \Delta p_{i}^{2}\right \rangle }  \end {equation}
For simplicity, if we consider the large sample limit with uniform probabilities, \begin {align}  \chi ^{2}/N_{p} &amp; =1+\frac {f\epsilon ^{2}}{\left \langle \Delta p^{2}\right \rangle }=1+\frac {f\epsilon ^{2}AN_{s}}{p^{a}}  \end {align}
<!--l. 4630--><p class="indent" >  Increasing the bin area \(A\) will increase \(\chi ^{2}/N_{p}\) above its usual value of <span 
class="ec-lmri-10x-x-109">1 </span>by an amount proportional
to \(A\). This is simply because smaller bins have less intrinsic accuracy, due to a larger sampling
error. As a result, it is often preferable to use more accurate probability estimates with
larger bins having more counts, since these are much more sensitive to effects like
this.
<!--l. 4637--><p class="indent" >  Often, simulated and comparison graphs may appear identical visually, but even if they have
small errors they may still be very significant. Such comparison binning errors can be reduced
by using cubic spline interpolations, as explained above.
<!--l. 4642--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">8.6</span>  <a 
 id="x1-1450008.6"></a>Error outputs</h3>
<!--l. 4644--><p class="noindent" >There are six types of data outputs: data, errors, comparisons and the comparison errors.
Summaries will appear in the printed outputs if available. Step errors and sampling errors, as
                                                                                
                                                                                
well as comparison data are stored in all the output data arrays. These are also available
graphically in two-dimensional graphs.
<!--l. 4650--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">8.6.1</span>  <a 
 id="x1-1460008.6.1"></a>Numerical error outputs</h4>
<!--l. 4652--><p class="noindent" >The last data index \(c\) is used to obtain errors and comparisons in data outputs. To obtain
comparison data, a comparison function is defined for each output function. This can include,
for example, experimental data, experimental errors or exact analytic comparisons where they
are available.
<ol  class="enumerate1" >
<li 
  class="enumerate" id="x1-146002x1">     
<!--l. 4658--><p class="noindent" >Means are in \(c=1\) data, except if <span 
class="ec-lmri-10x-x-109">scatters</span><span 
class="ec-lmri-10x-x-109">&#x003E;1, </span>which gives individual trajectories.
</li>
<li 
  class="enumerate" id="x1-146004x2">     
<!--l. 4660--><p class="noindent" >If <span 
class="ec-lmri-10x-x-109">checks</span><span 
class="ec-lmri-10x-x-109">&#x003E;0</span>, the step errors are in \(c=2\) data.
</li>
<li 
  class="enumerate" id="x1-146006x3">     
<!--l. 4661--><p class="noindent" >If \(ensembles(2,3)&gt;1,\) the sampling errors are in \(c=3\) data.
</li>
<li 
  class="enumerate" id="x1-146008x4">     
<!--l. 4662--><p class="noindent" >Comparison values from <span 
class="ec-lmri-10x-x-109">compare </span>functions are in \(c=4\) data.
</li>
<li 
  class="enumerate" id="x1-146010x5">     
<!--l. 4663--><p class="noindent" >Comparison systematic errors can be included in \(c=5\) data.
</li>
<li 
  class="enumerate" id="x1-146012x6">     
<!--l. 4664--><p class="noindent" >Comparison statistical errors can be included in \(c=6\) data.</li></ol>
                                                                                
                                                                                
<!--l. 4667--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">8.6.2</span>  <a 
 id="x1-1470008.6.2"></a>Graphical error outputs</h4>
<!--l. 4669--><p class="noindent" >These are explained in detail in the xGRAPH reference section <a 
href="#x1-22200010">10<!--tex4ht:ref: sec:xGRAPH-reference --></a>.
<ol  class="enumerate1" >
<li 
  class="enumerate" id="x1-147002x1">     
<!--l. 4671--><p class="noindent" >Mean values or trajectories are graphed as separate data lines.
</li>
<li 
  class="enumerate" id="x1-147004x2">     
<!--l. 4672--><p class="noindent" >Step errors generate graph error bars
</li>
<li 
  class="enumerate" id="x1-147006x3">     
<!--l. 4673--><p class="noindent" >Sampling errors are graphed as parallel solid lines
</li>
<li 
  class="enumerate" id="x1-147008x4">     
<!--l. 4674--><p class="noindent" >Dashed lines indicate comparison values from <span 
class="ec-lmri-10x-x-109">compare </span>functions.
</li>
<li 
  class="enumerate" id="x1-147010x5">     
<!--l. 4675--><p class="noindent" >Comparison systematic errors give additional error bars
</li>
<li 
  class="enumerate" id="x1-147012x6">     
<!--l. 4676--><p class="noindent" >Comparison statistical errors can be included as parallel lines</li></ol>
<!--l. 4678--><p class="noindent" >Because multiple errors can generate very complex graphs, there is additional control of error bar
generation, explained in the xGRAPH reference section. One can also obtain difference graphs
with comparisons, which allow errors to be examined more closely, and error bars can be
combined in different ways.
<!--l. 4684--><p class="indent" >  Graphics data is only available for two-dimensional graphs, and is subject to selection using
the <span 
class="ec-lmri-10x-x-109">axes </span>inputs.
                                                                                
                                                                                
<!--l. 4687--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">8.6.3</span>  <a 
 id="x1-1480008.6.3"></a>Printed error outputs</h4>
<!--l. 4689--><p class="noindent" >Printed error summaries are generated in each xSIM run, in addition to the data outputs.
These are normalized, root mean square (RMS) errors. Normalization is carried out using the
modulus of the largest data value. If the comparison results are all zero for a function, there is
no normalization carried out.
<!--l. 4695--><p class="indent" >  After computing RMS values over each graph function, a second RMS average is taken over
all totals, weighting each total equally, and including all functions and sequence datasets
where there are nonzero errors reported. Data with no errors are not included in the totals for
each category.
<!--l. 4701--><p class="indent" >  There is a final RMS average taken over the step, sampling and comparison totals. This
again ignores categories with no errors. The purpose is to allow a rapid comparison to ensure
that there are no higher than expected errors, which might require a new simulation with more
steps or increased trajectories.
<!--l. 4707--><p class="indent" >  Printed errors are summarized in three main categories
<ol  class="enumerate1" >
<li 
  class="enumerate" id="x1-148002x1">     
<!--l. 4709--><p class="noindent" >Discretization or step errors
</li>
<li 
  class="enumerate" id="x1-148004x2">     
<!--l. 4710--><p class="noindent" >Sampling errors
</li>
<li 
  class="enumerate" id="x1-148006x3">     
<!--l. 4711--><p class="noindent" >Comparison errors</li></ol>
<!--l. 4713--><p class="noindent" >Comparison data may not be available over an entire lattice. If this is the case, the <span 
class="ec-lmri-10x-x-109">axes </span>point
selections can be used to restrict the relevant datas points used for these comparisons. This
also applies to the goodness of fit and error-vector outputs, since they make use of comparison
data where it is available.
<!--l. 4719--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">8.6.4</span>  <a 
 id="x1-1490008.6.4"></a>Goodness of fit (\(\chi ^{2}\)) </h4>
<!--l. 4721--><p class="noindent" >The \(\chi ^{2}\) statistics are obtained by normalizing the comparison squared differences by the sum of
squares of all the data and comparison errors at that point. These are summed over every data
point with relevant data, and the number of relevant data points, \(k\), is stored. The ratio of \(\chi ^{2}/k\)
should be order 1 for statistical errors.
                                                                                
                                                                                
<!--l. 4727--><p class="indent" >  These are summarized for each functional data output type, as well as giving rise to an error
total.
<!--l. 4730--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">8.6.5</span>  <a 
 id="x1-1500008.6.5"></a>Error vector output</h4>
<!--l. 4732--><p class="noindent" >When used as a function call in batch mode, the first type of data returned by xSIM is a
six-component error vector. This can be used for summarizing error data in a batch job, to
determine if a specified error-threshold is reached, to allow an iterative increase in the number
of time-steps or trajectories.
<!--l. 4738--><p class="indent" >  The error-vector components are:
<ol  class="enumerate1" >
<li 
  class="enumerate" id="x1-150002x1">     
<!--l. 4740--><p class="noindent" >Total error overall, including step, discretization and comparisons
</li>
<li 
  class="enumerate" id="x1-150004x2">     
<!--l. 4741--><p class="noindent" >Total step-size error
</li>
<li 
  class="enumerate" id="x1-150006x3">     
<!--l. 4742--><p class="noindent" >Total sampling error
</li>
<li 
  class="enumerate" id="x1-150008x4">     
<!--l. 4743--><p class="noindent" >Total comparison error
</li>
<li 
  class="enumerate" id="x1-150010x5">     
<!--l. 4744--><p class="noindent" >Total \(\chi ^{2}/k\) goodness of fit
</li>
<li 
  class="enumerate" id="x1-150012x6">     
<!--l. 4745--><p class="noindent" >Simulation elapsed time</li></ol>
                                                                                
                                                                                
<!--l. 4748--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">8.6.6</span>  <a 
 id="x1-1510008.6.6"></a>Error summaries</h4>
<!--l. 4750--><p class="noindent" >There are six types of data outputs: data, errors, comparisons and comparison errors.
Summaries will appear in the printed outputs, depending on the verbosity setting. Step errors
and sampling errors, as well as comparison data are stored in output data arrays. These are
also available graphically in two-dimensional graphs.
<!--l. 4756--><p class="indent" >
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
  
<h2 class="chapterHead"><span class="titlemark">9</span>  <a 
 id="x1-1520009"></a>xSIM reference </h2>
<!--l. 4761--><p class="noindent" ><span 
class="ec-lmbxi-10x-x-109">This section gives a reference guide to the xSIM parameters and functions.</span>
  
<h3 class="sectionHead"><span class="titlemark">9.1</span>  <a 
 id="x1-1530009.1"></a>Overview</h3>
<!--l. 4765--><p class="noindent" >Simulations carried out by xSIM are performed by other specialized internal functions. Input
parameters come from an <span 
class="ec-lmbx-10x-x-109">input </span>cell array of structures, while output is saved in a <span 
class="ec-lmbx-10x-x-109">data </span>array,
and optionally in a file. During the simulation, global averages and error-bars are
calculated for time-step and sampling errors. When completed, timing and errors are
printed.
<!--l. 4772--><p class="indent" >  The <span 
class="ec-lmri-10x-x-109">xsim </span>function call syntax is: <span 
class="ec-lmri-10x-x-109">[error,data,output(,rawdata)] = xsim(input);</span>
<!--l. 4775--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.1.1</span>  <a 
 id="x1-1540009.1.1"></a>Input and data structures</h4>
<!--l. 4777--><p class="noindent" >To explain xSPDE in full detail,
<ul class="itemize1">     
<li class="itemize">
<!--l. 4779--><p class="noindent" >Simulation parameters are stored in the <span 
class="ec-lmbxi-10x-x-109">input </span>cell array.
</li>     
<li class="itemize">
<!--l. 4781--><p class="noindent" >This describes a sequence of parameter structures, so that <span 
class="ec-lmbxi-10x-x-109">input=</span><span 
class="ec-lmbxi-10x-x-109">{p1,p2,...</span><span 
class="ec-lmbxi-10x-x-109">}</span>.
</li>     
<li class="itemize">
<!--l. 4782--><p class="noindent" >Each structure <span 
class="ec-lmbxi-10x-x-109">p1,p2,..</span><span 
class="ec-lmbx-10x-x-109">. </span>generates an output which is the input of the next.
</li>     
<li class="itemize">
<!--l. 4784--><p class="noindent" >The main simulation function is called using <span 
class="ec-lmbxi-10x-x-109">xsim(input).</span>
</li>     
<li class="itemize">
<!--l. 4785--><p class="noindent" >The RMS errors and integration time are returned in the <span 
class="ec-lmbxi-10x-x-109">error </span>vector
</li>     
<li class="itemize">
<!--l. 4787--><p class="noindent" >Parameters including defaults are returned in the <span 
class="ec-lmbxi-10x-x-109">output </span>cell array.
</li>     
<li class="itemize">
<!--l. 4789--><p class="noindent" >Averages are recorded sequentially in the <span 
class="ec-lmbxi-10x-x-109">data </span>cell array.
                                                                                
                                                                                
     
</li>
<li class="itemize">     
<!--l. 4791--><p class="noindent" >Raw trajectory data is optionally stored in the <span 
class="ec-lmbxi-10x-x-109">rawdata </span>cell array.</li></ul>
<!--l. 4794--><p class="noindent" >The sequence <span 
class="ec-lmri-10x-x-109">input </span>defines a sequence of individual simulations, with parameters that specify
the simulation functions and give the equations and observables. If there is only one
simulation, just one data structure is needed, without a cell array. In addition, xSPDE can
generates graphs with its own graphics program, xGRAPH.
<!--l. 4800--><p class="indent" >  For convergence checking, a useful alternative to xspde which repeats the calculation <span 
class="ec-lmri-10x-x-109">checks</span>
times while halving the time-step each time, and reports the resulting errors for averaged
observables, is:
<ul class="itemize1">     
<li class="itemize">
<!--l. 4804--><p class="noindent" >xcheck (checks,p)</li></ul>
<!--l. 4807--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.1.2</span>  <a 
 id="x1-1550009.1.2"></a>Parameters and functions</h4>
<!--l. 4809--><p class="noindent" >The xSIM input objects include parameters and functions, with an extensible object-oriented
architecture. All xSIM functions are modular and replaceable. In many cases this is as easy as
just defining a new function handle to replace the default value.
<!--l. 4814--><p class="indent" >  There are two types of functions:
<ul class="itemize1">     
<li class="itemize">
<!--l. 4816--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">User  </span>functions define the simulation, and have default values. The defaults are
usually obtained by adding ’x’ in front of the name. In the special case of <span 
class="ec-lmri-10x-x-109">method</span>,
the default depends on the problem.
</li>     
<li class="itemize">
<!--l. 4819--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">Helper </span>functions usually start with <span 
class="ec-lmri-10x-x-109">’x’</span>. In some cases these are defaults for user
functions. In all cases they have well-defined roles, like the reserved functions in
C, Python, Matlab or Julia.
</li>     
<li class="itemize">
<!--l. 4822--><p class="noindent" >All arguments in square brackets are optional, but may be needed only in specific
cases.
                                                                                
                                                                                
     
</li>
<li class="itemize">     
<!--l. 4824--><p class="noindent" >The last argument, <span 
class="ec-lmri-10x-x-109">p, </span>is the parameter structure.</li></ul>
<!--l. 4826--><p class="noindent" >For example, to define your own integration function, include in the xSPDE/xSIM input the
line:
<div class="center" 
>
<!--l. 4828--><p class="noindent" >
<div class="doublebox"><div class="minipage"><span 
class="ec-lmtt-10x-x-109">p.method = @Mystep;</span>                                       </div></div>
</div>
<div class="center" 
>
<!--l. 4834--><p class="noindent" >
<!--l. 4835--><p class="noindent" >Next, include anywhere on your Matlab path the function definition, for example:
</div>
<div class="center" 
>
<!--l. 4839--><p class="noindent" >
<div class="doublebox"><div class="minipage"><span 
class="ec-lmtt-10x-x-109">function a = Mystep(a,w,p)</span>
<!--l. 4843--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">% a = Mystep(a,w,p) propagates a step my way.</span>
<!--l. 4845--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">..</span>
<!--l. 4847--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">a = ...;</span>
<!--l. 4849--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">end</span>                                                        </div></div>
</div>
<!--l. 4853--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">9.2</span>  <a 
 id="x1-1560009.2"></a>Parameter table</h3>
<!--l. 4855--><p class="noindent" >Simulation parameters are stored in a parameter structure which is passed to the \(xsim\) program.
Constants can be included, but must not be reserved names. Names starting with a capital
letter like ’A...’ - except the reserved ’<span 
class="ec-lmri-10x-x-109">D</span>’ for derivatives - are always available. Globals are
incompatible with the Matlab parallel toolbox. Graphics data is stored for the graphics
program to use.
<!--l. 4862--><p class="indent" >  Standard inputs have default values, which are user-modifiable through the <span 
class="ec-lmri-10x-x-109">xpreferences</span>
function. Defaults can be checked by including the input \(verbose=2\)<span 
class="ec-lmri-10x-x-109">. </span>All the inputs are part of a
structure passed to xSPDE. If a cell array of multiple structures are input, these are executed
in sequence, with the output of the first simulation passed to the second, then the third, and
so on.
                                                                                
                                                                                
<!--l. 4869--><p class="indent" >  Library functions inputs do not have defaults, as these are subject to change.
<div class="tabular"> <table id="TBL-7" class="tabular" 
 
><colgroup id="TBL-7-1g"><col 
id="TBL-7-1"></colgroup><colgroup id="TBL-7-2g"><col 
id="TBL-7-2"></colgroup><colgroup id="TBL-7-3g"><col 
id="TBL-7-3"></colgroup><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-1-"><td  style="white-space:nowrap; text-align:center;" id="TBL-7-1-1"  
class="td11">   Label     </td>
               <td  style="white-space:nowrap; text-align:center;" id="TBL-7-1-2"  
class="td11">Default value</td>
                             <td  style="white-space:nowrap; text-align:center;" id="TBL-7-1-3"  
class="td11">                   Description                             </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-2-"><td  style="white-space:nowrap; text-align:center;" id="TBL-7-2-1"  
class="td11">   <span 
class="ec-lmri-10x-x-109">version    </span></td>
               <td  style="white-space:nowrap; text-align:center;" id="TBL-7-2-2"  
class="td11"> <span 
class="ec-lmri-10x-x-109">’xSIM3.xx’  </span></td>
                             <td  style="white-space:nowrap; text-align:center;" id="TBL-7-2-3"  
class="td11">             Current version number                     </td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-3-"><td  style="white-space:nowrap; text-align:center;" id="TBL-7-3-1"  
class="td11"> <span 
class="ec-lmri-10x-x-109">name </span></td>
               <td  style="white-space:nowrap; text-align:center;" id="TBL-7-3-2"  
class="td11">     <span 
class="ec-lmri-10x-x-109">”        </span></td>
                             <td  style="white-space:nowrap; text-align:center;" id="TBL-7-3-3"  
class="td11">                Simulation name                          </td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-4-"><td  style="white-space:nowrap; text-align:center;" id="TBL-7-4-1"  
class="td11"> <span 
class="ec-lmri-10x-x-109">dimensions </span></td>
               <td  style="white-space:nowrap; text-align:center;" id="TBL-7-4-2"  
class="td11">      \(1\)      </td>
                             <td  style="white-space:nowrap; text-align:center;" id="TBL-7-4-3"  
class="td11">              Space-time dimensions                      </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-5-"><td  style="white-space:nowrap; text-align:center;" id="TBL-7-5-1"  
class="td11">    <span 
class="ec-lmri-10x-x-109">fields      </span></td>
               <td  style="white-space:nowrap; text-align:center;" id="TBL-7-5-2"  
class="td11">      \(1\)      </td>
                             <td  style="white-space:nowrap; text-align:center;" id="TBL-7-5-3"  
class="td11">          Total number of stochastic fields               </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-6-"><td  style="white-space:nowrap; text-align:center;" id="TBL-7-6-1"  
class="td11">  <span 
class="ec-lmri-10x-x-109">backfields   </span></td>
               <td  style="white-space:nowrap; text-align:center;" id="TBL-7-6-2"  
class="td11">      \(0\)      </td>
                             <td  style="white-space:nowrap; text-align:center;" id="TBL-7-6-3"  
class="td11">            Number of backward fields                   </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-7-"><td  style="white-space:nowrap; text-align:center;" id="TBL-7-7-1"  
class="td11">  <span 
class="ec-lmri-10x-x-109">auxfields    </span></td>
               <td  style="white-space:nowrap; text-align:center;" id="TBL-7-7-2"  
class="td11">      \(0\)      </td>
                             <td  style="white-space:nowrap; text-align:center;" id="TBL-7-7-3"  
class="td11">            Number of auxiliary fields                    </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-8-"><td  style="white-space:nowrap; text-align:center;" id="TBL-7-8-1"  
class="td11">   <span 
class="ec-lmri-10x-x-109">ranges     </span></td>
               <td  style="white-space:nowrap; text-align:center;" id="TBL-7-8-2"  
class="td11">      \([10,..]\)      </td>
                             <td  style="white-space:nowrap; text-align:center;" id="TBL-7-8-3"  
class="td11">         Range of coordinates in <span 
class="ec-lmri-10x-x-109">[t,x,y,z,..]              </span></td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-9-"><td  style="white-space:nowrap; text-align:center;" id="TBL-7-9-1"  
class="td11">   <span 
class="ec-lmri-10x-x-109">origins     </span></td>
               <td  style="white-space:nowrap; text-align:center;" id="TBL-7-9-2"  
class="td11">    [0,..]      </td>
                             <td  style="white-space:nowrap; text-align:center;" id="TBL-7-9-3"  
class="td11">         Origin of coordinates in <span 
class="ec-lmri-10x-x-109">[t,x,y,z,..]             </span></td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-10-"><td  style="white-space:nowrap; text-align:center;" id="TBL-7-10-1"  
class="td11">   <span 
class="ec-lmri-10x-x-109">points     </span></td>
               <td  style="white-space:nowrap; text-align:center;" id="TBL-7-10-2"  
class="td11">   [51,...     </td>
                             <td  style="white-space:nowrap; text-align:center;" id="TBL-7-10-3"  
class="td11">         Output lattice points in <span 
class="ec-lmri-10x-x-109">[t,x,y,z,..]             </span></td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-11-"><td  style="white-space:nowrap; text-align:center;" id="TBL-7-11-1"  
class="td11">   <span 
class="ec-lmri-10x-x-109">noises     </span></td>
               <td  style="white-space:nowrap; text-align:center;" id="TBL-7-11-2"  
class="td11">   <span 
class="ec-lmri-10x-x-109">[1, 0]     </span></td>
                             <td  style="white-space:nowrap; text-align:center;" id="TBL-7-11-3"  
class="td11">           Number of noise fields in <span 
class="ec-lmri-10x-x-109">[x,k]                </span></td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-12-"><td  style="white-space:nowrap; text-align:center;" id="TBL-7-12-1"  
class="td11">  <span 
class="ec-lmri-10x-x-109">inrandoms  </span></td>
               <td  style="white-space:nowrap; text-align:center;" id="TBL-7-12-2"  
class="td11">   <span 
class="ec-lmri-10x-x-109">[1, 0]     </span></td>
                             <td  style="white-space:nowrap; text-align:center;" id="TBL-7-12-3"  
class="td11">            Initial random fields in <span 
class="ec-lmri-10x-x-109">[x,k]                 </span></td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-13-"><td  style="white-space:nowrap; text-align:center;" id="TBL-7-13-1"  
class="td11">  <span 
class="ec-lmri-10x-x-109">ensembles   </span></td>
               <td  style="white-space:nowrap; text-align:center;" id="TBL-7-13-2"  
class="td11">  <span 
class="ec-lmri-10x-x-109">[1, 1, 1]   </span></td>
                             <td  style="white-space:nowrap; text-align:center;" id="TBL-7-13-3"  
class="td11">      Size of <span 
class="ec-lmri-10x-x-109">[vector, serial, parallel] </span>ensembles          </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-14-"><td  style="white-space:nowrap; text-align:center;" id="TBL-7-14-1"  
class="td11">    <span 
class="ec-lmri-10x-x-109">steps      </span></td>
               <td  style="white-space:nowrap; text-align:center;" id="TBL-7-14-2"  
class="td11">     <span 
class="ec-lmri-10x-x-109">1        </span></td>
                             <td  style="white-space:nowrap; text-align:center;" id="TBL-7-14-3"  
class="td11">         Integration steps per output point              </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-15-"><td  style="white-space:nowrap; text-align:center;" id="TBL-7-15-1"  
class="td11">  <span 
class="ec-lmri-10x-x-109">iterations   </span></td>
               <td  style="white-space:nowrap; text-align:center;" id="TBL-7-15-2"  
class="td11">     <span 
class="ec-lmri-10x-x-109">4        </span></td>
                             <td  style="white-space:nowrap; text-align:center;" id="TBL-7-15-3"  
class="td11">      Maximum implicit or midpoint iterations          </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-16-"><td  style="white-space:nowrap; text-align:center;" id="TBL-7-16-1"  
class="td11">    <span 
class="ec-lmri-10x-x-109">order      </span></td>
               <td  style="white-space:nowrap; text-align:center;" id="TBL-7-16-2"  
class="td11">     <span 
class="ec-lmri-10x-x-109">1        </span></td>
                             <td  style="white-space:nowrap; text-align:center;" id="TBL-7-16-3"  
class="td11">           Extrapolation order: <span 
class="ec-lmri-10x-x-109">0,1,2,..                 </span></td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-17-"><td  style="white-space:nowrap; text-align:center;" id="TBL-7-17-1"  
class="td11">   <span 
class="ec-lmri-10x-x-109">checks     </span></td>
               <td  style="white-space:nowrap; text-align:center;" id="TBL-7-17-2"  
class="td11">     <span 
class="ec-lmri-10x-x-109">1        </span></td>
                             <td  style="white-space:nowrap; text-align:center;" id="TBL-7-17-3"  
class="td11">           Check time-step errors: 0 or 1                 </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-18-"><td  style="white-space:nowrap; text-align:center;" id="TBL-7-18-1"  
class="td11">    <span 
class="ec-lmri-10x-x-109">seed      </span></td>
               <td  style="white-space:nowrap; text-align:center;" id="TBL-7-18-2"  
class="td11">     <span 
class="ec-lmri-10x-x-109">0        </span></td>
                             <td  style="white-space:nowrap; text-align:center;" id="TBL-7-18-3"  
class="td11">         Seed for random number generator              </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-19-"><td  style="white-space:nowrap; text-align:center;" id="TBL-7-19-1"  
class="td11">     <span 
class="ec-lmri-10x-x-109">file       </span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-7-19-2"  
class="td11">     <span 
class="ec-lmri-10x-x-109">”        </span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-7-19-3"  
class="td11">     File-name: <span 
class="ec-lmri-10x-x-109">’f.mat’ </span>= Matlab<span 
class="ec-lmri-10x-x-109">, ’f.h5’ </span>= HDF5       </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-20-"><td  style="white-space:nowrap; text-align:center;" id="TBL-7-20-1"  
class="td11"><span 
class="ec-lmri-10x-x-109">boundaries</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}</span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-7-20-2"  
class="td11">      \([0,0;0,0]\)      </td><td  style="white-space:nowrap; text-align:center;" id="TBL-7-20-3"  
class="td11">Boundary: ’-1,0,1’=Neum, periodic, Dirichlet boundary.</td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-21-"><td  style="white-space:nowrap; text-align:center;" id="TBL-7-21-1"  
class="td11"> <span 
class="ec-lmri-10x-x-109">binranges</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">} </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-7-21-2"  
class="td11">  <span 
class="ec-lmri-10x-x-109">{0,0,...</span><span 
class="ec-lmri-10x-x-109">}   </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-7-21-3"  
class="td11">     Observable binning ranges for probabilities        </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-22-"><td  style="white-space:nowrap; text-align:center;" id="TBL-7-22-1"  
class="td11">  <span 
class="ec-lmri-10x-x-109">cutoffs</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}   </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-7-22-2"  
class="td11">      \(0\)      </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-7-22-3"  
class="td11">     Lower graph cutoff for chi-squared estimates       </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-23-"><td  style="white-space:nowrap; text-align:center;" id="TBL-7-23-1"  
class="td11">  <span 
class="ec-lmri-10x-x-109">mincount   </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-7-23-2"  
class="td11">     0        </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-7-23-3"  
class="td11">     Lower count cutoff for chi-squared estimates        </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-24-"><td  style="white-space:nowrap; text-align:center;" id="TBL-7-24-1"  
class="td11">   <span 
class="ec-lmri-10x-x-109">ipsteps     </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-7-24-2"  
class="td11">     1        </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-7-24-3"  
class="td11">            IP transforms per time-step                  </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-25-"><td  style="white-space:nowrap; text-align:center;" id="TBL-7-25-1"  
class="td11"> <span 
class="ec-lmri-10x-x-109">numberaxis  </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-7-25-2"  
class="td11">     0        </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-7-25-3"  
class="td11">       If 1, forces use of numerical axis labels           </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-26-"><td  style="white-space:nowrap; text-align:center;" id="TBL-7-26-1"  
class="td11">   <span 
class="ec-lmri-10x-x-109">verbose    </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-7-26-2"  
class="td11">     0        </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-7-26-3"  
class="td11">    0 for brief, 1 for informative, 2 for full output       </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-27-"><td  style="white-space:nowrap; text-align:center;" id="TBL-7-27-1"  
class="td11">      \(A,B,C,\ldots \)      </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-7-27-2"  
class="td11">     -        </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-7-27-3"  
class="td11">          User specified static parameters                </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-28-"><td  style="white-space:nowrap; text-align:center;" id="TBL-7-28-1"  
class="td11">   <span 
class="ec-lmri-10x-x-109">olabels     </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-7-28-2"  
class="td11">  <span 
class="ec-lmri-10x-x-109">{’a</span><span 
class="ec-lmri-10x-x-109">_1’,..</span><span 
class="ec-lmri-10x-x-109">}   </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-7-28-3"  
class="td11">                Observable labels                         </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-29-"><td  style="white-space:nowrap; text-align:center;" id="TBL-7-29-1"  
class="td11"> <span 
class="ec-lmri-10x-x-109">transforms  </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-7-29-2"  
class="td11"><span 
class="ec-lmri-10x-x-109">{[0 0 0 0],..</span><span 
class="ec-lmri-10x-x-109">}</span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-7-29-3"  
class="td11">    Fourier transforms in [t,x,y,z,..] per observable      </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-30-"><td  style="white-space:nowrap; text-align:center;" id="TBL-7-30-1"  
class="td11">   <span 
class="ec-lmri-10x-x-109">rawdata    </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-7-30-2"  
class="td11">     0        </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-7-30-3"  
class="td11">         Raw data switch: 1 for raw output              </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-31-"><td  style="white-space:nowrap; text-align:center;" id="TBL-7-31-1"  
class="td11">   <span 
class="ec-lmri-10x-x-109">scatters    </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-7-31-2"  
class="td11">   <span 
class="ec-lmri-10x-x-109">{0,..</span><span 
class="ec-lmri-10x-x-109">}     </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-7-31-3"  
class="td11">     Specify to obtain scatter plots, not averages        </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-32-"><td  style="white-space:nowrap; text-align:center;" id="TBL-7-32-1"  
class="td11">   <span 
class="ec-lmri-10x-x-109">octave     </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-7-32-2"  
class="td11">     <span 
class="ec-lmri-10x-x-109">0        </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-7-32-3"  
class="td11">          Force octave syntax: 1 for octave               </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-33-"><td  style="white-space:nowrap; text-align:center;" id="TBL-7-33-1"  
class="td11">  <span 
class="ec-lmri-10x-x-109">thresholdw  </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-7-33-2"  
class="td11">      \(0\)      </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-7-33-3"  
class="td11">     Threshold for weighted simulation breeding        </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-34-"><td  style="white-space:nowrap; text-align:center;" id="TBL-7-34-1"  
class="td11">    <span 
class="ec-lmri-10x-x-109">iterfb      </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-7-34-2"  
class="td11">      \(2\)      </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-7-34-3"  
class="td11">      Iterations of forward-backward algorithm          </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-35-"><td  style="white-space:nowrap; text-align:center;" id="TBL-7-35-1"  
class="td11">   <span 
class="ec-lmri-10x-x-109">iterproj    </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-7-35-2"  
class="td11">      \(2\)      </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-7-35-3"  
class="td11">          Iterations of projector algorithm               </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-36-"><td  style="white-space:nowrap; text-align:center;" id="TBL-7-36-1"  
class="td11">   <span 
class="ec-lmri-10x-x-109">qcproj     </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-7-36-2"  
class="td11">     <span 
class="ec-lmri-10x-x-109">-        </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-7-36-3"  
class="td11">          Quadratic projection coefficients               </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-37-"><td  style="white-space:nowrap; text-align:center;" id="TBL-7-37-1"  
class="td11">   <span 
class="ec-lmri-10x-x-109">vcproj     </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-7-37-2"  
class="td11">     <span 
class="ec-lmri-10x-x-109">-        </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-7-37-3"  
class="td11">           Vector projection coefficients                  </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-38-"><td  style="white-space:nowrap; text-align:center;" id="TBL-7-38-1"  
class="td11">            </td>
</tr></table></div>
<!--l. 4951--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">9.3</span>  <a 
 id="x1-1570009.3"></a>Function tables</h3>
<!--l. 4953--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.3.1</span>  <a 
 id="x1-1580009.3.1"></a>User function table</h4>
<!--l. 4955--><p class="noindent" >The user-defined functions, calling arguments, and purpose, are:<br 
class="newline" />
                                                                                
                                                                                
  
<div class="tabular"> <table id="TBL-8" class="tabular" 
 
><colgroup id="TBL-8-1g"><col 
id="TBL-8-1"></colgroup><colgroup id="TBL-8-2g"><col 
id="TBL-8-2"></colgroup><colgroup id="TBL-8-3g"><col 
id="TBL-8-3"></colgroup><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-1-"><td  style="white-space:nowrap; text-align:center;" id="TBL-8-1-1"  
class="td11">  Label   </td>
                  <td  style="white-space:nowrap; text-align:center;" id="TBL-8-1-2"  
class="td11">Arguments</td>
                                   <td  style="white-space:nowrap; text-align:center;" id="TBL-8-1-3"  
class="td11">           Purpose                 </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-2-"><td  style="white-space:nowrap; text-align:center;" id="TBL-8-2-1"  
class="td11">  <span 
class="ec-lmri-10x-x-109">deriv    </span></td>
                <td  style="white-space:nowrap; text-align:center;" id="TBL-8-2-2"  
class="td11">     \((a,[a_{-},]w,p)\)     </td>
                      <td  style="white-space:nowrap; text-align:center;" id="TBL-8-2-3"  
class="td11">     Stochastic derivative        </td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-3-"><td  style="white-space:nowrap; text-align:center;" id="TBL-8-3-1"  
class="td11"> <span 
class="ec-lmri-10x-x-109">initial </span></td>
                <td  style="white-space:nowrap; text-align:center;" id="TBL-8-3-2"  
class="td11">     \((r,p)\)     </td>
                      <td  style="white-space:nowrap; text-align:center;" id="TBL-8-3-3"  
class="td11">   Function to initialize fields     </td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-4-"><td  style="white-space:nowrap; text-align:center;" id="TBL-8-4-1"  
class="td11"> <span 
class="ec-lmri-10x-x-109">linear </span></td>
                <td  style="white-space:nowrap; text-align:center;" id="TBL-8-4-2"  
class="td11">     \((p)\)     </td>
                      <td  style="white-space:nowrap; text-align:center;" id="TBL-8-4-3"  
class="td11">   Linear derivative function     </td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-5-"><td  style="white-space:nowrap; text-align:center;" id="TBL-8-5-1"  
class="td11"> <span 
class="ec-lmri-10x-x-109">rfilter </span></td>
                <td  style="white-space:nowrap; text-align:center;" id="TBL-8-5-2"  
class="td11">     \((r,p)\)     </td>
                      <td  style="white-space:nowrap; text-align:center;" id="TBL-8-5-3"  
class="td11">Random filter function in k-space</td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-6-"><td  style="white-space:nowrap; text-align:center;" id="TBL-8-6-1"  
class="td11">  <span 
class="ec-lmri-10x-x-109">nfilter   </span></td>
                <td  style="white-space:nowrap; text-align:center;" id="TBL-8-6-2"  
class="td11">     \((w,p)\)     </td>
                      <td  style="white-space:nowrap; text-align:center;" id="TBL-8-6-3"  
class="td11"> Noise filter function in k-space  </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-7-"><td  style="white-space:nowrap; text-align:center;" id="TBL-8-7-1"  
class="td11"> <span 
class="ec-lmri-10x-x-109">transfer  </span></td>
                <td  style="white-space:nowrap; text-align:center;" id="TBL-8-7-2"  
class="td11">     \((a,p,a_{0},p_{0})\)     </td>
                      <td  style="white-space:nowrap; text-align:center;" id="TBL-8-7-3"  
class="td11">   Transfer inside a sequence     </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-8-"><td  style="white-space:nowrap; text-align:center;" id="TBL-8-8-1"  
class="td11">  <span 
class="ec-lmri-10x-x-109">method   </span></td>
                <td  style="white-space:nowrap; text-align:center;" id="TBL-8-8-2"  
class="td11">     \((a,w,p)\)     </td>
                      <td  style="white-space:nowrap; text-align:center;" id="TBL-8-8-3"  
class="td11"> Algorithm defining a time-step  </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-9-"><td  style="white-space:nowrap; text-align:center;" id="TBL-8-9-1"  
class="td11">   <span 
class="ec-lmri-10x-x-109">grid    </span></td>
                <td  style="white-space:nowrap; text-align:center;" id="TBL-8-9-2"  
class="td11">     \((p)\)     </td>
                      <td  style="white-space:nowrap; text-align:center;" id="TBL-8-9-3"  
class="td11">  Grid calculator for the lattice   </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-10-"><td  style="white-space:nowrap; text-align:center;" id="TBL-8-10-1"  
class="td11">   <span 
class="ec-lmri-10x-x-109">prop    </span></td>
                <td  style="white-space:nowrap; text-align:center;" id="TBL-8-10-2"  
class="td11">     \((a,p)\)     </td>
                      <td  style="white-space:nowrap; text-align:center;" id="TBL-8-10-3"  
class="td11"> Interaction picture propagator  </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-11-"><td  style="white-space:nowrap; text-align:center;" id="TBL-8-11-1"  
class="td11"><span 
class="ec-lmri-10x-x-109">propfactor </span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-8-11-2"  
class="td11">     \((nc,p)\)     </td><td  style="white-space:nowrap; text-align:center;" id="TBL-8-11-3"  
class="td11">  Propagator array calculation   </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-12-"><td  style="white-space:nowrap; text-align:center;" id="TBL-8-12-1"  
class="td11">  <span 
class="ec-lmri-10x-x-109">observe  </span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-8-12-2"  
class="td11">     \((a,p)\)     </td><td  style="white-space:nowrap; text-align:center;" id="TBL-8-12-3"  
class="td11"> Observable function cell array  </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-13-"><td  style="white-space:nowrap; text-align:center;" id="TBL-8-13-1"  
class="td11"> <span 
class="ec-lmri-10x-x-109">function  </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-8-13-2"  
class="td11">     \((o,p)\)     </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-8-13-3"  
class="td11"> Functions of average observables </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-14-"><td  style="white-space:nowrap; text-align:center;" id="TBL-8-14-1"  
class="td11"> <span 
class="ec-lmri-10x-x-109">compare  </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-8-14-2"  
class="td11">     \((p)\)     </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-8-14-3"  
class="td11">Comparisons, for differences and \(\chi ^{2}\)</td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-15-"><td  style="white-space:nowrap; text-align:center;" id="TBL-8-15-1"  
class="td11">  <span 
class="ec-lmri-10x-x-109">define   </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-8-15-2"  
class="td11">     \((a,w,p)\)     </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-8-15-3"  
class="td11"> Defines an auxiliary field value  </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-16-"><td  style="white-space:nowrap; text-align:center;" id="TBL-8-16-1"  
class="td11"><span 
class="ec-lmri-10x-x-109">randomgen</span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-8-16-2"  
class="td11">     \((p)\)     </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-8-16-3"  
class="td11">    Initial random generator      </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-17-"><td  style="white-space:nowrap; text-align:center;" id="TBL-8-17-1"  
class="td11"> <span 
class="ec-lmri-10x-x-109">noisegen  </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-8-17-2"  
class="td11">     \((p)\)     </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-8-17-3"  
class="td11">       Noise generator            </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-18-"><td  style="white-space:nowrap; text-align:center;" id="TBL-8-18-1"  
class="td11">  <span 
class="ec-lmri-10x-x-109">rfilter   </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-8-18-2"  
class="td11">     \((v,p)\)     </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-8-18-3"  
class="td11">   Initial random kspace filter    </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-19-"><td  style="white-space:nowrap; text-align:center;" id="TBL-8-19-1"  
class="td11">  <span 
class="ec-lmri-10x-x-109">nfilter   </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-8-19-2"  
class="td11">     \((w,p)\)     </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-8-19-3"  
class="td11">      Noise kspace filter          </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-20-"><td  style="white-space:nowrap; text-align:center;" id="TBL-8-20-1"  
class="td11">  <span 
class="ec-lmri-10x-x-109">project   </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-8-20-2"  
class="td11">     \((d,a,n,p)\)     </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-8-20-3"  
class="td11">     Defines the projection        </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-21-"><td  style="white-space:nowrap; text-align:center;" id="TBL-8-21-1"  
class="td11">  <span 
class="ec-lmri-10x-x-109">firstfb   </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-8-21-2"  
class="td11">     \((a0,nc,p)\)     </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-8-21-3"  
class="td11">  First forward-backward path   </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-22-"><td  style="white-space:nowrap; text-align:center;" id="TBL-8-22-1"  
class="td11">         </td> 
</tr></table></div><br 
class="newline" />
<!--l. 5005--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.3.2</span>  <a 
 id="x1-1590009.3.2"></a>Internal function table</h4>
<!--l. 5007--><p class="noindent" >For details of the internal functions, see section <a 
href="#x1-2090009.6">9.6<!--tex4ht:ref: sec:xSIM-internal-functions --></a> and sections <a 
href="#x1-1110007">7<!--tex4ht:ref: sec:Algorithms --></a> and <a 
href="#x1-1110007">7<!--tex4ht:ref: sec:Algorithms --></a>. All xSPDE internal
functions are capitalized. They are:<br 
class="newline" />  
<div class="tabular"> <table id="TBL-9" class="tabular" 
 
><colgroup id="TBL-9-1g"><col 
id="TBL-9-1"></colgroup><colgroup id="TBL-9-2g"><col 
id="TBL-9-2"></colgroup><colgroup id="TBL-9-3g"><col 
id="TBL-9-3"></colgroup><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-9-1-"><td  style="white-space:nowrap; text-align:center;" id="TBL-9-1-1"  
class="td11"> Label  </td>
               <td  style="white-space:nowrap; text-align:center;" id="TBL-9-1-2"  
class="td11">Arguments</td>
                                 <td  style="white-space:nowrap; text-align:center;" id="TBL-9-1-3"  
class="td11">             Purpose                    </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-9-2-"><td  style="white-space:nowrap; text-align:center;" id="TBL-9-2-1"  
class="td11">  <span 
class="ec-lmri-10x-x-109">Ave    </span></td>
              <td  style="white-space:nowrap; text-align:center;" id="TBL-9-2-2"  
class="td11">     \((a,[av,]p)\)     </td>
                     <td  style="white-space:nowrap; text-align:center;" id="TBL-9-2-3"  
class="td11">   Averages over a spatial lattice     </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-9-3-"><td  style="white-space:nowrap; text-align:center;" id="TBL-9-3-1"  
class="td11">  <span 
class="ec-lmri-10x-x-109">Bin    </span></td>
              <td  style="white-space:nowrap; text-align:center;" id="TBL-9-3-2"  
class="td11">     \((a,[dx,]p)\)     </td>
                     <td  style="white-space:nowrap; text-align:center;" id="TBL-9-3-3"  
class="td11">      Bins results onto an axis         </td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-9-4-"><td  style="white-space:nowrap; text-align:center;" id="TBL-9-4-1"  
class="td11"> <span 
class="ec-lmri-10x-x-109">Catproj </span></td>
              <td  style="white-space:nowrap; text-align:center;" id="TBL-9-4-2"  
class="td11">     \((d,a,n,p)\)     </td>
                     <td  style="white-space:nowrap; text-align:center;" id="TBL-9-4-3"  
class="td11">        Catenoid projector             </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-9-5-"><td  style="white-space:nowrap; text-align:center;" id="TBL-9-5-1"  
class="td11">   <span 
class="ec-lmri-10x-x-109">D1    </span></td>
              <td  style="white-space:nowrap; text-align:center;" id="TBL-9-5-2"  
class="td11">     \((a,[dir,]p)\)     </td>
                     <td  style="white-space:nowrap; text-align:center;" id="TBL-9-5-3"  
class="td11">          First derivative               </td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-9-6-"><td  style="white-space:nowrap; text-align:center;" id="TBL-9-6-1"  
class="td11"> <span 
class="ec-lmri-10x-x-109">D2 </span></td>
              <td  style="white-space:nowrap; text-align:center;" id="TBL-9-6-2"  
class="td11">     \((a,[dir,]p)\)     </td>
                     <td  style="white-space:nowrap; text-align:center;" id="TBL-9-6-3"  
class="td11">         Second derivative              </td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-9-7-"><td  style="white-space:nowrap; text-align:center;" id="TBL-9-7-1"  
class="td11"> <span 
class="ec-lmri-10x-x-109">Euler </span></td>
              <td  style="white-space:nowrap; text-align:center;" id="TBL-9-7-2"  
class="td11">     \((a,w,p)\)     </td>
                     <td  style="white-space:nowrap; text-align:center;" id="TBL-9-7-3"  
class="td11">         Euler algorithm               </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-9-8-"><td  style="white-space:nowrap; text-align:center;" id="TBL-9-8-1"  
class="td11"> <span 
class="ec-lmri-10x-x-109">Implicit </span></td>
              <td  style="white-space:nowrap; text-align:center;" id="TBL-9-8-2"  
class="td11">     \((a,w,p)\)     </td>
                     <td  style="white-space:nowrap; text-align:center;" id="TBL-9-8-3"  
class="td11">      Implicit Euler algorithm         </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-9-9-"><td  style="white-space:nowrap; text-align:center;" id="TBL-9-9-1"  
class="td11">  <span 
class="ec-lmri-10x-x-109">MP    </span></td>
              <td  style="white-space:nowrap; text-align:center;" id="TBL-9-9-2"  
class="td11">     \((a,w,p)\)     </td>
                     <td  style="white-space:nowrap; text-align:center;" id="TBL-9-9-3"  
class="td11">        Midpoint algorithm            </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-9-10-"><td  style="white-space:nowrap; text-align:center;" id="TBL-9-10-1"  
class="td11"><span 
class="ec-lmri-10x-x-109">MPadapt</span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-9-10-2"  
class="td11">     \((a,w,p)\)     </td><td  style="white-space:nowrap; text-align:center;" id="TBL-9-10-3"  
class="td11">    Midpoint adaptive algorithm      </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-9-11-"><td  style="white-space:nowrap; text-align:center;" id="TBL-9-11-1"  
class="td11">  <span 
class="ec-lmri-10x-x-109">RK2   </span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-9-11-2"  
class="td11">     \((a,w,p)\)     </td><td  style="white-space:nowrap; text-align:center;" id="TBL-9-11-3"  
class="td11">     Runge-Kutta (2) algorithm       </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-9-12-"><td  style="white-space:nowrap; text-align:center;" id="TBL-9-12-1"  
class="td11">  <span 
class="ec-lmri-10x-x-109">RK4   </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-9-12-2"  
class="td11">     \((a,w,p)\)     </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-9-12-3"  
class="td11">     Runge-Kutta (4) algorithm       </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-9-13-"><td  style="white-space:nowrap; text-align:center;" id="TBL-9-13-1"  
class="td11">  <span 
class="ec-lmri-10x-x-109">MPfb  </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-9-13-2"  
class="td11">     \((a,w,p)\)     </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-9-13-3"  
class="td11">Midpoint forward-backward algorithm</td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-9-14-"><td  style="white-space:nowrap; text-align:center;" id="TBL-9-14-1"  
class="td11"><span 
class="ec-lmri-10x-x-109">Quadproj</span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-9-14-2"  
class="td11">     \((d,a,n,p)\)     </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-9-14-3"  
class="td11">    General quadratic projector       </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-9-15-"><td  style="white-space:nowrap; text-align:center;" id="TBL-9-15-1"  
class="td11"> <span 
class="ec-lmri-10x-x-109">Polproj </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-9-15-2"  
class="td11">     \((d,a,n,p)\)     </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-9-15-3"  
class="td11">   Diagonal polynomial projector     </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-9-16-"><td  style="white-space:nowrap; text-align:center;" id="TBL-9-16-1"  
class="td11">   <span 
class="ec-lmri-10x-x-109">Int    </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-9-16-2"  
class="td11">     \((a,[dx\,or\,dk],p)\)     </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-9-16-3"  
class="td11"> Integrates over space or momentum  </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-9-17-"><td  style="white-space:nowrap; text-align:center;" id="TBL-9-17-1"  
class="td11"> <span 
class="ec-lmri-10x-x-109">Enproj  </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-9-17-2"  
class="td11">     \((a,w,p)\)     </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-9-17-3"  
class="td11">  Euler normal projection algorithm   </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-9-18-"><td  style="white-space:nowrap; text-align:center;" id="TBL-9-18-1"  
class="td11"> <span 
class="ec-lmri-10x-x-109">MPproj </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-9-18-2"  
class="td11">     \((a,w,p)\)     </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-9-18-3"  
class="td11">   Midpoint projection algorithm     </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-9-19-"><td  style="white-space:nowrap; text-align:center;" id="TBL-9-19-1"  
class="td11"><span 
class="ec-lmri-10x-x-109">MPnproj</span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-9-19-2"  
class="td11">     \((a,w,p)\)     </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-9-19-3"  
class="td11">Midpoint normal projection algorithm</td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-9-20-"><td  style="white-space:nowrap; text-align:center;" id="TBL-9-20-1"  
class="td11">        </td> 
</tr></table></div><br 
class="newline" />     
<ul class="itemize1">
<li class="itemize">     
<!--l. 5055--><p class="noindent" >Projection algorithms with a ’<span 
class="ec-lmri-10x-x-109">proj</span>’ suffix require a <span 
class="ec-lmri-10x-x-109">project </span>function.
                                                                                
                                                                                
     
</li>
<li class="itemize">     
<!--l. 5057--><p class="noindent" >Forward-backward algorithms with an ’<span 
class="ec-lmri-10x-x-109">fb</span>’ suffix require a second field in the user
deriv function.
</li>     
<li class="itemize">
<!--l. 5059--><p class="noindent" >For \(Int\), one can integrate either with respect to \(dx\) or \(dk\), in either ordinary space or
momentum space, by changing the second argument passed to \(xint\) as required.
</li>     
<li class="itemize">
<!--l. 5062--><p class="noindent" >For integration in momentum space, fields that are passed to \(Int\) are transformed if
the <span 
class="ec-lmri-10x-x-109">observe </span>function is used with Fourier transforms selected using <span 
class="ec-lmri-10x-x-109">transforms</span>.
</li>     
<li class="itemize">
<!--l. 5065--><p class="noindent" >For integrating functions like <span 
class="ec-lmri-10x-x-109">function</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}  </span>with transforms, the transform flags
<span 
class="ec-lmri-10x-x-109">transforms</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">} </span>should be used both for the function and any <span 
class="ec-lmri-10x-x-109">observe </span>averages used.
</li>     
<li class="itemize">
<!--l. 5068--><p class="noindent" >Average data is <span 
class="ec-lmri-10x-x-109">not </span>Fourier transformed after averaging. If this is required, it is
best to output the data first.</li></ul>
<!--l. 5072--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">9.4</span>  <a 
 id="x1-1600009.4"></a>Parameter reference</h3>
<!--l. 5074--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.4.1</span>  <a 
 id="x1-1610009.4.1"></a><span 
class="ec-lmri-10x-x-109">auxfields</span></h4>
<dl class="description"><dt class="description">     
<!--l. 5076--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 5076--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">0</span></dd></dl>
                                                                                
                                                                                

<!--l. 5078--><p class="noindent" >These are real or complex auxiliary fields stored at each lattice point, specified using <span 
class="ec-lmri-10x-x-109">define</span>.
They are useful for input/output spectral calculations, and can be functions of the
noise.
<dl class="description"><dt class="description">     
<!--l. 5082--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 5082--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.auxfields = 2</span></dd></dl>
<!--l. 5085--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.4.2</span>  <a 
 id="x1-1620009.4.2"></a><span 
class="ec-lmri-10x-x-109">axes</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}</span></h4>
<dl class="description"><dt class="description">     
<!--l. 5087--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 5087--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">{0,0,0,..</span><span 
class="ec-lmri-10x-x-109">}</span></dd></dl>
<!--l. 5089--><p class="noindent" >Gives the axis points used for comparisons in the \(n\)-th output function, in each dimension. For
each function, the axes can be individually specified in each dimension. Each entry value is a
vector range for a particular dimension, for \(d\)<span 
class="ec-lmri-10x-x-109">=1,...p.dimension</span>s. Thus, <span 
class="ec-lmri-10x-x-109">5 </span>gives the fifth point
only in that dimension, and an input <span 
class="ec-lmri-10x-x-109">1:4:41 </span>plots every fourth point. Zero or negative values
are shorthand: <span 
class="ec-lmri-10x-x-109">-1 </span>generates a default point at the midpoint, <span 
class="ec-lmri-10x-x-109">-2 </span>the endpoint, and
<span 
class="ec-lmri-10x-x-109">0 </span>is the default value that gives the vector for the every axis point. This data is
also used to control graphics outputs. It can be input separately for the graphs if
required.
<dl class="description"><dt class="description">     
<!--l. 5100--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 5100--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.axes</span><span 
class="ec-lmri-10x-x-109">{4</span><span 
class="ec-lmri-10x-x-109">} = </span><span 
class="ec-lmri-10x-x-109">{1:2:10,0,0,-1</span><span 
class="ec-lmri-10x-x-109">}</span></dd></dl>
<!--l. 5103--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.4.3</span>  <a 
 id="x1-1630009.4.3"></a><span 
class="ec-lmri-10x-x-109">backfields</span></h4>
                                                                                
                                                                                
     
<dl class="description"><dt class="description">
<!--l. 5105--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 5105--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">0</span></dd></dl>
<!--l. 5107--><p class="noindent" >The optional input <span 
class="ec-lmbxi-10x-x-109">backfields </span>is the number of backward-time stochastic fields that are
integrated, as part of the overall vector of integrated <span 
class="ec-lmri-10x-x-109">fields </span>components. Requires a
forward-backward method like <span 
class="ec-lmri-10x-x-109">MPfb.</span>
<dl class="description"><dt class="description">     
<!--l. 5112--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 5112--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.backfields = 2</span></dd></dl>
<!--l. 5115--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.4.4</span>  <a 
 id="x1-1640009.4.4"></a><span 
class="ec-lmri-10x-x-109">binranges</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}</span></h4>
<dl class="description"><dt class="description">     
<!--l. 5117--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 5117--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">{</span><span 
class="ec-lmri-10x-x-109">}</span></dd></dl>
<!--l. 5119--><p class="noindent" >Nested cell array, \(binranges\{n\}\{m\}\), that defines the probability plotted for observable \(n\). If null or zero, the mean
of the observable is calculated as usual. The second cell index, \(m=1,\ldots M\), corresponds to the line index
returned by the corresponding \(n\)-th <span 
class="ec-lmri-10x-x-109">observe </span>function. When nonzero, the probability of the \(n\)-th
observable is calculated and plotted according to the specified vector of axis points. This sets
extra dimensions in the data, depending on the range of \(m\) values, with \([o_{1},o_{2},\ldots o_{K}]\), being the start and end
of each of the bins used to accumulate probabilities. The \(k-th\) bin is centered at \((o_{k}+o_{k+1})/2\). In this
version of xSPDE, each bin must have the same width for an observable and line
number. The output is the average probability density versus the (vector) value of the
observable. Hence \(M\) extra output dimensions are added to the generated probability
data. 
<dl class="description"><dt class="description">
<!--l. 5134--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 5134--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.binranges</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}</span><span 
class="ec-lmri-10x-x-109">{1</span><span 
class="ec-lmri-10x-x-109">} = </span><span 
class="ec-lmri-10x-x-109">{-5:0.1:5</span>,<span 
class="ec-lmri-10x-x-109">-2:0.1:2</span><span 
class="ec-lmri-10x-x-109">}</span></dd></dl>
                                                                                
                                                                                
<!--l. 5137--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.4.5</span>  <a 
 id="x1-1650009.4.5"></a><span 
class="ec-lmri-10x-x-109">boundaries</span><span 
class="ec-lmri-10x-x-109">{dir</span><span 
class="ec-lmri-10x-x-109">}</span></h4>
<dl class="description"><dt class="description">     
<!--l. 5139--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 5139--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">[0, 0]</span></dd></dl>
<!--l. 5141--><p class="noindent" >Cell array for type of spatial boundary conditions used, set for each dimension and field
component independently, and used in the equation solutions. The cell index is \(dir=2,3,..\), indicating the
dimension. The boundary conditions are defined as a matrix. The first index is the field index <span 
class="ec-lmri-10x-x-109">i</span>
and the second index the boundary <span 
class="ec-lmri-10x-x-109">j</span>, with \(j=1\) for the lower and \(j=2\) for the upper boundary. The
options are \(b=-1,0,1\).
<ul class="itemize1">     
<li class="itemize">
<!--l. 5149--><p class="noindent" >The default option, or 0, is periodic.
</li>     
<li class="itemize">
<!--l. 5150--><p class="noindent" >If  -1,  Robin/Neumann  boundaries  are  used,  with  derivatives  set  to  prescribed
values.
</li>     
<li class="itemize">
<!--l. 5152--><p class="noindent" >If 1, Dirichlet boundaries are used, with fields set to prescribed values.</li></ul>
<!--l. 5155--><p class="noindent" >In the current code, only default boundaries are available using spectral (<span 
class="ec-lmri-10x-x-109">linear</span>) methods. Using
arbitrary non-periodic boundaries <span 
class="ec-lmri-10x-x-109">requires </span>the use of finite difference derivatives, without the
option of an interaction picture derivative. In such general cases, arbitrary boundary values
are set by <span 
class="ec-lmri-10x-x-109">boundfun(a,d,p)</span>.
<dl class="description"><dt class="description">     
<!--l. 5161--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 5161--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.boundaries</span><span 
class="ec-lmri-10x-x-109">{d</span><span 
class="ec-lmri-10x-x-109">} = [-1,1;0,0;1,-1]</span></dd></dl>
                                                                                
                                                                                
<!--l. 5164--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.4.6</span>  <a 
 id="x1-1660009.4.6"></a><span 
class="ec-lmri-10x-x-109">c...</span></h4>
<!--l. 5166--><p class="noindent" >The starting letter <span 
class="ec-lmri-10x-x-109">c </span>is always reserved to store user-specified constants and parameters. It is
passed to user functions and can be any data. All inputs — including <span 
class="ec-lmri-10x-x-109">c </span>data — are copied into
the stored data files via the lattice structure p, to give a permanent record of simulation
parameter values along with the output data.
<dl class="description"><dt class="description">     
<!--l. 5173--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 5173--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.constant = 2*pi</span></dd></dl>
<!--l. 5176--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.4.7</span>  <a 
 id="x1-1670009.4.7"></a><span 
class="ec-lmri-10x-x-109">checks</span></h4>
<dl class="description"><dt class="description">     
<!--l. 5178--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 5178--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">1</span></dd></dl>
<!--l. 5180--><p class="noindent" >This defines if a repeat integration is carried out for error-checking purposes. If <span 
class="ec-lmri-10x-x-109">p.checks = </span>0,
there is one integration, with no checking at smaller time-steps. For error checking, set
<span 
class="ec-lmri-10x-x-109">p.checks = 1</span>, which repeats the calculation at half the time-step — but with identical noise —
to obtain error bars. This is the default value, taking three times longer overall, but with
increased accuracy and error-estimates.
<!--l. 5188--><p class="indent" >  Also see the <span 
class="ec-lmri-10x-x-109">order </span>parameter, below<span 
class="ec-lmri-10x-x-109">.</span>
<dl class="description"><dt class="description">     
<!--l. 5190--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 5190--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.checks = 0</span></dd></dl>
<!--l. 5193--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.4.8</span>  <a 
 id="x1-1680009.4.8"></a><span 
class="ec-lmri-10x-x-109">dimensions</span></h4>
                                                                                
                                                                                
     
<dl class="description"><dt class="description">
<!--l. 5195--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 5195--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">1</span></dd></dl>
<!--l. 5197--><p class="noindent" >This is the space-time dimension for an SPDE. If omitted, <span 
class="ec-lmri-10x-x-109">dimensions=1</span>, giving an SDE. It is
arbitrary apart from the obvious memory requirements at large dimensionality.
<dl class="description"><dt class="description">     
<!--l. 5201--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 5201--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.dimensions = 4</span></dd></dl>
<!--l. 5204--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.4.9</span>  <a 
 id="x1-1690009.4.9"></a><span 
class="ec-lmri-10x-x-109">ensembles</span></h4>
<dl class="description"><dt class="description">     
<!--l. 5206--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 5206--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">[1, 1, 1]</span></dd></dl>
<!--l. 5208--><p class="noindent" >Number of independent stochastic trajectories simulated. This has three levels to maximize
efficiency. The first is within-thread parallelism, allowing vector instructions. The second gives
a number of independent trajectories calculated serially. The third gives multi-core parallelism
and requires the Matlab parallel toolbox. Either <span 
class="ec-lmri-10x-x-109">p.ensembles(2) </span>or <span 
class="ec-lmri-10x-x-109">p.ensembles(3) </span>are
required to obtain sampling error-bars. The total number of stochastic trajectories or
samples is \(ensembles(1)\times ensembles(2)\times ensembles(3)\). The second and third <span 
class="ec-lmri-10x-x-109">ensembles </span>cannot be changed during a sequence of
simulations.
<dl class="description"><dt class="description">     
<!--l. 5218--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 5218--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.ensembles = [1000,100,10]</span></dd></dl>
                                                                                
                                                                                
<!--l. 5221--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.4.10</span>  <a 
 id="x1-1700009.4.10"></a><span 
class="ec-lmri-10x-x-109">fields</span></h4>
<dl class="description"><dt class="description">     
<!--l. 5223--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 5223--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">1</span></dd></dl>
<!--l. 5225--><p class="noindent" >These are real or complex variables stored at each lattice point that are the independent
variables for integration. The fields are vectors that can have any number of components
and any number of dimensions. The <span 
class="ec-lmri-10x-x-109">fields </span>input is the number of real or complex
components that are initialized by the <span 
class="ec-lmri-10x-x-109">initial </span>function and integrated using the deriv
derivative.
<dl class="description"><dt class="description">     
<!--l. 5232--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 5232--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.fields = 2</span></dd></dl>
<!--l. 5235--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.4.11</span>  <a 
 id="x1-1710009.4.11"></a><span 
class="ec-lmri-10x-x-109">file</span></h4>
<dl class="description"><dt class="description">     
<!--l. 5237--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 5237--><p class="noindent" >’ ’</dd></dl>
<!--l. 5239--><p class="noindent" >Matlab or HDF5 file name for output data. Includes all data and parameter values, including
raw trajectories if \(p.rawdata=1\). If not needed just omit this. A Matlab filename should end
in .mat, while an HDF5 file requires the filename to end in .h5. For a sequence of
inputs, the filename should be given in the first structure of the sequence, and the
entire sequence is stored. This cannot be changed for successive parts of the overall
sequence.
<dl class="description"><dt class="description">     
<!--l. 5247--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 5247--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.file = ’file-name’</span></dd></dl>
                                                                                
                                                                                
<!--l. 5250--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.4.12</span>  <a 
 id="x1-1720009.4.12"></a><span 
class="ec-lmri-10x-x-109">functions</span></h4>
<dl class="description"><dt class="description">     
<!--l. 5252--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 5252--><p class="noindent" >number of defined functions or observables</dd></dl>
<!--l. 5254--><p class="noindent" >This gives the maximum number of output datasets which are functions of the observables. The
default number of functional transformations is the greater of the length of the cell arrays of
<span 
class="ec-lmri-10x-x-109">observe </span>and <span 
class="ec-lmri-10x-x-109">function </span>definitions. Normally, this is not initialized, as the default is
typically used, unless one wishes to reduce the data output without changing an input
script.
<dl class="description"><dt class="description">     
<!--l. 5261--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 5261--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.functions = 1</span></dd></dl>
<!--l. 5264--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.4.13</span>  <a 
 id="x1-1730009.4.13"></a><span 
class="ec-lmri-10x-x-109">ipsteps</span></h4>
<dl class="description"><dt class="description">     
<!--l. 5266--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 5266--><p class="noindent" >1 for <span 
class="ec-lmri-10x-x-109">Euler</span>, <span 
class="ec-lmri-10x-x-109">Implici</span>t and <span 
class="ec-lmri-10x-x-109">RK2</span>; 2 for <span 
class="ec-lmri-10x-x-109">MP, MPadapt </span>and <span 
class="ec-lmri-10x-x-109">RK4; 0 otherwise</span></dd></dl>
<!--l. 5269--><p class="noindent" >This specifies the number of interaction picture time-steps needed in an integration time-step.
Default values are chosen according to the setting of <span 
class="ec-lmri-10x-x-109">method</span>. Can be changed for custom
integration methods. This must be initialized if a non-standard integration method is used
that requires an interaction picture as well.
<dl class="description"><dt class="description">     
<!--l. 5275--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 5275--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.ipsteps = 1</span></dd></dl>
                                                                                
                                                                                
<!--l. 5278--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.4.14</span>  <a 
 id="x1-1740009.4.14"></a><span 
class="ec-lmri-10x-x-109">iterations</span></h4>
<dl class="description"><dt class="description">     
<!--l. 5280--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 5280--><p class="noindent" >4</dd></dl>
<!--l. 5282--><p class="noindent" >For iterative algorithms like the implicit midpoint method, the iteration count is set here,
typically around 3-4. Will increase the integration accuracy if set higher, but it may be better
to increase steps if this is needed. With non-iterated algorithms, this input is not
used: 
<dl class="description"><dt class="description">
<!--l. 5287--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 5287--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.iterations = 3</span></dd></dl>
<!--l. 5290--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.4.15</span>  <a 
 id="x1-1750009.4.15"></a><span 
class="ec-lmri-10x-x-109">name</span></h4>
<dl class="description"><dt class="description">     
<!--l. 5292--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 5292--><p class="noindent" >’ ’</dd></dl>
<!--l. 5294--><p class="noindent" >Name used to label simulation, usually corresponding to the equation or problem solved. This
can be removed from graphs using <span 
class="ec-lmri-10x-x-109">headers </span>equal to a single blank space when running
<span 
class="ec-lmri-10x-x-109">xgraph</span>.
<dl class="description"><dt class="description">     
<!--l. 5298--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 5298--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.name = ’your project name’</span></dd></dl>
                                                                                
                                                                                
<!--l. 5301--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.4.16</span>  <a 
 id="x1-1760009.4.16"></a><span 
class="ec-lmri-10x-x-109">noises</span></h4>
<dl class="description"><dt class="description">     
<!--l. 5303--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 5303--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">fields (1)</span></dd></dl>
<!--l. 5305--><p class="noindent" >This gives the number of stochastic noises generated per lattice point, in coordinate and
momentum space, respectively. Set to zero (\(noises=0\)) for no noises. This is the number of rows in the
noise-vector. Noises can be delta-correlated in x-space or in k-space. The second input is
the dimension of noises in k-space. It can be omitted if zero. This allows use of
finite correlation lengths, by including a frequency filter function that is used to
modify the noise in Fourier-space. The Fourier-space random variance is defined
by the filter function. This takes the noises in Fourier space and returns a filtered
version, which is inverse Fourier transformed before use. The first noise index, \(noises(1)\),
indicates how many independent noise fields are generated, while \(noises(2)\) indicates how many
noises are Fourier-transformed, filtered and then inverse Fourier transformed to give
correlations. These are extra noises, so the total is \(noises(1)+noises(2)\). Filtered noises have a finite correlation
length.
<dl class="description"><dt class="description">     
<!--l. 5321--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 5321--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.noises = [2,4]</span>.</dd></dl>
<!--l. 5324--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.4.17</span>  <a 
 id="x1-1770009.4.17"></a><span 
class="ec-lmri-10x-x-109">order</span></h4>
<dl class="description"><dt class="description">     
<!--l. 5326--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 5326--><p class="noindent" >1 for \(ensembles\neq 1\), otherwise the deterministic order.</dd></dl>
<!--l. 5329--><p class="noindent" >This is the extrapolation order, which is only used if \(p.checks=1\). The program uses the estimated
convergence order to extrapolate to zero step-size, with reduced errors. If <span 
class="ec-lmri-10x-x-109">p.order</span>
<span 
class="ec-lmri-10x-x-109">= 0</span>, no extrapolation is used, which is the most conservative input. The default
order is usually acceptable, especially when combined with the default midpoint
algorithm.
                                                                                
                                                                                
<!--l. 5336--><p class="indent" >  The extrapolation order cannot be changed during a sequence. The default deterministic
orders of the six preset methods used <span 
class="ec-lmri-10x-x-109">without </span>stochastic ensembles are:
<dl class="description"><dt class="description">     
<!--l. 5340--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">1</span> 
</dt><dd 
class="description">   
<!--l. 5340--><p class="noindent" >for <span 
class="ec-lmri-10x-x-109">Euler </span>and <span 
class="ec-lmri-10x-x-109">Implicit;</span>
</dd>     
<dt class="description">
<!--l. 5341--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">2</span> 
</dt><dd 
class="description">   
<!--l. 5341--><p class="noindent" >for <span 
class="ec-lmri-10x-x-109">RK2</span>, <span 
class="ec-lmri-10x-x-109">MP </span>and <span 
class="ec-lmri-10x-x-109">MPadapt</span>;
</dd>     
<dt class="description">
<!--l. 5342--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">4</span> 
</dt><dd 
class="description">   
<!--l. 5342--><p class="noindent" >for <span 
class="ec-lmri-10x-x-109">RK4</span>.
</dd>     
<dt class="description">
<!--l. 5343--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 5343--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.order = 0</span></dd></dl>
<!--l. 5346--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.4.18</span>  <a 
 id="x1-1780009.4.18"></a><span 
class="ec-lmri-10x-x-109">origins</span></h4>
<dl class="description"><dt class="description">     
<!--l. 5348--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 5348--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">[0, -p.ranges/2]</span></dd></dl>
<!--l. 5350--><p class="noindent" >This displaces the graph origin for each simulation to a user-defined value. If omitted, all initial
times in a sequence are zero, and the space origin is set to <span 
class="ec-lmri-10x-x-109">-p.ranges/2 </span>to give results that are
symmetric about the origin. As an example, for the x-dimension, the problem is solved on an
interval of \(x=[O_{2},O_{2}+R_{2}]\), with a default origin of \(-R_{2}/2\), so that \(x=[-R_{2}/2,R_{2}/2].\)
<dl class="description"><dt class="description">     
<!--l. 5357--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 5357--><p class="noindent" >p.origins = [0,-20,-20]</dd></dl>
                                                                                
                                                                                
<!--l. 5360--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.4.19</span>  <a 
 id="x1-1790009.4.19"></a><span 
class="ec-lmri-10x-x-109">points</span></h4>
<dl class="description"><dt class="description">     
<!--l. 5362--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 5362--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">[51, 35, ..., 35]</span></dd></dl>
<!--l. 5364--><p class="noindent" >The rectangular lattice of points plotted for each dimension are defined by a vector giving the
number of points in each dimension. The default values are given as a rough guide for initial
calculations. Large, high dimensional lattices take more time to integrate. Increasing points
improves graphics resolution and gives better accuracy in each relevant dimension as well, but
requires more memory. Speed is improved when the lattice points are a product of small prime
factors. In order to discretize the problem, the \(p_{i}\) lattice <span 
class="ec-lmri-10x-x-109">points </span>are fitted into the range \(R_{i}\) so that \(dx_{i}=R_{i}/(p_{i}-1)\),
ie: \begin {equation}  x_{i}=O_{i}+(i-1)dx_{i}\,.  \end {equation}  
<dl class="description"><dt class="description">
<!--l. 5379--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 5379--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.points = [30,40,40]</span></dd></dl>
<!--l. 5382--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.4.20</span>  <a 
 id="x1-1800009.4.20"></a><span 
class="ec-lmri-10x-x-109">inrandoms</span></h4>
<dl class="description"><dt class="description">     
<!--l. 5384--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 5384--><p class="noindent" >noises</dd></dl>
<!--l. 5386--><p class="noindent" >This gives the number of initial random fields generated per lattice point in coordinate
and momentum space. Set to zero (\(p.inrandoms=0\)) for no random fields. Random fields can be
delta-correlated in x-space or in k-space. The second input is the dimension of random
fields that are delta-correlated in momentum space. It can be left out if zero. The
Fourier-space random variance is modified by the filter function. This takes the initial
random fields in Fourier space and returns a filtered version, which is inverse Fourier
transformed before use. The first noise index, <span 
class="ec-lmri-10x-x-109">p.inrandoms(1)</span>, indicates how many
                                                                                
                                                                                
independent random fields delta-correlated in space are generated, while <span 
class="ec-lmri-10x-x-109">p.inrandoms(2)</span>
indicates how many additional random fields are Fourier-transformed, filtered and
then inverse Fourier transformed. These are additional random fields, so the total is
<span 
class="ec-lmri-10x-x-109">p.inrandoms(1)+p.inrandoms(2)</span>. The filtered random inputs have a finite correlation
length.
<dl class="description"><dt class="description">     
<!--l. 5401--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 5401--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.inrandoms = [2, 0]</span></dd></dl>
<!--l. 5404--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.4.21</span>  <a 
 id="x1-1810009.4.21"></a><span 
class="ec-lmri-10x-x-109">ranges</span></h4>
<dl class="description"><dt class="description">     
<!--l. 5406--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 5406--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">[10, 10, ...]</span></dd></dl>
<!--l. 5408--><p class="noindent" >Each lattice dimension has a coordinate range. The default value is 10 in each dimension. In the
temporal graphs, the first coordinate is plotted over \(0:p.ranges(1)\). All other coordinates are plotted over \(-p.ranges(n)/2:p.ranges(n)/2\).
The starting value can be changed using the <span 
class="ec-lmri-10x-x-109">origins </span>variable.
<dl class="description"><dt class="description">     
<!--l. 5414--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 5414--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.ranges = [1, 10]</span></dd></dl>
<!--l. 5417--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.4.22</span>  <a 
 id="x1-1820009.4.22"></a><span 
class="ec-lmri-10x-x-109">rawdata</span></h4>
<dl class="description"><dt class="description">     
<!--l. 5419--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 5419--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">0</span></dd></dl>
                                                                                
                                                                                

<!--l. 5421--><p class="noindent" >Flag for storing raw trajectory data. If this flag is turned on, raw trajectories are stored in
memory. The raw data is returned in function calls and also written to a file on completion, if
a file-name is included.
<dl class="description"><dt class="description">     
<!--l. 5426--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 5426--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.rawdata = 1</span></dd></dl>
<!--l. 5429--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.4.23</span>  <a 
 id="x1-1830009.4.23"></a><span 
class="ec-lmri-10x-x-109">scatters</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}</span></h4>
<dl class="description"><dt class="description">     
<!--l. 5431--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 5431--><p class="noindent" >0</dd></dl>
<!--l. 5433--><p class="noindent" >Cell array that defines the number of scatter trajectories plotted for observable \(n\). If absent or
zero, the mean of the observable is calculated as usual. If nonzero, a set of \(s\) observables that
correspond to independent stochastic fields are accumulated, with no averaging. This
cannot be combined with probabilities or with parallel ensembles. There must be at
least <span 
class="ec-lmri-10x-x-109">s </span>trajectories in <span 
class="ec-lmri-10x-x-109">ensembles(1)</span>, otherwise the number of stored trajectories is
reduced.
<dl class="description"><dt class="description">     
<!--l. 5441--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 5441--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.scatters</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">} = 20</span></dd></dl>
<!--l. 5444--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.4.24</span>  <a 
 id="x1-1840009.4.24"></a><span 
class="ec-lmri-10x-x-109">seed</span></h4>
<dl class="description"><dt class="description">     
<!--l. 5446--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 5446--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">0</span></dd></dl>
                                                                                
                                                                                

<!--l. 5448--><p class="noindent" >Random noise generation seed, for obtaining reproducible noise sequences. Set to unique and
distinct values for the different parallel ensembles. Used if \(p.noises&gt;0\) or \(p.inrandoms&gt;0\).
<dl class="description"><dt class="description">     
<!--l. 5452--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 5452--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.seed = 42</span></dd></dl>
<!--l. 5455--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.4.25</span>  <a 
 id="x1-1850009.4.25"></a><span 
class="ec-lmri-10x-x-109">steps</span></h4>
<dl class="description"><dt class="description">     
<!--l. 5457--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 5457--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">1</span></dd></dl>
<!--l. 5459--><p class="noindent" >Number of time-steps per plotted point. The total number of integration time-steps in a
simulation is therefore <span 
class="ec-lmri-10x-x-109">p.steps</span>\(\times \)<span 
class="ec-lmri-10x-x-109">(p.points(1)-1)</span>. Thus, steps can be increased to improve the
accuracy, but gives no change in graphics resolution. Increasing the steps will give a lower
time-discretization error.
<dl class="description"><dt class="description">     
<!--l. 5465--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 5465--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.steps = 1, 2, ...</span></dd></dl>
<!--l. 5468--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.4.26</span>  <a 
 id="x1-1860009.4.26"></a><span 
class="ec-lmri-10x-x-109">transforms</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}</span></h4>
<dl class="description"><dt class="description">     
<!--l. 5470--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 5470--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">[0,0,..]</span></dd></dl>
                                                                                
                                                                                

<!--l. 5472--><p class="noindent" >Cell array defining the Fourier transforms used for an observable <span 
class="ec-lmri-10x-x-109">n</span>. There is one transform
vector per observable. The <span 
class="ec-lmri-10x-x-109">j</span>-th flag, <span 
class="ec-lmri-10x-x-109">tr(j)</span>, indicates a Fourier transform on the <span 
class="ec-lmri-10x-x-109">j</span>-th axis if set
to one, starting with the time axis. The default value is zero, indicating no transform. The
normalization of the Fourier transform is such that the \(k=0\) value in momentum space corresponds
to the integral over space with a factor of \(1/\sqrt {2\pi }\) in each transformed dimension. The Fourier
transform that is graphed has \(k=0\) as the central value. The default is no Fourier transform. Must
be set for any functional transform of a Fourier observable, to give the correct graph
axes. 
<dl class="description"><dt class="description">
<!--l. 5484--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 5484--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.transforms</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">} = [1,0,0,1]</span></dd></dl>
<!--l. 5487--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.4.27</span>  <a 
 id="x1-1870009.4.27"></a><span 
class="ec-lmri-10x-x-109">verbose</span></h4>
<dl class="description"><dt class="description">     
<!--l. 5489--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 5489--><p class="noindent" >0</dd></dl>
<!--l. 5491--><p class="noindent" >Print flag for output information while running xSIM. Print options are:
<ul class="itemize1">     
<li class="itemize">
<!--l. 5494--><p class="noindent" >Minimal if <span 
class="ec-lmri-10x-x-109">verbose = -1</span>: Prints just the start-up time and hard error messages
</li>     
<li class="itemize">
<!--l. 5496--><p class="noindent" >Brief if <span 
class="ec-lmri-10x-x-109">verbose = 0</span>: Additionally prints the final, total integration errors
</li>     
<li class="itemize">
<!--l. 5498--><p class="noindent" >Informative if <span 
class="ec-lmri-10x-x-109">verbose = 1</span>: Also prints the individual function RMS errors and
progress indicators
</li>     
<li class="itemize">
<!--l. 5500--><p class="noindent" >Full if <span 
class="ec-lmri-10x-x-109">verbose = 2</span>: Prints everything, including the internal parameter structure
data.</li></ul>
                                                                                
                                                                                

<!--l. 5503--><p class="noindent" >In summary, if <span 
class="ec-lmri-10x-x-109">verbose = 0</span>, most output is suppressed except the final data, while <span 
class="ec-lmri-10x-x-109">verbose = 1</span>
displays a progress report, and <span 
class="ec-lmri-10x-x-109">verbose = 2 </span>additionally generates a readable summary of the
parameter input as a record.
<dl class="description"><dt class="description">     
<!--l. 5508--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 5508--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.verbose = 2</span></dd></dl>
<!--l. 5511--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.4.28</span>  <a 
 id="x1-1880009.4.28"></a><span 
class="ec-lmri-10x-x-109">version</span></h4>
<dl class="description"><dt class="description">     
<!--l. 5513--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 5513--><p class="noindent" >’<span 
class="ec-lmri-10x-x-109">xSIM3.44</span>’</dd></dl>
<!--l. 5515--><p class="noindent" >Sets the current version number of the simulation program. There is no need to input this except
for project documentation for a customized version.
<dl class="description"><dt class="description">     
<!--l. 5519--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 5519--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.version = ’current version name’</span></dd></dl>
<!--l. 5522--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">9.5</span>  <a 
 id="x1-1890009.5"></a>Function reference </h3>
<!--l. 5524--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.5.1</span>  <a 
 id="x1-1900009.5.1"></a>User function reference </h4>
<!--l. 5526--><p class="noindent" >The following function inputs define the differential equation that is integrated or solved. They
are specified in an xSPDE/xSIM input file using <span 
class="ec-lmri-10x-x-109">p.(fun) = @(Myfun)</span>, either as inline or
externally defined functions. Externally defined functions must be in the same file as the input
parameters, or on the execution path.
                                                                                
                                                                                
<!--l. 5532--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.5.2</span>  <a 
 id="x1-1910009.5.2"></a><span 
class="ec-lmri-10x-x-109">boundfun(a, d, p)</span></h4>
<dl class="description"><dt class="description">     
<!--l. 5534--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 5534--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">xboundfun()</span></dd></dl>
<!--l. 5536--><p class="noindent" >The boundary function <span 
class="ec-lmri-10x-x-109">boundfun(a,d,p) </span>is called for specified boundary conditions in the \(d\)-th
dimension. This returns the boundary values used for the fields or their first derivatives in
space dimension \(d&gt;1\), as an array indexed as \(b(f,\mathbf {i},e)\) in the standard way. Here \(f\) is the field index, \(\mathbf {i}\equiv \left [j_{2},\dots j_{d}\right ]\) are the
space indices, and \(e\) is the ensemble index.
<!--l. 5543--><p class="indent" >  Only two values are needed for \(j_{d}\), which is the index of the dimension whose boundary values
are specified. These are \(j_{d}=1,2\), for the lower and upper boundary values, which are either field values
or derivatives. Boundary values may be constant or a function of the fields \(a\) and space-time
\(t,\mathbf {x}\).
<!--l. 5549--><p class="indent" >  If boundary values have stochastic values which are calculated only once, they must be
initialized. To allow for this, <span 
class="ec-lmri-10x-x-109">boundfun(a,d,p) </span>is initially called with time \(t=origins(1)-1\), snd the input field <span 
class="ec-lmri-10x-x-109">a</span>
set to random values from <span 
class="ec-lmri-10x-x-109">randomgen, </span>which are independent of those that initialise the field
at \(t=origins(1)\).
<!--l. 5555--><p class="indent" >  They are reproducible for different \(check\) cycles, to allow noise-independent error-checking. The
initial results for the boundaries are stored in an array <span 
class="ec-lmri-10x-x-109">boundval</span><span 
class="ec-lmri-10x-x-109">{d</span><span 
class="ec-lmri-10x-x-109">} </span>for later use by <span 
class="ec-lmri-10x-x-109">boundfun </span>if
required.
<!--l. 5560--><p class="indent" >  The default boundary value is zero, set by the default boundary function <span 
class="ec-lmri-10x-x-109">xboundfun(a,d,p)</span>.
<!--l. 5563--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.5.3</span>  <a 
 id="x1-1920009.5.3"></a><span 
class="ec-lmri-10x-x-109">compare(p)</span></h4>
<dl class="description"><dt class="description">     
<!--l. 5565--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 5565--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">compare</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}= []</span></dd></dl>
<!--l. 5567--><p class="noindent" >This is for comparisons to experimental or analytic data. The output is an array with \(d+2\)
dimensions. The first dimension is the line index, the next \(d\) dimensions are time and space,
while the last index is an error index. This can have up to two additional entries for systematic
and/or statistical error bars in the comparison data, from analytic or experimental results.
Error-bars are optional if not available.
                                                                                
                                                                                
<!--l. 5575--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.5.4</span>  <a 
 id="x1-1930009.5.4"></a><span 
class="ec-lmri-10x-x-109">define(a, w, p)</span></h4>
<dl class="description"><dt class="description">     
<!--l. 5577--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 5577--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">xdefine()</span></dd></dl>
<!--l. 5579--><p class="noindent" >Calculates auxiliary fields, which are combinations of fields and noises. If used they are accessed
in <span 
class="ec-lmri-10x-x-109">observe </span>functions as \(a(n,:)\), where \(n&gt;fields\). The default, <span 
class="ec-lmri-10x-x-109">xdefine(), </span>sets the auxiliary fields to
zero.
<!--l. 5584--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.5.5</span>  <a 
 id="x1-1940009.5.5"></a><span 
class="ec-lmri-10x-x-109">deriv(a,w,p)</span></h4>
<dl class="description"><dt class="description">     
<!--l. 5586--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 5586--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">deriv()= 0</span></dd></dl>
<!--l. 5588--><p class="noindent" >This defines the stochastic equation time derivative, given the current field \(a\), delta-correlated
noise terms <span 
class="ec-lmri-10x-x-109">w, </span>and parameters \(p\). It is defined explicitly in (<span 
class="ec-lmbx-10x-x-109">??</span>). This is the right-hand-side of
(<span 
class="ec-lmbx-10x-x-109">??</span>) or (<span 
class="ec-lmbx-10x-x-109">??</span>), <span 
class="ec-lmri-10x-x-109">without </span>the linear term if it is specified separately.
<!--l. 5594--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.5.6</span>  <a 
 id="x1-1950009.5.6"></a><span 
class="ec-lmri-10x-x-109">firstfb(a0,nc,p)</span></h4>
<dl class="description"><dt class="description">     
<!--l. 5596--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 5596--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">xfirstfb()</span></dd></dl>
<!--l. 5598--><p class="noindent" >Returns the zero-th order field estimates in a forward-backward iteration. Here \(nc\) is the time-step
check index. This is needed because the number of time-points to be initialized depends on \(nc\).
The default function is <span 
class="ec-lmri-10x-x-109">xfirstfb</span>, which sets each field in either direction equal to its
initial value at the time boundaries, given by \(a0\). Other estimates may give faster
convergence.
                                                                                
                                                                                
<!--l. 5605--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.5.7</span>  <a 
 id="x1-1960009.5.7"></a><span 
class="ec-lmri-10x-x-109">function(o,p)</span></h4>
<dl class="description"><dt class="description">     
<!--l. 5607--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 5607--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">xfunction</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}=@(o,p) o</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}</span></dd></dl>
<!--l. 5609--><p class="noindent" >This is a user-defined array of functions of the <span 
class="ec-lmri-10x-x-109">observe </span>outputs after averaging over <span 
class="ec-lmri-10x-x-109">ensembles(1)</span>,
possibly involving combinations of several observed averages. The input to the <span 
class="ec-lmri-10x-x-109">n</span>-th function is
the cell array of all averages, and the output is the data for the <span 
class="ec-lmri-10x-x-109">n</span>-th graph. This
function is compatible with all error estimates. The default values generate all the
<span 
class="ec-lmri-10x-x-109">observe </span>averages that are in the data. The output data format is an array with \(d+1\)
dimensions. The first dimension is the line index, the next \(d\) dimensions are time and
space.
<!--l. 5619--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.5.8</span>  <a 
 id="x1-1970009.5.8"></a>grid</h4>
<dl class="description"><dt class="description">     
<!--l. 5621--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">default</span> 
</dt><dd 
class="description">
<!--l. 5621--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">xgrid</span></dd></dl>
<!--l. 5623--><p class="noindent" >Calculates the spatial grid for specialized purposes like non-uniform grids. The default,
<span 
class="ec-lmri-10x-x-109">xgrid</span>, returns a homogeneous rectangular grid in both ordinary and momentum
space.
<!--l. 5627--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.5.9</span>  <a 
 id="x1-1980009.5.9"></a><span 
class="ec-lmri-10x-x-109">initial(rv, p)</span></h4>
<dl class="description"><dt class="description">     
<!--l. 5629--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 5629--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">xinitial()</span></dd></dl>
                                                                                
                                                                                

<!--l. 5631--><p class="noindent" >This is used to initialize each integration in time. It is a user-defined function which can involve
random numbers for an initial probability distribution. This creates a stochastic field on the
lattice, called <span 
class="ec-lmbxi-10x-x-109">a. </span>The returned first dimension should be <span 
class="ec-lmri-10x-x-109">p.fields</span>. The initial Gaussian random
field variable, <span 
class="ec-lmri-10x-x-109">rv</span>, has unit variance if dimension is 1 or else is delta-correlated in space, with
variance \(1/p.dv=1/(dx_{2}...dx_{d}))\) for \(d\) space-time dimensions. If <span 
class="ec-lmri-10x-x-109">inrandoms </span>is given in the input parameter structure,
<span 
class="ec-lmri-10x-x-109">rv </span>has a first dimension of <span 
class="ec-lmri-10x-x-109">inrandoms(1) + inrandoms(2)</span>. If not specified, the default for
<span 
class="ec-lmri-10x-x-109">inrandoms </span>is <span 
class="ec-lmri-10x-x-109">noises</span>. The default function is <span 
class="ec-lmri-10x-x-109">xinitial, </span>which sets fields to zero<span 
class="ec-lmri-10x-x-109">, </span>returning
\(\mathbf {a}=0\).
<!--l. 5644--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.5.10</span>  <a 
 id="x1-1990009.5.10"></a><span 
class="ec-lmri-10x-x-109">linear(p)</span></h4>
<dl class="description"><dt class="description">     
<!--l. 5646--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 5646--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">xlinear()</span></dd></dl>
<!--l. 5648--><p class="noindent" >A user-definable function for the linear response, which is a matrix for an SDE or ODE.
For an SPDE or PDE, it includes transverse derivatives in space, returning the
linear coefficients \(L\) in FFT/DST/DCT space, which are assumed diagonal in the field
index. These are functions of differential terms <span 
class="ec-lmri-10x-x-109">Dx, Dy, Dz</span>, which correspond to \(\partial /\partial x\), \(\partial /\partial y\), \(\partial /\partial z\),
respectively. Each component has a dimension the same as the coordinate lattice.
For axes that are numbered, use <span 
class="ec-lmri-10x-x-109">D</span><span 
class="ec-lmri-10x-x-109">{2</span><span 
class="ec-lmri-10x-x-109">}, D</span><span 
class="ec-lmri-10x-x-109">{3</span><span 
class="ec-lmri-10x-x-109">} </span>etc. The default, <span 
class="ec-lmri-10x-x-109">xlinear, </span>sets <span 
class="ec-lmri-10x-x-109">L </span>to
zero.
<!--l. 5658--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.5.11</span>  <a 
 id="x1-2000009.5.11"></a><span 
class="ec-lmri-10x-x-109">nfilter (w,p)</span></h4>
<dl class="description"><dt class="description">     
<!--l. 5660--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 5660--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">xnfilter()</span></dd></dl>
<!--l. 5662--><p class="noindent" >Returns the momentum-space filter function for the propagation noise terms in momentum-space.
Each component has an array dimension the same as the random noises in momentum space,
that is, the return dimension is <span 
class="ec-lmri-10x-x-109">[noises(2), d.lattice]</span>.
                                                                                
                                                                                
<!--l. 5667--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.5.12</span>  <a 
 id="x1-2010009.5.12"></a><span 
class="ec-lmri-10x-x-109">noisegen(p)</span></h4>
<dl class="description"><dt class="description">     
<!--l. 5669--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 5669--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">xnoisegen(p)</span></dd></dl>
<!--l. 5671--><p class="noindent" >Generates arrays of noise terms for each point in time. The default, <span 
class="ec-lmri-10x-x-109">xnoisegen() </span>returns <span 
class="ec-lmri-10x-x-109">noises(1)</span>
+ <span 
class="ec-lmri-10x-x-109">noises(2) </span>Gaussian real noises that are delta-correlated in time, space and momentum
space, unless <span 
class="ec-lmri-10x-x-109">nfilter </span>is used to modify momentum space correlations.
<!--l. 5676--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.5.13</span>  <a 
 id="x1-2020009.5.13"></a><span 
class="ec-lmri-10x-x-109">observe(a, p)</span></h4>
<dl class="description"><dt class="description">     
<!--l. 5678--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 5678--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">xobserve</span><span 
class="ec-lmri-10x-x-109">{1</span><span 
class="ec-lmri-10x-x-109">}=@(a,p) a</span></dd></dl>
<!--l. 5680--><p class="noindent" >Cell array of function handles that take the current field and returns an observable o. Note the
use of braces for cell arrays! One can input these as <span 
class="ec-lmri-10x-x-109">p.observe</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">} = @(a,p) f(a,p)</span>. An omitted
function less than the maximum index is replaced by the default, which is the vector <span 
class="ec-lmri-10x-x-109">a </span>of real
field amplitudes.
<!--l. 5686--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.5.14</span>  <a 
 id="x1-2030009.5.14"></a><span 
class="ec-lmri-10x-x-109">prop(a, p)</span></h4>
<dl class="description"><dt class="description">     
<!--l. 5688--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 5688--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">xprop()</span></dd></dl>
                                                                                
                                                                                

<!--l. 5690--><p class="noindent" >Returns the fields propagated for one step in the interaction picture, given an initial field a,
using the propagator array. The time-step used in propagator depends on the input time-step,
the error-checking and the algorithm. The default, <span 
class="ec-lmri-10x-x-109">xprop</span>, takes a Fourier transform
of \(\mathbf {a}\), multiplies by propfactor to propagate in time, then takes an inverse Fourier
transform.
<!--l. 5697--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.5.15</span>  <a 
 id="x1-2040009.5.15"></a><span 
class="ec-lmri-10x-x-109">propfactor(nc, p)</span></h4>
<dl class="description"><dt class="description">     
<!--l. 5699--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 5699--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">xpropfactor()</span></dd></dl>
<!--l. 5701--><p class="noindent" >Returns the interaction picture propagator used by the prop function. The time propagated is a
fraction of the current integration time-step, <span 
class="ec-lmri-10x-x-109">dt</span>. It is equal to \(1/ipsteps\) of the integration time-step. It
uses data from the \(\mathbf {linear}\) function to calculate this.
<!--l. 5706--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.5.16</span>  <a 
 id="x1-2050009.5.16"></a><span 
class="ec-lmri-10x-x-109">randomgen(xp)</span></h4>
<dl class="description"><dt class="description">     
<!--l. 5708--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 5708--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">xrandomgen()</span></dd></dl>
<!--l. 5710--><p class="noindent" >Generates a set of initial random fields v to initialize the fields simulated. The default, \(\mathbf {xrandomgen}\), returns
Gaussian real fields that are delta-correlated in space or momentum space. The default uses
rfilter to modify spatial correlations in momentum space if specified.
<!--l. 5715--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.5.17</span>  <a 
 id="x1-2060009.5.17"></a><span 
class="ec-lmri-10x-x-109">rfilter(w, p)</span></h4>
                                                                                
                                                                                
     
<dl class="description"><dt class="description">
<!--l. 5717--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 5717--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">xrfilter()</span></dd></dl>
<!--l. 5719--><p class="noindent" >Returns the momentum-space filter function for the momentum-space random terms. Each
component has an array dimension the same as the input random fields in momentum space,
that is, the return dimension is <span 
class="ec-lmri-10x-x-109">[inrandoms(2), nlattice]</span>.
<!--l. 5724--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.5.18</span>  <a 
 id="x1-2070009.5.18"></a><span 
class="ec-lmri-10x-x-109">method(a, w, p)</span></h4>
<dl class="description"><dt class="description">     
<!--l. 5726--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 5726--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">MP </span>(stochastic); <span 
class="ec-lmri-10x-x-109">RK4 </span>(deterministic)</dd></dl>
<!--l. 5728--><p class="noindent" >Specifies the stochastic integration method for the field <span 
class="ec-lmri-10x-x-109">a</span>, noise <span 
class="ec-lmri-10x-x-109">w</span>, parameters <span 
class="ec-lmri-10x-x-109">p</span>. It returns the
new field <span 
class="ec-lmri-10x-x-109">a</span>. It uses the current reduced step in time p.dtr and current time p.t. This function
can be set to any of the predefined stochastic integration routines provided with xSPDE,
described in the Algorithms section. User-written functions can also be used. The default
deterministic method, <span 
class="ec-lmri-10x-x-109">RK4</span>, is a fourth-order interaction picture Runge-Kutta. The default
stochastic method, <span 
class="ec-lmri-10x-x-109">MP</span>, is an interaction picture midpoint integrator and is used if \(ensembles\) is not
<span 
class="ec-lmri-10x-x-109">[1,1,1]</span>.
<!--l. 5738--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.5.19</span>  <a 
 id="x1-2080009.5.19"></a><span 
class="ec-lmri-10x-x-109">transfer(v, p, a0, p0)</span></h4>
<dl class="description"><dt class="description">     
<!--l. 5740--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 5740--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">xtransfer()</span></dd></dl>
<!--l. 5742--><p class="noindent" >This function initializes sequential simulations, where the previous field <span 
class="ec-lmri-10x-x-109">a0 </span>and parameter
structure <span 
class="ec-lmri-10x-x-109">p0 </span>are inputs to the next stage in the integration sequence. The default,
<span 
class="ec-lmri-10x-x-109">xtransfer()</span>, takes the output, <span 
class="ec-lmri-10x-x-109">a0 </span>of the previous simulation to initialise the fields
\(a\). Otherwise, this function is identical to <span 
class="ec-lmri-10x-x-109">initial()</span>. The default set by <span 
class="ec-lmri-10x-x-109">xtransfer </span>is
\(a=a0\).
                                                                                
                                                                                
<!--l. 5749--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">9.6</span>  <a 
 id="x1-2090009.6"></a>Internal function reference</h3>
<!--l. 5751--><p class="noindent" >The following xSIM predefined functions are available to define the differential equations and
averages. They all start with a capital letter. Algorithms are documented in section
<a 
href="#x1-1110007">7<!--tex4ht:ref: sec:Algorithms --></a>. Fields can be differentiated or integrated only in space, observables in space or
time.
<!--l. 5757--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.6.1</span>  <a 
 id="x1-2100009.6.1"></a><span 
class="ec-lmri-10x-x-109">Ave(o[, av ], p)</span></h4>
<!--l. 5759--><p class="noindent" >This function takes a field or observable and returns an average over one or more
dimensions. The input includes an optional averaging switch <span 
class="ec-lmri-10x-x-109">av</span>. If \(av(j)&gt;0\), an average is taken
over dimension <span 
class="ec-lmri-10x-x-109">j</span>. If the <span 
class="ec-lmri-10x-x-109">av </span>vector is omitted, the average is taken over all space
directions.
<!--l. 5765--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.6.2</span>  <a 
 id="x1-2110009.6.2"></a><span 
class="ec-lmri-10x-x-109">Bin(o[, dx ], p)</span></h4>
<!--l. 5767--><p class="noindent" >The \(Bin\) function takes a field o and returns probabilities on space axes that are defined
by a vector dx. This allows binning of position probabilities if the observable is a
mean position that is plotted on an axis. If <span 
class="ec-lmri-10x-x-109">j </span>is the first index with \(dx(j)&gt;0\), the binning is
taken over dimension <span 
class="ec-lmri-10x-x-109">j</span>. The results returned are the probability of o in the bin,
normalized by \(1/dx\left (j\right )\). If the input array is Fourier transformed, by using the transforms
attribute in the observe function, then one must set \(dx(j)=p.dk(j)\) for transformed dimensions j. If
the dx vector is omitted, or a scalar dx is used, the binning is over the first space
direction.
<!--l. 5778--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.6.3</span>  <a 
 id="x1-2120009.6.3"></a><span 
class="ec-lmri-10x-x-109">D1(a[, dir,ind], p)</span></h4>
<!--l. 5780--><p class="noindent" >Takes a scalar or vector field <span 
class="ec-lmri-10x-x-109">a </span>and returns a derivative with direction <span 
class="ec-lmri-10x-x-109">dir </span>using finite
differences. Set <span 
class="ec-lmri-10x-x-109">dir = 2 </span>for an x-derivative, <span 
class="ec-lmri-10x-x-109">dir = 3 </span>for a y-derivative, and so on. The default
value is \(dir=2\), which is an x-derivative. If the direction is input, an index \(ind\) can be included to
take a derivative of one component. If this is omitted, derivatives of all components
are returned. Boundary conditions are from the <span 
class="ec-lmri-10x-x-109">boundaries </span>input. The D1 input
uses the entire field to identify components and boundary values. It can be made
periodic (<span 
class="ec-lmri-10x-x-109">boundaries = 0</span>), which is the default, or Neumann/Robin with specified
derivatives using <span 
class="ec-lmri-10x-x-109">boundaries = -1</span>, or Dirichlet with specified field using <span 
class="ec-lmri-10x-x-109">boundaries =</span>
<span 
class="ec-lmri-10x-x-109">1</span>.
                                                                                
                                                                                
<!--l. 5793--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.6.4</span>  <a 
 id="x1-2130009.6.4"></a><span 
class="ec-lmri-10x-x-109">D2(a[, dir,ind], p)</span></h4>
<!--l. 5795--><p class="noindent" >This takes a scalar or vector field <span 
class="ec-lmri-10x-x-109">a </span>and returns the second derivative in direction <span 
class="ec-lmri-10x-x-109">dir</span>. Set <span 
class="ec-lmri-10x-x-109">dir</span>
<span 
class="ec-lmri-10x-x-109">= 2 </span>for an x-derivative, <span 
class="ec-lmri-10x-x-109">dir = 3 </span>for a y-derivative, and so on. Other properties are the same as
<span 
class="ec-lmri-10x-x-109">D1()</span>.
<!--l. 5800--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.6.5</span>  <a 
 id="x1-2140009.6.5"></a><span 
class="ec-lmri-10x-x-109">Int(o[, dx, bounds], p)</span></h4>
<!--l. 5802--><p class="noindent" >This function takes any vector or scalar field or observable and returns a space integral over
selected dimensions with vector measure <span 
class="ec-lmri-10x-x-109">dx</span>. If \(dx(j)&gt;0\), dimension <span 
class="ec-lmri-10x-x-109">j </span>is integrated. Time integrals are
only possible for observables. Space dimensions are labelled from <span 
class="ec-lmri-10x-x-109">j = 2,3,...dimension</span>s. To
integrate over the lattice, set <span 
class="ec-lmri-10x-x-109">dx = p.dx</span>, otherwise set <span 
class="ec-lmri-10x-x-109">dx(j) = p.dx(j) </span>for integrated dimensions
and <span 
class="ec-lmri-10x-x-109">dx(j) = 0 </span>for non-integrated dimensions.
<!--l. 5810--><p class="indent" >  If the input array is fourier transformed by using the <span 
class="ec-lmri-10x-x-109">p.transforms </span>attribute, one must set
<span 
class="ec-lmri-10x-x-109">dx(j) = p.dk(j) </span>for transformed dimensions <span 
class="ec-lmri-10x-x-109">j</span>, to get correct results. If the <span 
class="ec-lmri-10x-x-109">dx </span>vector is omitted,
the integral is over all available space dimensions, assuming no Fourier transforms. The
optional input <span 
class="ec-lmri-10x-x-109">bounds </span>is an array of size <span 
class="ec-lmri-10x-x-109">[p.dimensions,2]</span>, which specifies lower and upper
integration bounds in each direction. This is only available if <span 
class="ec-lmri-10x-x-109">dx </span>is input. If omitted,
integration is over the whole domain.
<!--l. 5819--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">9.7</span>  <a 
 id="x1-2150009.7"></a>Arrays and indices</h3>
<!--l. 5821--><p class="noindent" >Knowing the details of array indexing inside xSPDE isn’t usually necessary. Yet it becomes
important if you want to write your own functions to extend xSPDE, interface xSPDE with
other functions, or read and write xSPDE data files with external programs. It also helps to
understand how the program works.
<!--l. 5827--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.7.1</span>  <a 
 id="x1-2160009.7.1"></a>Array tables</h4>
<!--l. 5829--><p class="noindent" >There are two main internal xSPDE arrays:, <span 
class="ec-lmri-10x-x-109">fields </span>labelled \(a\) and output <span 
class="ec-lmri-10x-x-109">data </span>labelled \(d\). The
<span 
class="ec-lmri-10x-x-109">fields </span>contain stochastic variables, the <span 
class="ec-lmri-10x-x-109">data </span>contains the averaged outputs and errors
estimates.
                                                                                
                                                                                
<!--l. 5834--><p class="indent" >  Important array and index definitions are:<br 
class="newline" />
<div class="center" 
>
<!--l. 5836--><p class="noindent" >
<div class="tabular"> <table id="TBL-10" class="tabular" 
 
><colgroup id="TBL-10-1g"><col 
id="TBL-10-1"></colgroup><colgroup id="TBL-10-2g"><col 
id="TBL-10-2"></colgroup><colgroup id="TBL-10-3g"><col 
id="TBL-10-3"></colgroup><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-10-1-"><td  style="white-space:nowrap; text-align:center;" id="TBL-10-1-1"  
class="td11">   Label    </td>
              <td  style="white-space:nowrap; text-align:center;" id="TBL-10-1-2"  
class="td11">Indices</td>
                       <td  style="white-space:nowrap; text-align:center;" id="TBL-10-1-3"  
class="td11">            Description                   </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-10-2-"><td  style="white-space:nowrap; text-align:center;" id="TBL-10-2-1"  
class="td11">     \(a\)     </td>
              <td  style="white-space:nowrap; text-align:center;" id="TBL-10-2-2"  
class="td11">   \(\left [f,\mathbf {i},e\right ]\)   </td>
                       <td  style="white-space:nowrap; text-align:center;" id="TBL-10-2-3"  
class="td11">        Stochastic field array             </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-10-3-"><td  style="white-space:nowrap; text-align:center;" id="TBL-10-3-1"  
class="td11">     <span 
class="ec-lmri-10x-x-109">v       </span></td>
              <td  style="white-space:nowrap; text-align:center;" id="TBL-10-3-2"  
class="td11">   \(\left [m_{1},\mathbf {i},e\right ]\)   </td>
                       <td  style="white-space:nowrap; text-align:center;" id="TBL-10-3-3"  
class="td11">     Initial random variable array        </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-10-4-"><td  style="white-space:nowrap; text-align:center;" id="TBL-10-4-1"  
class="td11">     <span 
class="ec-lmri-10x-x-109">w       </span></td>
              <td  style="white-space:nowrap; text-align:center;" id="TBL-10-4-2"  
class="td11">   \(\left [m_{2},\mathbf {i},e\right ]\)   </td>
                       <td  style="white-space:nowrap; text-align:center;" id="TBL-10-4-3"  
class="td11">          Noise field array                </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-10-5-"><td  style="white-space:nowrap; text-align:center;" id="TBL-10-5-1"  
class="td11"> <span 
class="ec-lmri-10x-x-109">r</span><span 
class="ec-lmri-10x-x-109">{2</span><span 
class="ec-lmri-10x-x-109">},k</span><span 
class="ec-lmri-10x-x-109">{2</span><span 
class="ec-lmri-10x-x-109">}.... </span></td>
              <td  style="white-space:nowrap; text-align:center;" id="TBL-10-5-2"  
class="td11">   \((1,\mathbf {i},1)\)   </td>
                       <td  style="white-space:nowrap; text-align:center;" id="TBL-10-5-3"  
class="td11">Numbered space/momentum coordinates</td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-10-6-"><td  style="white-space:nowrap; text-align:center;" id="TBL-10-6-1"  
class="td11"><span 
class="ec-lmri-10x-x-109">x,y,z,kx,ky,kz</span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-10-6-2"  
class="td11">   \((1,\mathbf {i},1)\)   </td><td  style="white-space:nowrap; text-align:center;" id="TBL-10-6-3"  
class="td11"> Labelled space/momentum coordinates </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-10-7-"><td  style="white-space:nowrap; text-align:center;" id="TBL-10-7-1"  
class="td11">     \(o\)     </td><td  style="white-space:nowrap; text-align:center;" id="TBL-10-7-2"  
class="td11">   \(\{n\}(\ell ,\mathbf {j})\)   </td><td  style="white-space:nowrap; text-align:center;" id="TBL-10-7-3"  
class="td11">   Cell array of all observed averages    </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-10-8-"><td  style="white-space:nowrap; text-align:center;" id="TBL-10-8-1"  
class="td11">     \(d\)     </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-10-8-2"  
class="td11">   \(\{s\}\{n\}(\ell ,\mathbf {j},c)\)   </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-10-8-3"  
class="td11">     Cell array of data with errors        </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-10-9-"><td  style="white-space:nowrap; text-align:center;" id="TBL-10-9-1"  
class="td11">     \(rawdata\)     </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-10-9-2"  
class="td11">   \(\{s,c,h\}(f,\mathbf {j},e)\)   </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-10-9-3"  
class="td11">          Raw trajectories                </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-10-10-"><td  style="white-space:nowrap; text-align:center;" id="TBL-10-10-1"  
class="td11">     \(points\)     </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-10-10-2"  
class="td11">   \(\left [pt_{1},pt_{2}\ldots pt_{d}\right ]\)   </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-10-10-3"  
class="td11">        Vector of lattice sizes:             </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-10-11-"><td  style="white-space:nowrap; text-align:center;" id="TBL-10-11-1"  
class="td11">     \(fields\)     </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-10-11-2"  
class="td11">   \(\left [f_{1},f_{2},f_{3}\right ]\)   </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-10-11-3"  
class="td11">      Vector of field components:         </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-10-12-"><td  style="white-space:nowrap; text-align:center;" id="TBL-10-12-1"  
class="td11">     \(ensembles\)     </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-10-12-2"  
class="td11">   \(\left [e,h_{1},h_{2}\right ]\)   </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-10-12-3"  
class="td11">       Vector of ensemble sizes:           </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-10-13-"><td  style="white-space:nowrap; text-align:center;" id="TBL-10-13-1"  
class="td11">           </td></tr></table></div>
</div>
<!--l. 5867--><p class="indent" >  Here:
<ul class="itemize1">     
<li class="itemize">
<!--l. 5869--><p class="noindent" >\(f\) is the field index (combines \(f_{1},f_{2}\))
</li>     
<li class="itemize">
<!--l. 5870--><p class="noindent" >\(\mathbf {i}\) is the space index
</li>     
<li class="itemize">
<!--l. 5871--><p class="noindent" >\(e\) is the vector ensemble index
</li>     
<li class="itemize">
<!--l. 5872--><p class="noindent" >\(\mathbf {m}\) is the random or noise index
</li>     
<li class="itemize">
<!--l. 5873--><p class="noindent" >\(\mathbf {j}=[j_{1},\mathbf {i}]\) is the space-time index
</li>     
<li class="itemize">
<!--l. 5874--><p class="noindent" >\(\ell \) is the line index
                                                                                
                                                                                
     
</li>
<li class="itemize">     
<!--l. 5875--><p class="noindent" >\(n\) is the observe and/or function index
</li>     
<li class="itemize">
<!--l. 5876--><p class="noindent" >\(h\) is the high-level ensemble index (combines \(h_{1},h_{2}\))
</li>     
<li class="itemize">
<!--l. 5877--><p class="noindent" >\(s\) is the sequence index
</li>     
<li class="itemize">
<!--l. 5878--><p class="noindent" >\(c\) is the check index</li></ul>
<!--l. 5880--><p class="noindent" >When fields are passed to <span 
class="ec-lmri-10x-x-109">observe</span>, defined fields (\(f_{3}\)) are added as well. Apart from the first
dimension, the common dimensionality for internal arrays used in computations is
\(d.lattice=[d.space,ensembles(1)]\).
<!--l. 5884--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.7.2</span>  <a 
 id="x1-2170009.7.2"></a>Simulation data in xSIM</h4>
<!--l. 5886--><p class="noindent" >In xSIM, the space-time dimension \(d\) is unlimited, although xGRAPH can only plot up to three
chosen axes at a time. All fields are stored in real or complex numerical arrays of rank \(1+d\).
Average results are stored are stored in real or complex numerical arrays of rank
\(2+d\).
<!--l. 5892--><p class="indent" >  The array index ordering in xSPDE integrated fields is \((f,\mathbf {i},e)\), where:
<ul class="itemize1">     
<li class="itemize">
<!--l. 5895--><p class="noindent" >The first index is a field index \(f\).
</li>     
<li class="itemize">
<!--l. 5896--><p class="noindent" >The next \(d-1\) indices are \(\mathbf {i}\), which is a space index with no time index.
</li>     
<li class="itemize">
<!--l. 5898--><p class="noindent" >The last is an ensemble index \(e\), to store low-level parallel trajectories.</li></ul>
<!--l. 5900--><p class="noindent" >The array index ordering in graphical averaged data is \((\ell ,\mathbf {j},c)\)where:
                                                                                
                                                                                
     
<ul class="itemize1">
<li class="itemize">     
<!--l. 5902--><p class="noindent" >The first index is a line index \(\ell \).
</li>     
<li class="itemize">
<!--l. 5903--><p class="noindent" >The next \(d\) indices are \(\mathbf {j}=\left [j_{1},\ldots j_{d}\right ]=\left [j,\mathbf {i}\right ]\), for time <span 
class="ec-lmri-10x-x-109">and </span>space.
</li>     
<li class="itemize">
<!--l. 5905--><p class="noindent" >The last is a check index \(c\), for comparisons and errors.</li></ul>
<!--l. 5907--><p class="noindent" >Stored data uses heterogenous cell arrays to package numerical arrays with additional high level
indices. The first cell index is the sequence index, \(s\). Inside a sequence, data cell arrays
have a graph index \(n\). This distinguishes the different averages generated for output
graphs and data. Raw data has cell indices for the sequence, time-step and high level
ensembles.
<!--l. 5914--><p class="indent" >  In summary, the xSPDE internal arrays are as follows:
<ul class="itemize1">     
<li class="itemize">
<!--l. 5916--><p class="noindent" ><span 
class="ec-lmbx-10x-x-109">Field </span>arrays \(a(f,\mathbf {i},e)\) - these have a field index, a space index and low-level ensemble index
     
\(e\).
</li>     
<li class="itemize">
<!--l. 5918--><p class="noindent" ><span 
class="ec-lmbx-10x-x-109">Random </span>and <span 
class="ec-lmbx-10x-x-109">noise </span>arrays \(w(r,\mathbf {i},e)\) - these are initial random fields or noise fields. The
first index may have a different range to the field index.
</li>     
<li class="itemize">
<!--l. 5921--><p class="noindent" ><span 
class="ec-lmbx-10x-x-109">Coordinate </span>arrays \(x(1,\mathbf {i})\) - these contain the coordinates at grid-points, with labels \(x,y,z\), and \(j_{1}=1\).
Numeric labels \(x\{l\}\) are used for \(d&gt;4\), where \(l=2,\ldots d\). The same sizes are used for:
<ul class="itemize2">          
<li class="itemize">
<!--l. 5926--><p class="noindent" >momentum coordinates \(kx,ky,kz\) (alternatively \(k\{2\},k\{3\},\ldots \))
</li>          
<li class="itemize">
<!--l. 5927--><p class="noindent" >spectral derivative arrays \(Dx,Dy,Dz\) (alternatively \(D\{2\},D\{3\},\ldots \)) .</li></ul>
</li>     
<li class="itemize">
                                                                                
                                                                                
     
<!--l. 5930--><p class="noindent" ><span 
class="ec-lmbx-10x-x-109">Raw data </span>arrays \(r\{s,c,h\}(f,\mathbf {j},e)\) - these are cell arrays of generated trajectories. They are optional, as
they use large amounts of memory. These are saved in cell arrays with indices \(s\) for the
sequence, \(c\) for the time-step error-check and \(h\) for high level ensemble index. The cell
indices are:
<ul class="itemize2">          
<li class="itemize">
<!--l. 5936--><p class="noindent" >\(s=1,\ldots S\) for the sequence number,
</li>          
<li class="itemize">
<!--l. 5937--><p class="noindent" >\(c=1,2\) for the error-checking time-step used, first coarse then fine,
</li>          
<li class="itemize">
<!--l. 5939--><p class="noindent" >\(h=1,\ldots ensemble(2)*ensemble(3)\) for a high level parallel and serial ensemble index.</li></ul>
</li>     
<li class="itemize">
<!--l. 5942--><p class="noindent" ><span 
class="ec-lmbx-10x-x-109">Observe </span>data arrays \(o\{n\}(\ell ,\mathbf {j})\) - these are generated in xSIM by the observe functions, then used
to store generated average data at all time points. The cell index \(n\) is the <span 
class="ec-lmri-10x-x-109">observe </span>index,
which indexes overs the observe functions.The internal index \(\ell \) is a <span 
class="ec-lmri-10x-x-109">line </span>index generated
by an observe function.
</li>     
<li class="itemize">
<!--l. 5947--><p class="noindent" ><span 
class="ec-lmbx-10x-x-109">Graphics </span>data arrays \(g\{s\}\{n\}(\ell ,\mathbf {j},c))\) - these store the final results. Check indices are added to store
error estimates and comparisons, where \(c=1\) for the average, \(c=2\) for the time-step error, and \(c=3\)
for the sampling error. If there is comparison data, it uses \(c=4\) up to \(c=6\), to allow for error bars.
Graphics cell data uses cell indices \(\{s\}\) for the <span 
class="ec-lmri-10x-x-109">sequence </span>index, and \(\{n\}\) for the <span 
class="ec-lmri-10x-x-109">graph </span>index.
This is just the index of the observe function, unless changed internally by an xSIM
<span 
class="ec-lmri-10x-x-109">function</span>.</li></ul>
<!--l. 5957--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">9.8</span>  <a 
 id="x1-2180009.8"></a>Internal parameter table</h3>
<!--l. 5959--><p class="noindent" >The internal parameter structures in xSPDE are available to the user if required.
Internally, all xSPDE parameters are stored in the parameter structures passed to
functions. This includes the data given above from the input structures. In addition,
it includes the computed parameters given below, which includes internal array
dimensions.
                                                                                
                                                                                
<!--l. 5965--><p class="indent" >  Data in \(k-\)space is stored in two alternative lattices, each having their own axis
vectors. The propagation grid is used while propagating, and is compatible with
numerical FFT conventions where the first index value is \(k=0\). The graphics grid is
centered around \(k=0\), and is used for graphics and data storage, following scientific
conventions.
<!--l. 5971--><p class="indent" >  For more than four total dimensions, the spatial grid, momentum grid and derivative grid
notation of \(t,x,y,z\)<span 
class="ec-lmri-10x-x-109">,</span> \(\omega ,kx,ky,kz\) and \(Dx,Dy,Dz\) is changed to use numerical labels that correspond to the dimension
numbers, i.e., \(D\{2\},\dots D\{d\}\), \(r\{1\},\dots r\{d\}\), \(k\{1\},\dots k\{d\}\).
<!--l. 5977--><p class="indent" >  Numeric dimension labeling can also be used even for lower dimensionality if
preferred.
<div class="tabular"> <table id="TBL-11" class="tabular" 
 
><colgroup id="TBL-11-1g"><col 
id="TBL-11-1"></colgroup><colgroup id="TBL-11-2g"><col 
id="TBL-11-2"></colgroup><colgroup id="TBL-11-3g"><col 
id="TBL-11-3"></colgroup><colgroup id="TBL-11-4g"><col 
id="TBL-11-4"></colgroup><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-11-1-"><td  style="white-space:nowrap; text-align:center;" id="TBL-11-1-1"  
class="td11">  Label   </td>
            <td  style="white-space:nowrap; text-align:center;" id="TBL-11-1-2"  
class="td11">    Type      </td>
                           <td  style="white-space:nowrap; text-align:center;" id="TBL-11-1-3"  
class="td11"> Typical value </td>
                                            <td  style="white-space:nowrap; text-align:center;" id="TBL-11-1-4"  
class="td11">              Description                      </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-11-2-"><td  style="white-space:nowrap; text-align:center;" id="TBL-11-2-1"  
class="td11">    \(t,x,y,z\)    </td>
            <td  style="white-space:nowrap; text-align:center;" id="TBL-11-2-2"  
class="td11">    array      </td>
                           <td  style="white-space:nowrap; text-align:center;" id="TBL-11-2-3"  
class="td11">      <span 
class="ec-lmri-10x-x-109">-         </span></td>
                                            <td  style="white-space:nowrap; text-align:center;" id="TBL-11-2-4"  
class="td11">           Space-time grid of \(t,x,y,z\)                 </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-11-3-"><td  style="white-space:nowrap; text-align:center;" id="TBL-11-3-1"  
class="td11">    \(\omega ,kx,ky,kz\)    </td>
            <td  style="white-space:nowrap; text-align:center;" id="TBL-11-3-2"  
class="td11">    array      </td>
                           <td  style="white-space:nowrap; text-align:center;" id="TBL-11-3-3"  
class="td11">      <span 
class="ec-lmri-10x-x-109">-         </span></td>
                                            <td  style="white-space:nowrap; text-align:center;" id="TBL-11-3-4"  
class="td11">      Frequency-momentum grid of \(k_{x},k_{y},k_{z}\)         </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-11-4-"><td  style="white-space:nowrap; text-align:center;" id="TBL-11-4-1"  
class="td11">    \(Dx,Dy,Dz\)    </td>
            <td  style="white-space:nowrap; text-align:center;" id="TBL-11-4-2"  
class="td11">    array      </td>
                           <td  style="white-space:nowrap; text-align:center;" id="TBL-11-4-3"  
class="td11">      <span 
class="ec-lmri-10x-x-109">-         </span></td>
                                            <td  style="white-space:nowrap; text-align:center;" id="TBL-11-4-4"  
class="td11">           Derivative grid of \(D_{x},D_{y},D_{z}\)                 </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-11-5-"><td  style="white-space:nowrap; text-align:center;" id="TBL-11-5-1"  
class="td11">    \(r\{1\},\ldots r\{d\}\)    </td>
            <td  style="white-space:nowrap; text-align:center;" id="TBL-11-5-2"  
class="td11">    array      </td>
                           <td  style="white-space:nowrap; text-align:center;" id="TBL-11-5-3"  
class="td11">      <span 
class="ec-lmri-10x-x-109">-         </span></td>
                                            <td  style="white-space:nowrap; text-align:center;" id="TBL-11-5-4"  
class="td11">           Space-time grid of \(r_{1},\ldots r_{d}\)                 </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-11-6-"><td  style="white-space:nowrap; text-align:center;" id="TBL-11-6-1"  
class="td11">    \(k\{1\},\ldots k\{d\}\)    </td>
            <td  style="white-space:nowrap; text-align:center;" id="TBL-11-6-2"  
class="td11">    array      </td>
                           <td  style="white-space:nowrap; text-align:center;" id="TBL-11-6-3"  
class="td11">      <span 
class="ec-lmri-10x-x-109">-         </span></td>
                                            <td  style="white-space:nowrap; text-align:center;" id="TBL-11-6-4"  
class="td11">      Graphics momentum grid of \(k_{1},\ldots k_{d}\)          </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-11-7-"><td  style="white-space:nowrap; text-align:center;" id="TBL-11-7-1"  
class="td11">    \(D\{2\},\ldots D\{d\}\)    </td>
            <td  style="white-space:nowrap; text-align:center;" id="TBL-11-7-2"  
class="td11">    array      </td>
                           <td  style="white-space:nowrap; text-align:center;" id="TBL-11-7-3"  
class="td11">      <span 
class="ec-lmri-10x-x-109">-         </span></td>
                                            <td  style="white-space:nowrap; text-align:center;" id="TBL-11-7-4"  
class="td11">           Derivative grid of \(D_{2},\ldots D_{d}\)                 </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-11-8-"><td  style="white-space:nowrap; text-align:center;" id="TBL-11-8-1"  
class="td11">   <span 
class="ec-lmri-10x-x-109">dx     </span></td>
            <td  style="white-space:nowrap; text-align:center;" id="TBL-11-8-2"  
class="td11">    vector      </td>
                           <td  style="white-space:nowrap; text-align:center;" id="TBL-11-8-3"  
class="td11">    <span 
class="ec-lmri-10x-x-109">[0.2,..]      </span></td>
                                            <td  style="white-space:nowrap; text-align:center;" id="TBL-11-8-4"  
class="td11">               Steps in \([t,x,y,z]\)                       </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-11-9-"><td  style="white-space:nowrap; text-align:center;" id="TBL-11-9-1"  
class="td11">   <span 
class="ec-lmri-10x-x-109">dk     </span></td>
            <td  style="white-space:nowrap; text-align:center;" id="TBL-11-9-2"  
class="td11">    vector      </td>
                           <td  style="white-space:nowrap; text-align:center;" id="TBL-11-9-3"  
class="td11">   <span 
class="ec-lmri-10x-x-109">[0.61,....]    </span></td>
                                            <td  style="white-space:nowrap; text-align:center;" id="TBL-11-9-4"  
class="td11">               Steps in \([\omega ,k_{x},k_{y},k_{z}]\)                       </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-11-10-"><td  style="white-space:nowrap; text-align:center;" id="TBL-11-10-1"  
class="td11">    <span 
class="ec-lmri-10x-x-109">dt     </span></td>
            <td  style="white-space:nowrap; text-align:center;" id="TBL-11-10-2"  
class="td11">   double     </td>
                           <td  style="white-space:nowrap; text-align:center;" id="TBL-11-10-3"  
class="td11">    <span 
class="ec-lmri-10x-x-109">0.2000      </span></td>
                                            <td  style="white-space:nowrap; text-align:center;" id="TBL-11-10-4"  
class="td11">           Output time-step                  </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-11-11-"><td  style="white-space:nowrap; text-align:center;" id="TBL-11-11-1"  
class="td11">   <span 
class="ec-lmri-10x-x-109">dtr     </span></td>
            <td  style="white-space:nowrap; text-align:center;" id="TBL-11-11-2"  
class="td11">   double     </td>
                           <td  style="white-space:nowrap; text-align:center;" id="TBL-11-11-3"  
class="td11">    <span 
class="ec-lmri-10x-x-109">0.1000      </span></td>
                                            <td  style="white-space:nowrap; text-align:center;" id="TBL-11-11-4"  
class="td11">        Computational time-step             </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-11-12-"><td  style="white-space:nowrap; text-align:center;" id="TBL-11-12-1"  
class="td11">    <span 
class="ec-lmri-10x-x-109">v      </span></td>
            <td  style="white-space:nowrap; text-align:center;" id="TBL-11-12-2"  
class="td11">     real       </td>
                           <td  style="white-space:nowrap; text-align:center;" id="TBL-11-12-3"  
class="td11">      <span 
class="ec-lmri-10x-x-109">1         </span></td>
                                            <td  style="white-space:nowrap; text-align:center;" id="TBL-11-12-4"  
class="td11">         Spatial lattice volume               </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-11-13-"><td  style="white-space:nowrap; text-align:center;" id="TBL-11-13-1"  
class="td11">   <span 
class="ec-lmri-10x-x-109">kv     </span></td>
            <td  style="white-space:nowrap; text-align:center;" id="TBL-11-13-2"  
class="td11">     real       </td>
                           <td  style="white-space:nowrap; text-align:center;" id="TBL-11-13-3"  
class="td11">      <span 
class="ec-lmri-10x-x-109">1         </span></td>
                                            <td  style="white-space:nowrap; text-align:center;" id="TBL-11-13-4"  
class="td11">        Momentum lattice volume            </td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-11-14-"><td  style="white-space:nowrap; text-align:center;" id="TBL-11-14-1"  
class="td11"> <span 
class="ec-lmri-10x-x-109">dv </span></td>
            <td  style="white-space:nowrap; text-align:center;" id="TBL-11-14-2"  
class="td11">     real       </td>
                           <td  style="white-space:nowrap; text-align:center;" id="TBL-11-14-3"  
class="td11">      <span 
class="ec-lmri-10x-x-109">1         </span></td>
                                            <td  style="white-space:nowrap; text-align:center;" id="TBL-11-14-4"  
class="td11">           Spatial cell volume                 </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-11-15-"><td  style="white-space:nowrap; text-align:center;" id="TBL-11-15-1"  
class="td11">   <span 
class="ec-lmri-10x-x-109">dkv     </span></td>
            <td  style="white-space:nowrap; text-align:center;" id="TBL-11-15-2"  
class="td11">     real       </td>
                           <td  style="white-space:nowrap; text-align:center;" id="TBL-11-15-3"  
class="td11">      <span 
class="ec-lmri-10x-x-109">1         </span></td>
                                            <td  style="white-space:nowrap; text-align:center;" id="TBL-11-15-4"  
class="td11">         Momentum cell volume              </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-11-16-"><td  style="white-space:nowrap; text-align:center;" id="TBL-11-16-1"  
class="td11">  <span 
class="ec-lmri-10x-x-109">xc</span><span 
class="ec-lmri-10x-x-109">{d</span><span 
class="ec-lmri-10x-x-109">}   </span></td>
            <td  style="white-space:nowrap; text-align:center;" id="TBL-11-16-2"  
class="td11">cells of vectors</td>
                           <td  style="white-space:nowrap; text-align:center;" id="TBL-11-16-3"  
class="td11">   <span 
class="ec-lmri-10x-x-109">[-5,... 5]     </span></td>
                                            <td  style="white-space:nowrap; text-align:center;" id="TBL-11-16-4"  
class="td11">          Coordinate axes in \(t,x,y,z\)                </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-11-17-"><td  style="white-space:nowrap; text-align:center;" id="TBL-11-17-1"  
class="td11">  <span 
class="ec-lmri-10x-x-109">kc</span><span 
class="ec-lmri-10x-x-109">{d</span><span 
class="ec-lmri-10x-x-109">}   </span></td>
            <td  style="white-space:nowrap; text-align:center;" id="TBL-11-17-2"  
class="td11">cells of vectors</td>
                           <td  style="white-space:nowrap; text-align:center;" id="TBL-11-17-3"  
class="td11">    <span 
class="ec-lmri-10x-x-109">[-5,..5]      </span></td>
                                            <td  style="white-space:nowrap; text-align:center;" id="TBL-11-17-4"  
class="td11">            Graphics axes in\([\omega ,k_{x},k_{y},k_{z}]\)                  </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-11-18-"><td  style="white-space:nowrap; text-align:center;" id="TBL-11-18-1"  
class="td11">  <span 
class="ec-lmri-10x-x-109">kcp</span><span 
class="ec-lmri-10x-x-109">{d</span><span 
class="ec-lmri-10x-x-109">}   </span></td>
            <td  style="white-space:nowrap; text-align:center;" id="TBL-11-18-2"  
class="td11">cells of vectors</td>
                           <td  style="white-space:nowrap; text-align:center;" id="TBL-11-18-3"  
class="td11">    <span 
class="ec-lmri-10x-x-109">[0,...]      </span></td>
                                            <td  style="white-space:nowrap; text-align:center;" id="TBL-11-18-4"  
class="td11">          Propagation axes in\([\omega ,k_{x},k_{y},k_{z}]\)                </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-11-19-"><td  style="white-space:nowrap; text-align:center;" id="TBL-11-19-1"  
class="td11">   <span 
class="ec-lmri-10x-x-109">s.dx    </span></td>
            <td  style="white-space:nowrap; text-align:center;" id="TBL-11-19-2"  
class="td11">   double     </td>
                           <td  style="white-space:nowrap; text-align:center;" id="TBL-11-19-3"  
class="td11">      1         </td>
                                            <td  style="white-space:nowrap; text-align:center;" id="TBL-11-19-4"  
class="td11">      Initial stochastic normalization         </td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-11-20-"><td  style="white-space:nowrap; text-align:center;" id="TBL-11-20-1"  
class="td11"> <span 
class="ec-lmri-10x-x-109">s.dxt </span></td>
            <td  style="white-space:nowrap; text-align:center;" id="TBL-11-20-2"  
class="td11">   double     </td><td  style="white-space:nowrap; text-align:center;" id="TBL-11-20-3"  
class="td11">    <span 
class="ec-lmri-10x-x-109">3.1623      </span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-11-20-4"  
class="td11">   Propagating stochastic normalization     </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-11-21-"><td  style="white-space:nowrap; text-align:center;" id="TBL-11-21-1"  
class="td11">   <span 
class="ec-lmri-10x-x-109">s.dk    </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-21-2"  
class="td11">   double     </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-21-3"  
class="td11">      1         </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-21-4"  
class="td11">     Initial k stochastic normalization       </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-11-22-"><td  style="white-space:nowrap; text-align:center;" id="TBL-11-22-1"  
class="td11">  <span 
class="ec-lmri-10x-x-109">s.dkt    </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-22-2"  
class="td11">   double     </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-22-3"  
class="td11">    <span 
class="ec-lmri-10x-x-109">3.1623      </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-22-4"  
class="td11">  Propagating k stochastic normalization   </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-11-23-"><td  style="white-space:nowrap; text-align:center;" id="TBL-11-23-1"  
class="td11">  <span 
class="ec-lmri-10x-x-109">nspace   </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-23-2"  
class="td11">   integer     </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-23-3"  
class="td11">      35         </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-23-4"  
class="td11">     Number of spatial lattice points        </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-11-24-"><td  style="white-space:nowrap; text-align:center;" id="TBL-11-24-1"  
class="td11"> <span 
class="ec-lmri-10x-x-109">nlattice  </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-24-2"  
class="td11">   integer     </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-24-3"  
class="td11">     3500       </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-24-4"  
class="td11">   Total lattice: <span 
class="ec-lmri-10x-x-109">ensembles(1) x n.space     </span></td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-11-25-"><td  style="white-space:nowrap; text-align:center;" id="TBL-11-25-1"  
class="td11"> <span 
class="ec-lmri-10x-x-109">ncopies  </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-25-2"  
class="td11">   integer     </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-25-3"  
class="td11">      20         </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-25-4"  
class="td11">       <span 
class="ec-lmri-10x-x-109">ensembles(2) x ensembles(3)          </span></td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-11-26-"><td  style="white-space:nowrap; text-align:center;" id="TBL-11-26-1"  
class="td11"><span 
class="ec-lmri-10x-x-109">inrandoms</span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-26-2"  
class="td11">    vector      </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-26-3"  
class="td11">     [2,0]       </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-26-4"  
class="td11">     Number of initial random fields        </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-11-27-"><td  style="white-space:nowrap; text-align:center;" id="TBL-11-27-1"  
class="td11">  <span 
class="ec-lmri-10x-x-109">noises   </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-27-2"  
class="td11">    vector      </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-27-3"  
class="td11">     [2,0]       </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-27-4"  
class="td11">         Number of noise fields               </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-11-28-"><td  style="white-space:nowrap; text-align:center;" id="TBL-11-28-1"  
class="td11"> <span 
class="ec-lmri-10x-x-109">d.space  </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-28-2"  
class="td11">    vector      </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-28-3"  
class="td11">   <span 
class="ec-lmri-10x-x-109">[35, 35]     </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-28-4"  
class="td11"> Space dimensions: [points(2), points(3), ...] </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-11-29-"><td  style="white-space:nowrap; text-align:center;" id="TBL-11-29-1"  
class="td11"> <span 
class="ec-lmri-10x-x-109">d.lattice  </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-29-2"  
class="td11">    vector      </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-29-3"  
class="td11">    <span 
class="ec-lmri-10x-x-109">[1, 1]      </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-29-4"  
class="td11"> Lattice dimensions: [d.space, ensembles(1)] </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-11-30-"><td  style="white-space:nowrap; text-align:center;" id="TBL-11-30-1"  
class="td11">   <span 
class="ec-lmri-10x-x-109">d.a     </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-30-2"  
class="td11">    vector      </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-30-3"  
class="td11">    <span 
class="ec-lmri-10x-x-109">[1, 1]      </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-30-4"  
class="td11">          Dimensions for \(a\) field                </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-11-31-"><td  style="white-space:nowrap; text-align:center;" id="TBL-11-31-1"  
class="td11">   <span 
class="ec-lmri-10x-x-109">d.r     </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-31-2"  
class="td11">    vector      </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-31-3"  
class="td11">    <span 
class="ec-lmri-10x-x-109">[1, 1]      </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-31-4"  
class="td11">       Dimensions for coordinates           </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-11-32-"><td  style="white-space:nowrap; text-align:center;" id="TBL-11-32-1"  
class="td11"> <span 
class="ec-lmri-10x-x-109">d.fields  </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-32-2"  
class="td11">    vector      </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-32-3"  
class="td11">    <span 
class="ec-lmri-10x-x-109">[1, 1]      </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-32-4"  
class="td11">   Dimensions for \(a\) field (including time)    </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-11-33-"><td  style="white-space:nowrap; text-align:center;" id="TBL-11-33-1"  
class="td11"> <span 
class="ec-lmri-10x-x-109">d.aplus  </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-33-2"  
class="td11">    vector      </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-33-3"  
class="td11">   <span 
class="ec-lmri-10x-x-109">[1, 1, 1]     </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-33-4"  
class="td11">Dimensions for integrated plus defined fields</td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-11-34-"><td  style="white-space:nowrap; text-align:center;" id="TBL-11-34-1"  
class="td11">   <span 
class="ec-lmri-10x-x-109">d.k     </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-34-2"  
class="td11">    vector      </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-34-3"  
class="td11">   <span 
class="ec-lmri-10x-x-109">[0, 1, 1]     </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-34-4"  
class="td11">     Dimensions for noise transforms        </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-11-35-"><td  style="white-space:nowrap; text-align:center;" id="TBL-11-35-1"  
class="td11">  <span 
class="ec-lmri-10x-x-109">d.obs   </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-35-2"  
class="td11">    vector      </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-35-3"  
class="td11">    <span 
class="ec-lmri-10x-x-109">[1, 35]      </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-35-4"  
class="td11">       Dimensions for observations           </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-11-36-"><td  style="white-space:nowrap; text-align:center;" id="TBL-11-36-1"  
class="td11">  <span 
class="ec-lmri-10x-x-109">d.data   </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-36-2"  
class="td11">    vector      </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-36-3"  
class="td11">   <span 
class="ec-lmri-10x-x-109">[1, 35, 3]    </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-36-4"  
class="td11">       Dimensions for average data           </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-11-37-"><td  style="white-space:nowrap; text-align:center;" id="TBL-11-37-1"  
class="td11">  <span 
class="ec-lmri-10x-x-109">d.raw   </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-37-2"  
class="td11">    vector      </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-37-3"  
class="td11"><span 
class="ec-lmri-10x-x-109">[1, 51, 35, 100]</span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-11-37-4"  
class="td11">        Dimensions for raw data             </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-11-38-"><td  style="white-space:nowrap; text-align:center;" id="TBL-11-38-1"  
class="td11">         </td>
</tr></table></div>
<!--l. 6059--><p class="noindent" >
                                                                                
                                                                                
  
<h3 class="sectionHead"><span class="titlemark">9.9</span>  <a 
 id="x1-2190009.9"></a>xSIM overall structure</h3>
<!--l. 6061--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.9.1</span>  <a 
 id="x1-2200009.9.1"></a>xSPDE</h4>
<!--l. 6063--><p class="noindent" >The control program, \(xspde\), calls the <span 
class="ec-lmri-10x-x-109">xsim </span>integration and <span 
class="ec-lmri-10x-x-109">xgraph </span>graphics functions
successively
<!--l. 6072--><p class="indent" >  \[ \mathbf {xspde}\rightarrow \begin {cases} \begin {array}{c} \mathbf {xsim}\,\,(simulations)\\ \mathbf {xgraph}\,\,(graphics) \end {array}\end {cases} \]
<!--l. 6075--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">9.9.2</span>  <a 
 id="x1-2210009.9.2"></a>xSIM</h4>
<!--l. 6077--><p class="noindent" >The integration function, \(xsim\), generates all data. It first carries out elementary checks in
<span 
class="ec-lmri-10x-x-109">xpreferences </span>and constructs the grid of lattice points in <span 
class="ec-lmri-10x-x-109">xlattice</span>. Then it generates the nested
ensembles in <span 
class="ec-lmri-10x-x-109">xensemble</span>, and integrates each subensemble using <span 
class="ec-lmri-10x-x-109">xpath</span>. The output data is
written to files, if required, in <span 
class="ec-lmri-10x-x-109">xwrite</span>.
<!--l. 6088--><p class="indent" >  \begin {align*}  \mathbf {xsim} &amp; \rightarrow \mathbf {xpreferences}\rightarrow \mathbf {xlattice}\,\,(checks\,inputs)\\ &amp; \rightarrow \mathbf {xensemble}\leftrightarrow \mathbf {xpath}\leftrightarrow \mathbf {xdata}\,\,(simulates)\\ &amp; \rightarrow \mathbf {xwrite}\,\,\,\,(stores\,data)  \end {align*}
<!--l. 6090--><p class="indent" >
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
  
<h2 class="chapterHead"><span class="titlemark">10</span>  <a 
 id="x1-22200010"></a>xGRAPH reference</h2>
<!--l. 6095--><p class="noindent" ><span 
class="ec-lmbxi-10x-x-109">This section gives a reference explanation of the available graphics parameters</span>
<span 
class="ec-lmbxi-10x-x-109">and functions.</span>
  
<h3 class="sectionHead"><span class="titlemark">10.1</span>  <a 
 id="x1-22300010.1"></a>Overview</h3>
<!--l. 6099--><p class="noindent" >The graphics function provided is a general purpose multidimensional batch graphics code,
xGRAPH, which is called by xSPDE when xSIM is finished. The results are graphed and
output if required. Alternatively, xGRAPH can be replaced by another graphics code,
or it can be used to process the data generated by the xSIM function at a later
time.
<!--l. 6105--><p class="indent" >  The <span 
class="ec-lmri-10x-x-109">xgraph </span>function call syntax is:
<ul class="itemize1">     
<li class="itemize">
<!--l. 6107--><p class="noindent" ><span 
class="ec-lmbxi-10x-x-109">xgraph (data [,input])</span></li></ul>
<!--l. 6109--><p class="noindent" >This takes simulation <span 
class="ec-lmri-10x-x-109">data </span>and <span 
class="ec-lmri-10x-x-109">input </span>cell arrays, then plots graphs. The <span 
class="ec-lmri-10x-x-109">data </span>should have as
many cells as there are <span 
class="ec-lmri-10x-x-109">input </span>cells, for sequences.
<!--l. 6113--><p class="indent" >  If <span 
class="ec-lmri-10x-x-109">data = ’filename.h5’ </span>or <span 
class="ec-lmri-10x-x-109">’filename.mat’</span>, the specified file is read both for <span 
class="ec-lmri-10x-x-109">input </span>and <span 
class="ec-lmri-10x-x-109">data</span>.
Here <span 
class="ec-lmri-10x-x-109">.h5 </span>indicates an HDF5 file, and <span 
class="ec-lmri-10x-x-109">.mat </span>indicates a Matlab file.
<!--l. 6117--><p class="indent" >  When the <span 
class="ec-lmri-10x-x-109">data </span>input is a filename, parameters in the file can be replaced by new
<span 
class="ec-lmri-10x-x-109">input </span>parameters that are specified, if present. Any stored <span 
class="ec-lmri-10x-x-109">input </span>in the file is then
overwritten when graphs are generated. This allows graphs of data to be modified
retrospectively.
<!--l. 6123--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">10.1.1</span>  <a 
 id="x1-22400010.1.1"></a>Parameter and data structures</h4>
<!--l. 6125--><p class="noindent" >This is a batch graphics function, intended to process quantities of graphics data, input as a
cell array of multi-dimensional data. Theoretical and/or experimental data is passed to the
graphics program, including the complete <span 
class="ec-lmri-10x-x-109">data </span>cell array and a cell array of graphics
parameters for plotting each graph.
<!--l. 6131--><p class="indent" >  To explain xGRAPH in full detail,
<ul class="itemize1">     
<li class="itemize">
<!--l. 6133--><p class="noindent" >Data to be graphed are recorded sequentially in the <span 
class="ec-lmri-10x-x-109">data </span>cell array.
</li>     
<li class="itemize">
<!--l. 6135--><p class="noindent" >Graphics parameters including defaults are given in the <span 
class="ec-lmri-10x-x-109">input </span>cell array.
                                                                                
                                                                                
     
</li>
<li class="itemize">     
<!--l. 6137--><p class="noindent" >This describes a sequence of graph sets, so that <span 
class="ec-lmri-10x-x-109">input=</span><span 
class="ec-lmri-10x-x-109">{x1,x2,...</span><span 
class="ec-lmri-10x-x-109">}</span>.
</li>     
<li class="itemize">
<!--l. 6138--><p class="noindent" >For a one member sequence, the structure can be used on its own.
</li>     
<li class="itemize">
<!--l. 6139--><p class="noindent" >Each structure <span 
class="ec-lmri-10x-x-109">x1,x2,... </span>describes a set of graphs.</li></ul>
<!--l. 6141--><p class="noindent" >The data input to <span 
class="ec-lmri-10x-x-109">xGRAPH </span>can either come from a file, or from data generated directly with
<span 
class="ec-lmri-10x-x-109">xSIM</span>. The main graphics data is a nested cell array, which contains numerical graphics arrays,
each defining one independent set of averaged data, the observed data averages, stored
in a cell array indexed as \(d\{s\}\{n\}(\ell ,\mathbf {j},c)\). It also requires a cell array of structures of graphics
parameters.
<!--l. 6148--><p class="indent" >  The output is unlimited, apart from memory limits. The program also generates error
comparisons and chi-squared values if required. The data structure for input is as
follows:
<ol  class="enumerate1" >
<li 
  class="enumerate" id="x1-224002x1">     
<!--l. 6152--><p class="noindent" >The input <span 
class="ec-lmri-10x-x-109">data </span>is a cell array of <span 
class="ec-lmri-10x-x-109">datasets, </span>which can be collapsed to a single dataset
</li>
<li 
  class="enumerate" id="x1-224004x2">     
<!--l. 6154--><p class="noindent" >The <span 
class="ec-lmri-10x-x-109">parameters </span>are also a cell array of parameter structures, which can be collapsed
or omitted
</li>
<li 
  class="enumerate" id="x1-224006x3">     
<!--l. 6156--><p class="noindent" >The  <span 
class="ec-lmri-10x-x-109">dataset  </span>is  a  cell  array  of  multidimensional  <span 
class="ec-lmri-10x-x-109">graphs</span>,  each  with  arbitrary
dimensionality.
</li>
<li 
  class="enumerate" id="x1-224008x4">     
<!--l. 6158--><p class="noindent" >Each <span 
class="ec-lmri-10x-x-109">graph </span>is an array that can generate multiple plots, defined by the parameters.
                                                                                
                                                                                
     
</li>
<li 
  class="enumerate" id="x1-224010x5">     
<!--l. 6160--><p class="noindent" >The first index of each graph allows multiple lines, with different line-styles
</li>
<li 
  class="enumerate" id="x1-224012x6">     
<!--l. 6162--><p class="noindent" >The last index of each graph array can optionally be used for error and comparison
fields.</li></ol>
<!--l. 6166--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">10.2</span>  <a 
 id="x1-22500010.2"></a>Parameter table</h3>
<!--l. 6168--><p class="noindent" >The complete cell array of the simulation data is passed to the \(xgraph\) program, along
with graphics parameters for each observable, to create an extended graphics data
structure.
<!--l. 6172--><p class="indent" >  Some \(xgraph\) parameters are global parameters for all graphs. However, most \(xgraph\) parameters are cell
arrays by graph index, which replace the global parameters like labels. These graphics
parameters are individually set for each output that is plotted, using the cell index \(\{n\}\) in a curly
bracket.
<!--l. 6178--><p class="indent" >  If a graph index is omitted, and the parameter is not a nested cell array, the program will
set an identical value for all graphs.
<!--l. 6181--><p class="indent" >  The <span 
class="ec-lmri-10x-x-109">axes</span>, <span 
class="ec-lmri-10x-x-109">glabels, legends, lines, logs, </span>and <span 
class="ec-lmri-10x-x-109">xfunctions </span>of each graph are nested cell arrays, as
there can be any number of axes and lines. Graphics defaults are user-modifiable by editing
the <span 
class="ec-lmri-10x-x-109">xgpreferences </span>function. In the case of the <span 
class="ec-lmri-10x-x-109">logs </span>switch, the observable axis is treated as an
extra dimension.
<!--l. 6187--><p class="indent" >  The plotted result can be an arbitrary function of the generated average data, by using the
optional input <span 
class="ec-lmri-10x-x-109">gfunction. </span>If this is omitted, the generated average data that is input is
plotted.
<!--l. 6191--><p class="indent" >  Comparisons are plotted if present in the input data indexed by the last error index with \(e&gt;errors\),
where \(errors=3\) in all data generated by xSIM.<br 
class="newline" />
                                                                                
                                                                                
  
<div class="tabular"> <table id="TBL-12" class="tabular" 
 
><colgroup id="TBL-12-1g"><col 
id="TBL-12-1"></colgroup><colgroup id="TBL-12-2g"><col 
id="TBL-12-2"></colgroup><colgroup id="TBL-12-3g"><col 
id="TBL-12-3"></colgroup><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-12-1-"><td  style="white-space:nowrap; text-align:center;" id="TBL-12-1-1"  
class="td11">    Label      </td>
                       <td  style="white-space:nowrap; text-align:center;" id="TBL-12-1-2"  
class="td11">       Default value            </td>
                                                                  <td  style="white-space:nowrap; text-align:center;" id="TBL-12-1-3"  
class="td11">              Description                      </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-12-2-"><td  style="white-space:nowrap; text-align:center;" id="TBL-12-2-1"  
class="td11">   <span 
class="ec-lmri-10x-x-109">axes</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}     </span></td>
                     <td  style="white-space:nowrap; text-align:center;" id="TBL-12-2-2"  
class="td11">           {0,..}                 </td>
                                                                  <td  style="white-space:nowrap; text-align:center;" id="TBL-12-2-3"  
class="td11">        Points plotted for each axis            </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-12-3-"><td  style="white-space:nowrap; text-align:center;" id="TBL-12-3-1"  
class="td11"> <span 
class="ec-lmri-10x-x-109">chisqplot</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}  </span></td>
                     <td  style="white-space:nowrap; text-align:center;" id="TBL-12-3-2"  
class="td11">            0                    </td>
                                                                  <td  style="white-space:nowrap; text-align:center;" id="TBL-12-3-3"  
class="td11">         Chi-square plot options               </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-12-4-"><td  style="white-space:nowrap; text-align:center;" id="TBL-12-4-1"  
class="td11">    <span 
class="ec-lmri-10x-x-109">cutoff      </span></td>
                     <td  style="white-space:nowrap; text-align:center;" id="TBL-12-4-2"  
class="td11">          1.e-12                </td>
                                                                  <td  style="white-space:nowrap; text-align:center;" id="TBL-12-4-3"  
class="td11">     Global lower cutoff for chi-squares       </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-12-5-"><td  style="white-space:nowrap; text-align:center;" id="TBL-12-5-1"  
class="td11">  <span 
class="ec-lmri-10x-x-109">cutoffs</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}   </span></td>
                     <td  style="white-space:nowrap; text-align:center;" id="TBL-12-5-2"  
class="td11">          <span 
class="ec-lmri-10x-x-109">cutoff                </span></td>
                                                              <td  style="white-space:nowrap; text-align:center;" id="TBL-12-5-3"  
class="td11">     Probability cutoff for n-th graph         </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-12-6-"><td  style="white-space:nowrap; text-align:center;" id="TBL-12-6-1"  
class="td11">  <span 
class="ec-lmri-10x-x-109">diffplot</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}   </span></td>
                     <td  style="white-space:nowrap; text-align:center;" id="TBL-12-6-2"  
class="td11">            0                    </td>
                                                                  <td  style="white-space:nowrap; text-align:center;" id="TBL-12-6-3"  
class="td11">    Comparison difference plot options       </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-12-7-"><td  style="white-space:nowrap; text-align:center;" id="TBL-12-7-1"  
class="td11">    <span 
class="ec-lmri-10x-x-109">errors     </span></td>
                     <td  style="white-space:nowrap; text-align:center;" id="TBL-12-7-2"  
class="td11">            0                    </td>
                                                                  <td  style="white-space:nowrap; text-align:center;" id="TBL-12-7-3"  
class="td11">      Index of last error field in <span 
class="ec-lmri-10x-x-109">data         </span></td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-12-8-"><td  style="white-space:nowrap; text-align:center;" id="TBL-12-8-1"  
class="td11"> <span 
class="ec-lmri-10x-x-109">esample</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">} </span></td>
                     <td  style="white-space:nowrap; text-align:center;" id="TBL-12-8-2"  
class="td11">            1                    </td>
                                                                  <td  style="white-space:nowrap; text-align:center;" id="TBL-12-8-3"  
class="td11">     Size and type of sampling errorbar       </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-12-9-"><td  style="white-space:nowrap; text-align:center;" id="TBL-12-9-1"  
class="td11">   <span 
class="ec-lmri-10x-x-109">font</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}     </span></td>
                     <td  style="white-space:nowrap; text-align:center;" id="TBL-12-9-2"  
class="td11">            18                   </td>
                                                                  <td  style="white-space:nowrap; text-align:center;" id="TBL-12-9-3"  
class="td11">        Font size for graph labels             </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-12-10-"><td  style="white-space:nowrap; text-align:center;" id="TBL-12-10-1"  
class="td11"> <span 
class="ec-lmri-10x-x-109">gfunction</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">} </span></td>
                     <td  style="white-space:nowrap; text-align:center;" id="TBL-12-10-2"  
class="td11">        @(d,~) d{n}            </td>
                                                                  <td  style="white-space:nowrap; text-align:center;" id="TBL-12-10-3"  
class="td11">        Functions of graphics data             </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-12-11-"><td  style="white-space:nowrap; text-align:center;" id="TBL-12-11-1"  
class="td11">  <span 
class="ec-lmri-10x-x-109">glabels</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}   </span></td>
                     <td  style="white-space:nowrap; text-align:center;" id="TBL-12-11-2"  
class="td11">      <span 
class="ec-lmri-10x-x-109">{’t’ ,’x’ ,’y’ ,’z’</span><span 
class="ec-lmri-10x-x-109">}         </span></td>
                                                              <td  style="white-space:nowrap; text-align:center;" id="TBL-12-11-3"  
class="td11">        Graph-specific axis labels             </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-12-12-"><td  style="white-space:nowrap; text-align:center;" id="TBL-12-12-1"  
class="td11">   <span 
class="ec-lmri-10x-x-109">graphs     </span></td>
                     <td  style="white-space:nowrap; text-align:center;" id="TBL-12-12-2"  
class="td11">             \([1:max]\)             </td>
                                          <td  style="white-space:nowrap; text-align:center;" id="TBL-12-12-3"  
class="td11">     Vector of all the required graphs         </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-12-13-"><td  style="white-space:nowrap; text-align:center;" id="TBL-12-13-1"  
class="td11">  <span 
class="ec-lmri-10x-x-109">gsqplot</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}   </span></td>
                     <td  style="white-space:nowrap; text-align:center;" id="TBL-12-13-2"  
class="td11">            0                    </td>
                                                                  <td  style="white-space:nowrap; text-align:center;" id="TBL-12-13-3"  
class="td11">     G-square (likelihood) plot options        </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-12-14-"><td  style="white-space:nowrap; text-align:center;" id="TBL-12-14-1"  
class="td11">  <span 
class="ec-lmri-10x-x-109">headers</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}   </span></td>
                     <td  style="white-space:nowrap; text-align:center;" id="TBL-12-14-2"  
class="td11">            ”                    </td>
                                                                  <td  style="white-space:nowrap; text-align:center;" id="TBL-12-14-3"  
class="td11">             Graph headers                    </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-12-15-"><td  style="white-space:nowrap; text-align:center;" id="TBL-12-15-1"  
class="td11">  <span 
class="ec-lmri-10x-x-109">images</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}   </span></td>
                     <td  style="white-space:nowrap; text-align:center;" id="TBL-12-15-2"  
class="td11">            0                    </td>
                                                                  <td  style="white-space:nowrap; text-align:center;" id="TBL-12-15-3"  
class="td11">         Number of movie images              </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-12-16-"><td  style="white-space:nowrap; text-align:center;" id="TBL-12-16-1"  
class="td11"> <span 
class="ec-lmri-10x-x-109">imagetype</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">} </span></td>
                     <td  style="white-space:nowrap; text-align:center;" id="TBL-12-16-2"  
class="td11">            0                    </td>
                                                                  <td  style="white-space:nowrap; text-align:center;" id="TBL-12-16-3"  
class="td11">            Type of 3D image                  </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-12-17-"><td  style="white-space:nowrap; text-align:center;" id="TBL-12-17-1"  
class="td11">    <span 
class="ec-lmri-10x-x-109">klabels     </span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-12-17-2"  
class="td11"><span 
class="ec-lmri-10x-x-109">{’</span><span 
class="ec-lmri-10x-x-109">\omega’ ,’k</span><span 
class="ec-lmri-10x-x-109">_x’ ,’k</span><span 
class="ec-lmri-10x-x-109">_y’ ,’k</span><span 
class="ec-lmri-10x-x-109">_z’...</span><span 
class="ec-lmri-10x-x-109">}</span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-12-17-3"  
class="td11">      Global transformed axis labels          </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-12-18-"><td  style="white-space:nowrap; text-align:center;" id="TBL-12-18-1"  
class="td11">  <span 
class="ec-lmri-10x-x-109">legends</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}   </span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-12-18-2"  
class="td11">        {’label1’,..}             </td><td  style="white-space:nowrap; text-align:center;" id="TBL-12-18-3"  
class="td11">       Legends for multi-line graphs           </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-12-19-"><td  style="white-space:nowrap; text-align:center;" id="TBL-12-19-1"  
class="td11">  <span 
class="ec-lmri-10x-x-109">limits</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}    </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-12-19-2"  
class="td11">     <span 
class="ec-lmri-10x-x-109">{[lc1,uc1],[lc2,uc2]</span><span 
class="ec-lmri-10x-x-109">}       </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-12-19-3"  
class="td11">     Axis limits, first lower then upper        </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-12-20-"><td  style="white-space:nowrap; text-align:center;" id="TBL-12-20-1"  
class="td11">   <span 
class="ec-lmri-10x-x-109">lines</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}    </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-12-20-2"  
class="td11">          <span 
class="ec-lmri-10x-x-109">{’-’,..</span><span 
class="ec-lmri-10x-x-109">}               </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-12-20-3"  
class="td11">     Line types for multiline 2D graphs       </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-12-21-"><td  style="white-space:nowrap; text-align:center;" id="TBL-12-21-1"  
class="td11">   <span 
class="ec-lmri-10x-x-109">logs</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}     </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-12-21-2"  
class="td11">           {0,..}                 </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-12-21-3"  
class="td11">    Axis logarithmic switch: \(0\) linear, \(1\) log      </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-12-22-"><td  style="white-space:nowrap; text-align:center;" id="TBL-12-22-1"  
class="td11">  <span 
class="ec-lmri-10x-x-109">minbar</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}   </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-12-22-2"  
class="td11">           <span 
class="ec-lmri-10x-x-109">0.01                 </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-12-22-3"  
class="td11">        Minimum relative error-bar            </td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-12-23-"><td  style="white-space:nowrap; text-align:center;" id="TBL-12-23-1"  
class="td11"> <span 
class="ec-lmri-10x-x-109">mincount </span></td> 
<td  style="white-space:nowrap; text-align:center;" id="TBL-12-23-2"  
class="td11">            10                   </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-12-23-3"  
class="td11">    Global counts for chi-square cutoffs       </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-12-24-"><td  style="white-space:nowrap; text-align:center;" id="TBL-12-24-1"  
class="td11">    <span 
class="ec-lmri-10x-x-109">name      </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-12-24-2"  
class="td11">            ”                    </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-12-24-3"  
class="td11">          Global graph header                 </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-12-25-"><td  style="white-space:nowrap; text-align:center;" id="TBL-12-25-1"  
class="td11">  <span 
class="ec-lmri-10x-x-109">olabels</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}   </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-12-25-2"  
class="td11">           <span 
class="ec-lmri-10x-x-109">’a</span><span 
class="ec-lmri-10x-x-109">_1’                </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-12-25-3"  
class="td11">            Observable labels                  </td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-12-26-"><td  style="white-space:nowrap; text-align:center;" id="TBL-12-26-1"  
class="td11"><span 
class="ec-lmri-10x-x-109">pdimension</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}</span></td> 
<td  style="white-space:nowrap; text-align:center;" id="TBL-12-26-2"  
class="td11">            3                    </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-12-26-3"  
class="td11">        Maximum plot dimensions             </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-12-27-"><td  style="white-space:nowrap; text-align:center;" id="TBL-12-27-1"  
class="td11">   <span 
class="ec-lmri-10x-x-109">saveeps     </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-12-27-2"  
class="td11">            0                    </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-12-27-3"  
class="td11">      Switch, set to 1 to save eps files         </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-12-28-"><td  style="white-space:nowrap; text-align:center;" id="TBL-12-28-1"  
class="td11">   <span 
class="ec-lmri-10x-x-109">savefig     </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-12-28-2"  
class="td11">            0                    </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-12-28-3"  
class="td11">     Switch, set to 1 to save figure files       </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-12-29-"><td  style="white-space:nowrap; text-align:center;" id="TBL-12-29-1"  
class="td11">   <span 
class="ec-lmri-10x-x-109">scale</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}    </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-12-29-2"  
class="td11">            1                    </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-12-29-3"  
class="td11">    Scaling: Counts/ probability density      </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-12-30-"><td  style="white-space:nowrap; text-align:center;" id="TBL-12-30-1"  
class="td11"> <span 
class="ec-lmri-10x-x-109">transverse</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">} </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-12-30-2"  
class="td11">            0                    </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-12-30-3"  
class="td11">        Number of transverse plots            </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-12-31-"><td  style="white-space:nowrap; text-align:center;" id="TBL-12-31-1"  
class="td11"> <span 
class="ec-lmri-10x-x-109">xfunctions</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">} </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-12-31-2"  
class="td11">    <span 
class="ec-lmri-10x-x-109">{@(t,</span><span 
class="ec-lmri-10x-x-109">~) t,@(x,</span><span 
class="ec-lmri-10x-x-109">~) x,..</span><span 
class="ec-lmri-10x-x-109">}      </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-12-31-3"  
class="td11">          Axis transformations                </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-12-32-"><td  style="white-space:nowrap; text-align:center;" id="TBL-12-32-1"  
class="td11">   verbose     </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-12-32-2"  
class="td11">            0                    </td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-12-32-3"  
class="td11">0 for brief, 1 for informative, 2 for full output</td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-12-33-"><td  style="white-space:nowrap; text-align:center;" id="TBL-12-33-1"  
class="td11">    <span 
class="ec-lmri-10x-x-109">xlabels     </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-12-33-2"  
class="td11">     <span 
class="ec-lmri-10x-x-109">{’t’ ,’x’ ,’y’ ,’z’...</span><span 
class="ec-lmri-10x-x-109">}        </span></td>
<td  style="white-space:nowrap; text-align:center;" id="TBL-12-33-3"  
class="td11">            Global axis labels                  </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-12-34-"><td  style="white-space:nowrap; text-align:center;" id="TBL-12-34-1"  
class="td11">            </td> 
</tr></table></div> 
<ul class="itemize1">
<li class="itemize">     
<!--l. 6266--><p class="noindent" >Up to 6 types of input data can occur, including errors and comparisons, indexed
by the last index. The original mean data always has <span 
class="ec-lmri-10x-x-109">c =1</span>. If there are no errors
or comparisons, one graph is plotted for each dimensional reduction.
</li>     
<li class="itemize">
<!--l. 6270--><p class="noindent" >The input data has up to two error bars (I and II), and optional comparisons also
with up to two error bars.
</li>     
<li class="itemize">
<!--l. 6272--><p class="noindent" >Type (I) errors labeled \(c=2\) have standard vertical error bars. Type II error bars labeled
     
\(c=3\), usually standard deviation errors from sampling, have two solid lines.
</li>     
<li class="itemize">
                                                                                
                                                                                
     
<!--l. 6275--><p class="noindent" >If <span 
class="ec-lmri-10x-x-109">esample </span>= -1<span 
class="ec-lmri-10x-x-109">, </span>both error bars are combined and the RMS errors are plotted as
a single error bar.
</li>     
<li class="itemize">
<!--l. 6277--><p class="noindent" >If \(diffplot&gt;0\)<span 
class="ec-lmri-10x-x-109">, </span>differences are plotted as unnormalized (\(diffplot=1\)<span 
class="ec-lmri-10x-x-109">)</span>, or normalized (\(diffplot=2\)<span 
class="ec-lmri-10x-x-109">) </span>by the total RMS
errors. If \(diffplot=3\), raw comparison data is plotted.
</li>     
<li class="itemize">
<!--l. 6280--><p class="noindent" >When differences are plotted, the total comparison errors are treated as type (I)
error bars, while total simulation errors are treated as type (II) errors with parallel
lines in the graphs, to distinguish them.</li></ul>
<!--l. 6285--><p class="noindent" >A detailed description of each parameter is listed in Sec (<a 
href="#x1-23300010.7">10.7<!--tex4ht:ref: sec:Parameter-reference --></a>).
<!--l. 6287--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">10.3</span>  <a 
 id="x1-22600010.3"></a>Example</h3>
<!--l. 6289--><p class="noindent" >A simple example of data and input parameters, but without errors or comparisons is as
follows
<div class="center" 
>
<!--l. 6291--><p class="noindent" >
<div class="doublebox"><div class="minipage"><span 
class="ec-lmtt-10x-x-109">p.name = ’Sine and cosine functions’;</span>
<!--l. 6295--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.olabels = </span><span 
class="ec-lmtt-10x-x-109">{’sine(m</span><span 
class="ec-lmtt-10x-x-109">_1/100)’,’cosine(m</span><span 
class="ec-lmtt-10x-x-109">_1/100)’</span><span 
class="ec-lmtt-10x-x-109">};</span>
<!--l. 6297--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">data = </span><span 
class="ec-lmtt-10x-x-109">{sin([1:100*pi]/100),cos([1:100*pi]/100)</span><span 
class="ec-lmtt-10x-x-109">};</span>
<!--l. 6299--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">xgraph(data,p);</span>                                           </div></div>
</div>
<!--l. 6303--><p class="indent" >  <figure class="figure"> 

                                                                                
                                                                                
<a 
 id="x1-226001r1"></a>
                                                                                
                                                                                
<!--l. 6304--><p class="noindent" ><img 
src="xFIGURES/xGraphfig1.svg" alt="pict"  
 style="width:20.91278em;" > <img 
src="xFIGURES/xGraphfig2.svg" alt="pict"  
 style="width:20.91278em;" >
<figcaption class="caption" ><span class="id">Figure 10.1: </span><span  
class="content">Example: xgraph output of two plots</span></figcaption><!--tex4ht:label?: x1-226001r1 -->
                                                                                
                                                                                
<!--l. 6305--><p class="indent" >  </figure>
  
<h3 class="sectionHead"><span class="titlemark">10.4</span>  <a 
 id="x1-22700010.4"></a>xGRAPH data arrays</h3>
<!--l. 6310--><p class="noindent" >The data input to <span 
class="ec-lmri-10x-x-109">xGRAPH </span>can come from a file, or from data generated directly from any
compatible program.
<!--l. 6313--><p class="indent" >  The data is stored in a cell array \(data\) with structure: \[ data\{s\}\{n\}(\ell ,\mathbf {j},c) \] Each member of the outer cell array
<span 
class="ec-lmri-10x-x-109">data</span><span 
class="ec-lmri-10x-x-109">{s</span><span 
class="ec-lmri-10x-x-109">} </span>defines a number of related sets of graphical data, all described by common
parameters <span 
class="ec-lmri-10x-x-109">input</span><span 
class="ec-lmri-10x-x-109">{s</span><span 
class="ec-lmri-10x-x-109">}</span>. Comparisons and errors are plotted if there are errors and
comparison data in the input, indexed by <span 
class="ec-lmri-10x-x-109">c</span>. This generates comparison plots, as well
as error totals and \(\chi \)- squared error estimate when there are statistical variances
available.
<!--l. 6324--><p class="indent" >  An individual member of <span 
class="ec-lmri-10x-x-109">data</span><span 
class="ec-lmri-10x-x-109">{s</span><span 
class="ec-lmri-10x-x-109">}</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">} </span>is a multidimensional array, called a <span 
class="ec-lmri-10x-x-109">graph </span>in the
xSPDE User’s guide. For each <span 
class="ec-lmri-10x-x-109">graph</span>, multiple different plots with different dimensionality can
be obtained from the dataset <span 
class="ec-lmri-10x-x-109">data</span><span 
class="ec-lmri-10x-x-109">{s</span><span 
class="ec-lmri-10x-x-109">}</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}</span>, either through projections and slices or by
generating additional data defined with graphics functions. Either or both alternatives are
available.
<!--l. 6331--><p class="indent" >  Note that:
<ul class="itemize1">     
<li class="itemize">
<!--l. 6333--><p class="noindent" >If a sequence has one member, the outer cell array can be omitted.
</li>     
<li class="itemize">
<!--l. 6334--><p class="noindent" >In this simplified case, if there is only one <span 
class="ec-lmri-10x-x-109">graph </span>array, the inner cell array can be
omitted.</li></ul>
<!--l. 6337--><p class="noindent" >The graphics data for a single dataset is held in a multidimensional real array, where:
<ul class="itemize1">     
<li class="itemize">
<!--l. 6340--><p class="noindent" >\(\ell \) is the index for lines in the graph. Even for one line, the first dimension is retained.
</li>     
<li class="itemize">
<!--l. 6342--><p class="noindent" >\(\mathbf {j}=j_{1},\ldots j_{d}\) is the array index in each dimension, where \(d\ge 1\).
</li>     
<li class="itemize">
<!--l. 6344--><p class="noindent" >Averages in momentum space have the momentum origin as the central index.
</li>     
<li class="itemize">
                                                                                
                                                                                
     
<!--l. 6346--><p class="noindent" >If integrals or spatial averages are used, the corresponding dimension has one index
     
\(j_{d}=1\).
</li>     
<li class="itemize">
<!--l. 6348--><p class="noindent" >With probabilities, extra dimensions are added to \(\mathbf {j}\) to store the bin indices.
</li>     
<li class="itemize">
<!--l. 6350--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">c  </span>indexes  error-checks  and  comparisons  in  the  data.  If  not  present,  the  last
dimension is omitted.
</li>     
<li class="itemize">
<!--l. 6352--><p class="noindent" >If \(c&gt;p.errors\), the extra fields are comparison inputs, where \(p.errors=0\) is the default.</li></ul>
<!--l. 6355--><p class="noindent" >When the optional comparison fields are used, an input parameter \(errors\) is required to indicate the
maximum error index, to distinguish data from comparisons. Parameter structures
from xSIM have \(errors=3\) set to allow for both sampling errors and discretization errors. If
this is omitted, the default is \(errors=0\), which implies that there is no error or comparison
data
<!--l. 6362--><p class="indent" >  If \(errors&gt;0\), the last index can have larger values with \(c&gt;errors\), for comparisons. The special case of \(errors=1\) is used
if the data has no error bars, but there are comparisons in the data. Larger indices are used to
index the comparison data, which can also have two types of errors. The largest usable last
index is \(errors+3\).
<!--l. 6368--><p class="indent" >  It is possible to directly plot the <span 
class="ec-lmri-10x-x-109">raw </span>data using xGRAPH. One can even combine the raw
data with a graphics parameter input. But since the raw data has no error estimates - it is raw
data - one must set \(p.errors=0\), since the xsim output parameters have a default of \(p.errors=3\). This will give a
single trajectory.
<!--l. 6374--><p class="indent" >  However, the raw data from a simulation typically includes many trajectories if \(ensembles(1)&gt;0\), and then
one must select particular trajectory datasets from the raw cell array, to plot just
one.
<!--l. 6378--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">10.4.1</span>  <a 
 id="x1-22800010.4.1"></a>Input parameters and defaults</h4>
<!--l. 6380--><p class="noindent" >A sequence of graph parameters is obtained from inputs in a cell array, as <span 
class="ec-lmri-10x-x-109">input = </span><span 
class="ec-lmri-10x-x-109">{in1, in2,</span>
<span 
class="ec-lmri-10x-x-109">...</span><span 
class="ec-lmri-10x-x-109">}</span>. The input parameters of each simulation in the sequence are specified in a Matlab
structure. The inputs are numbers, vectors, strings, functions and cell arrays. All metadata has
preferred values, so only changes from the preferences need to be input. The resulting data is
stored internally as a sequence of structures in a cell array, to describe the simulation
sequence.
                                                                                
                                                                                
<!--l. 6388--><p class="indent" >  The graphics parameters are also stored in the cell array <span 
class="ec-lmri-10x-x-109">input </span>as a sequence of structures <span 
class="ec-lmri-10x-x-109">p.</span>
This only need to be input when the graphs are generated and can be changed at a later
time to alter the graphics output. A sequence of simulations is graphed from <span 
class="ec-lmri-10x-x-109">input</span>
specifications.
<!--l. 6394--><p class="indent" >  If there is one simulation, just one structure can be input, without the sequence braces. The
standard way to input each parameter value is:
<!--l. 6400--><p class="indent" >  \[ p.label=parameter \]
<!--l. 6402--><p class="indent" >  The standard way to input a function handle is:
<!--l. 6406--><p class="indent" >  \[ p.label=@function \]
<!--l. 6408--><p class="indent" >  The inputs are scalar or vector parameters or function handles. Quantities relating to
graphed averages are cell arrays, indexed by the graph number. The available inputs, with
their default values in brackets, are given below.
<!--l. 6413--><p class="indent" >  Simulation metadata, including default values that were used in a particular simulation,
can be included in the input data files. This is done in both the <span 
class="ec-lmri-10x-x-109">.mat </span>and the <span 
class="ec-lmri-10x-x-109">.h5</span>
output files generated by xSIM, so the entire graphics input can be reconstructed or
changed.
<!--l. 6418--><p class="indent" >  Parameters can be numbers, vectors, strings or cell arrays. Conventions that are used are
that: 
<ul class="itemize1">
<li class="itemize">     
<!--l. 6421--><p class="noindent" >All input parameters have default values
</li>     
<li class="itemize">
<!--l. 6422--><p class="noindent" >Vector inputs of numbers are enclosed in square brackets, <span 
class="ec-lmri-10x-x-109">[...]</span>.
</li>     
<li class="itemize">
<!--l. 6423--><p class="noindent" >Cell arrays of strings, functions or vectors are enclosed in curly brackets.
</li>     
<li class="itemize">
<!--l. 6425--><p class="noindent" >Vector or cell array inputs with only one member don’t require brackets.
</li>     
<li class="itemize">
<!--l. 6426--><p class="noindent" >Incomplete parameter inputs are completed with the last used default value.
</li>     
<li class="itemize">
<!--l. 6428--><p class="noindent" >Function definitions can be handles pointing elsewhere, or defined inline.</li></ul>
                                                                                
                                                                                

<!--l. 6431--><p class="noindent" >If any inputs are omitted, there are default values which are set by the internal function
<span 
class="ec-lmri-10x-x-109">xgpreferences</span>. The defaults can be changed by editing <span 
class="ec-lmri-10x-x-109">xgpreferences</span>.
<!--l. 6435--><p class="indent" >  In the following descriptions, <span 
class="ec-lmri-10x-x-109">graphs </span>is the total number of graphed variables of all types.
The space coordinate, image, image-type and transverse data can be omitted if there is no
spatial lattice, that is, if the dimension variable is set to one.
<!--l. 6440--><p class="indent" >  For uniformity, the graphics parameters that reference an individual data object are cell
arrays. These are indexed over the graph number using braces <span 
class="ec-lmri-10x-x-109">{</span><span 
class="ec-lmri-10x-x-109">}</span>. If a different type of input
is used, like a scalar or matrix, xSPDE will attempt to convert the type to a cell
array.
<!--l. 6446--><p class="indent" >  Axis labels are cell arrays, indexed over dimension. The graph number used to index these
cell arrays refers to the data object. In each case there can be multiple generated plots,
depending on the graphics input.
<!--l. 6451--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">10.5</span>  <a 
 id="x1-22900010.5"></a>xGRAPH output graphs</h3>
<!--l. 6453--><p class="noindent" >This routine automatically generates a default range of graphs, but this can be modified to
suit the user.
<!--l. 6456--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">10.5.1</span>  <a 
 id="x1-23000010.5.1"></a>Plot dimensions</h4>
<!--l. 6458--><p class="noindent" >The <span 
class="ec-lmri-10x-x-109">pdimension </span>input sets the maximum plotted dimensions. For example, \(pdimension\{1\}=1\) means that only
plots vs \(r_{1}\) are output for the first function plotted. Default values are used for the non-plotted
dimensions, unless there are axes specified, as indicated below.
<!--l. 6464--><p class="indent" >  The graphs cascade down from higher to lower dimensions, generating different types of
graphs. Each type of graph is generated once for each function index.
<!--l. 6468--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">10.5.2</span>  <a 
 id="x1-23100010.5.2"></a>Plot axes</h4>
<!--l. 6470--><p class="noindent" >The graphics axes that are used for plotting and the points plotted are defined using the
optional <span 
class="ec-lmri-10x-x-109">axes </span>input parameters, where \(axes\{n\}\) indicates the <span 
class="ec-lmri-10x-x-109">n</span>-th specified graph or set of generated
graph data.
<!--l. 6475--><p class="indent" >  If there are no <span 
class="ec-lmri-10x-x-109">axes </span>inputs, or the <span 
class="ec-lmri-10x-x-109">axes </span>inputs are zero - for example, \(axes\{1\}=\{0,0,0\}\) - only the
lowest dimensions are plotted, up to <span 
class="ec-lmri-10x-x-109">3</span>. If either the data or <span 
class="ec-lmri-10x-x-109">axes </span>inputs project
one point in a given dimension, - for example, \(axes\{1\}=\{0,31,-1,0\}\), this dimension is suppressed in
the plots, which reduces the effective dimension of the data - in this case to two
dimensions.
                                                                                
                                                                                
<!--l. 6482--><p class="indent" >  Examples:
<ul class="itemize1">     
<li class="itemize">
<!--l. 6484--><p class="noindent" >\(axes\{1\}=\{0\}\) -  For  function  1,  plot  all  the  first  dimensional  points;  higher  dimensions  get
defaults.
</li>     
<li class="itemize">
<!--l. 6486--><p class="noindent" >\(axes\{2\}=\{-2,0\}\)  -  For  function  2,  plot  the  maximum  value  of  \(r_{1}\)  (the  default)  and  all
higher-dimensional x-points.
</li>     
<li class="itemize">
<!--l. 6488--><p class="noindent" >\(axes\{3\}=\{1:4:51,32,64\}\) - For function 3, plot every 4-th \(x_{1}\) point at \(x_{2}\) point 32, \(x_{3}\) point 64
</li>     
<li class="itemize">
<!--l. 6490--><p class="noindent" >\(axes\{4\}=\{0,2:4:48,0\}\) - For function 4, plot every \(x_{1}\) point , every 4-th \(x_{2}\) point, and all \(x_{3}\)-points.</li></ul>
<!--l. 6493--><p class="noindent" >Points labelled \(-1\) indicates a default ‘typical’ point, which is the midpoint. If one uses \(-2\), this is the
last point.
<!--l. 6496--><p class="indent" >  Lower dimensions are replaced by corresponding higher dimensions if there are <span 
class="ec-lmri-10x-x-109">dimensions</span>
or <span 
class="ec-lmri-10x-x-109">axes </span>that are suppressed. Slices can be taken at any desired point, not just the midpoint.
The notation of \(axes\{1\}=\{6:3:81\}\), is used to modify the starting, interval, and finishing points for complete
control on the plot points.
<!--l. 6502--><p class="indent" >  The graphics results depend on the resulting <span 
class="ec-lmbx-10x-x-109">effective </span>dimension, which is equal to the
actual input data dimension unless there is an <span 
class="ec-lmri-10x-x-109">axes </span>suppression, described above. Since
the plot has to include a data axis, the plot itself will usually have an extra data
axis.
<!--l. 6508--><p class="indent" >  One can plot only three axes directly using standard graphics tools. The strategy to
deal with the higher effective dimensionality is as follows. For simplicity, “time” is
used to label the first effective dimension, although in fact any first dimension is
possible:
<dl class="description"><dt class="description">     
<!--l. 6513--><p class="noindent" >
<span 
class="ec-lmssbo-10x-x-109">dimensions</span><span 
class="ec-lmssbo-10x-x-109"> =</span><span 
class="ec-lmssbo-10x-x-109"> 1</span> 
</dt><dd 
class="description">
<!--l. 6513--><p class="noindent" >For one lattice dimension, a 2D plot of observable <span 
class="ec-lmri-10x-x-109">vs t </span>is plotted, with data at
each lattice point in time. Exact results, error bars and sampling error bounds are
included if available.
</dd>     
<dt class="description">
<!--l. 6517--><p class="noindent" >
<span 
class="ec-lmssbo-10x-x-109">dimensions</span><span 
class="ec-lmssbo-10x-x-109"> =</span><span 
class="ec-lmssbo-10x-x-109"> 2</span> 
</dt><dd 
class="description">
                                                                                
                                                                                
<!--l. 6517--><p class="noindent" >For two lattice dimensions, a 3D image of observable <span 
class="ec-lmri-10x-x-109">vs x,t </span>is plotted. A movie of
distinct 2D graphic plots is also possible. Otherwise, a slice through \(x=0\) is used tp
reduce the lattice dimension to \(1\).
</dd>     
<dt class="description">
<!--l. 6521--><p class="noindent" >
<span 
class="ec-lmssbo-10x-x-109">dimensions</span><span 
class="ec-lmssbo-10x-x-109"> =</span><span 
class="ec-lmssbo-10x-x-109"> 3</span> 
</dt><dd 
class="description">
<!--l. 6521--><p class="noindent" >For  three  lattice  dimensions,  if  \(images&gt;1\),  a  movie  of  distinct  3D  graphic  images  of
observables are plotted as \(images\) slices versus the first plot dimension. Otherwise, a slice
through the chosen point, is used at the highest dimension to reduce the lattice
dimension to \(2\).
</dd>     
<dt class="description">
<!--l. 6526--><p class="noindent" >
<span 
class="ec-lmssbo-10x-x-109">dimensions</span><span 
class="ec-lmssbo-10x-x-109"> </span><span 
class="ec-lmssbo-10x-x-109">&#x003E;</span><span 
class="ec-lmssbo-10x-x-109"> 3</span> 
</dt><dd 
class="description">
<!--l. 6526--><p class="noindent" >For  higher  lattice  dimensions,  a  slice  through  a  chosen  point,  or  the  default
midpoint is used to reduce the lattice dimension to \(3\).</dd></dl>
<!--l. 6530--><p class="noindent" >As explained above, in addition to graphs versus \(x_{1}\) the <span 
class="ec-lmbx-10x-x-109">xGRAPH </span>function can generate <span 
class="ec-lmri-10x-x-109">images</span>
(3D) and <span 
class="ec-lmri-10x-x-109">transverse </span>(2D) plots at specified points, up to a maximum given by the number of
points specified. The number of these can be individually specified for each graph number. The
images available are specified as <span 
class="ec-lmri-10x-x-109">imagetype</span>\(=1,\ldots 4\), giving:
<ol  class="enumerate1" >
<li 
  class="enumerate" id="x1-231002x1">     
<!--l. 6537--><p class="noindent" >3D perspective plots (Matlab <span 
class="ec-lmri-10x-x-109">surf </span>- the default)
</li>
<li 
  class="enumerate" id="x1-231004x2">     
<!--l. 6538--><p class="noindent" >2D filled color plots (Matlab <span 
class="ec-lmri-10x-x-109">contourf </span>)
</li>
<li 
  class="enumerate" id="x1-231006x3">     
<!--l. 6539--><p class="noindent" >contour plots (Matlab <span 
class="ec-lmri-10x-x-109">contour </span>)
</li>
<li 
  class="enumerate" id="x1-231008x4">     
<!--l. 6540--><p class="noindent" >pseudo-color plots (Matlab <span 
class="ec-lmri-10x-x-109">pcolor </span>)</li></ol>
                                                                                
                                                                                

<!--l. 6542--><p class="noindent" >Error bars, sampling errors and multiple lines for comparisons are only graphed for 2D plots.
Error-bars are not plotted when they are below a user-specified size, with a default of \(1\%\) of the
maximum range, to improve graphics quality. Higher dimensional graphs do not output
error-bar data, but they are still recorded in the data files.
<!--l. 6548--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">10.6</span>  <a 
 id="x1-23200010.6"></a>Probability and \(\chi ^{2}\) plots</h3>
<!--l. 6550--><p class="noindent" >Probability data can be input and plotted as usual. It is generated from the \(xsim\) and <span 
class="ec-lmri-10x-x-109">xqsim</span>
programs using the \(binranges\) data for binning. It is plotted like any other graph, with any
dimension.
<!--l. 6554--><p class="indent" >  In addition it is possible for the program to make a \(\chi ^{2}\) plot, which is a plot of the \(\chi ^{2}\) comparison
with a comparison probability density against space and/or time. This allows a test of the
simulated data against a known target probability distribution, provided that the following
input data conditions are satisfied:
<ul class="itemize1">     
<li class="itemize">
<!--l. 6560--><p class="noindent" >The input data dimension exceeds the p.<span 
class="ec-lmri-10x-x-109">dimensions </span>parameter,
</li>     
<li class="itemize">
<!--l. 6561--><p class="noindent" >The switch p.<span 
class="ec-lmri-10x-x-109">chisqplot </span>is set to \(1\)or 2, and
</li>     
<li class="itemize">
<!--l. 6562--><p class="noindent" >The input data includes comparison function data.</li></ul>
<!--l. 6564--><p class="noindent" >The \(\chi ^{2}\) plots, depending on \(p.chisqplot\) are:
<ol  class="enumerate1" >
<li 
  class="enumerate" id="x1-232002x1">     
<!--l. 6566--><p class="noindent" >a plot of \(\chi ^{2}\) and \(k\), where \(k\) is the number of valid data points,
</li>
<li 
  class="enumerate" id="x1-232004x2">     
<!--l. 6568--><p class="noindent" >a plot of \(\sqrt {2\chi ^{2}}\) and \(\sqrt {2k-1}\), which should have a unit variance.</li></ol>
<!--l. 6571--><p class="noindent" >Here, for one point in space and time, with \(m\) bins, \(N_{j}\) counts per bin and \(E_{j}\) expected counts:
\[ \chi ^{2}=\sum _{j=1}^{m}\frac {\left (N_{j}-E_{j}\right )^{2}}{E_{j}} \]
                                                                                
                                                                                
<!--l. 6577--><p class="indent" >  The number \(k\) is the number of valid counts, with \(N_{j},E_{j}&gt;mincount\). This is partly determined from the
requirement that the probability count data per bin is greater than the \(p.mincount\) parameter. The
default is set to give a number of samples \(&gt;10\). The program prints a summary that sums over of
all the \(\chi ^{2}\) data.
<!--l. 6583--><p class="indent" >  The \(p.scale\{n\}\) parameter gives the number of counts per bin at unit probability density. This is
needed to set the scale of the \(\chi ^{2}\) results, ie, \(N_{j}=scale\{n\}\times p_{j}\), where \(p_{j}\) is the probability density that is compared
and plotted in the simulation data. Note that a uniform bin size is assumed here, to give a
uniform scaling.
<!--l. 6590--><p class="indent" >  It can be useful to compare two probability distributions with different variances. For one
point in space and time, with \(m\) bins, \(p_{j}\) probability density and \(e_{j}\) expected probability density, \[ \chi ^{2}=\sum _{j=1}^{m}\frac {\left (p_{j}-e_{j}\right )^{2}}{\sigma _{j}^{2}+\sigma _{e,j}^{2}} \] In
this case, \(\sigma _{j}^{2}\) and \(\sigma _{e,j}^{2}\) are the sampling errors in the simulation data and comparison data, so that
built-in error fields in the data are used to work out the \(\chi ^{2}\) results. This option is chosen if \(p.scale\{n\}=0\), and
the cutoff for the data is then specified so that \(p_{j},e_{j}&gt;p.cutoffs\{n\}\). This only has a \(\chi ^{2}\) distribution if points are
independent.
<!--l. 6603--><p class="indent" >  It is also possible to plot the \(G^{2}\) or maximum likelihood plot of the data, which is
an alternative means to compare distributions, where \[ G^{2}=2\sum _{j=1}^{m}N_{j}\ln \left (N_{j}/E_{j}\right ) \] The expected values \(E_{j}\) are
automatically scaled so that \(\sum N_{j}=\sum E_{j},\)with the same minimum count cutoff that is used for the \(\chi ^{2}\)
data. The result is similar to the \(\chi ^{2}\) results. It is obtained if p.<span 
class="ec-lmri-10x-x-109">gsqplot </span>is set to \(1\)or 2
and requires for the input that \(p.scale\{n\}&gt;0.\) It is sometimes regarded as a preferred method for
comparisons.
<!--l. 6616--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">10.7</span>  <a 
 id="x1-23300010.7"></a>Parameter reference</h3>
<!--l. 6618--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">10.7.1</span>  <a 
 id="x1-23400010.7.1"></a><span 
class="ec-lmri-10x-x-109">axes</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}</span></h4>
<dl class="description"><dt class="description">     
<!--l. 6620--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 6620--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">{0,0,0,..</span><span 
class="ec-lmri-10x-x-109">}</span></dd></dl>
<!--l. 6622--><p class="noindent" >Gives the axis points plotted for the \(n\)-th plotted function, in each dimension. Each entry value is
a vector range for a particular plot and dimension. Thus, <span 
class="ec-lmri-10x-x-109">p = 5 </span>gives the fifth point only, and
a vector input <span 
class="ec-lmri-10x-x-109">p = 1:4:41 </span>plots every fourth point. Single points generate graphics
projections, allowing the other dimensions to be plotted. Zero or negative values are
shorthand. For example, <span 
class="ec-lmri-10x-x-109">p = -1 </span>generates a default point at the midpoint, <span 
class="ec-lmri-10x-x-109">p = -2 </span>the
endpoint, and <span 
class="ec-lmri-10x-x-109">p = 0 </span>is the default value that gives the vector for the every axis
                                                                                
                                                                                
point. For each graph type, i.e. <span 
class="ec-lmri-10x-x-109">n=1,..graphs </span>the axes can be individually specified
in each dimension, <span 
class="ec-lmri-10x-x-109">d=1,..dimension</span>s. If more than three axes are specified to be
vectors, only the first three are used, and others are set to default values in the
plots.
<dl class="description"><dt class="description">     
<!--l. 6635--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 6635--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.axes</span><span 
class="ec-lmri-10x-x-109">{4</span><span 
class="ec-lmri-10x-x-109">} = </span><span 
class="ec-lmri-10x-x-109">{1:2:10,0,0,-1</span><span 
class="ec-lmri-10x-x-109">}</span></dd></dl>
<!--l. 6638--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">10.7.2</span>  <a 
 id="x1-23500010.7.2"></a><span 
class="ec-lmri-10x-x-109">diffplot</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}</span></h4>
<dl class="description"><dt class="description">     
<!--l. 6640--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 6640--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">0</span></dd></dl>
<!--l. 6642--><p class="noindent" >Differences are plotted as a comparison dashed line on \(2D\) plots as a default. Otherwise, a separate
difference plot is obtained which is unnormalized (<span 
class="ec-lmri-10x-x-109">diffplot = 1)</span>, or normalized (<span 
class="ec-lmri-10x-x-109">diffplot = 2)</span>
by the total RMS errors. If <span 
class="ec-lmri-10x-x-109">diffplot = 3</span>, the comparison data is plotted directly as an
additional graph.
<dl class="description"><dt class="description">     
<!--l. 6648--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 6648--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.diffplot</span><span 
class="ec-lmri-10x-x-109">{3</span><span 
class="ec-lmri-10x-x-109">} = 2</span></dd></dl>
<!--l. 6651--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">10.7.3</span>  <a 
 id="x1-23600010.7.3"></a><span 
class="ec-lmri-10x-x-109">errors</span></h4>
<dl class="description"><dt class="description">     
<!--l. 6653--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 6653--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">0</span></dd></dl>
                                                                                
                                                                                

<!--l. 6655--><p class="noindent" >Indicates if the last index in the graphics input data arrays is used for errorbars and/or
comparisons. Should be set to zero if there is no error or comparison data. If non-zero, this will
give the highest last index used for errors. The standard <span 
class="ec-lmri-10x-x-109">xsim </span>output sets \(p.errors=3\) automatically.
As a special case, \(p.errors=1\) is used to indicate that there is comparison data but no error
data.
<!--l. 6662--><p class="indent" >  If \(p.errors&gt;0\) , the data indexed up to <span 
class="ec-lmri-10x-x-109">p.errors </span>gives the data, then a maximum of two types of error
bars. Up to three further index values, up to \(p.errors+3\)<span 
class="ec-lmri-10x-x-109">, </span>are available to index all comparison data and
its error fields. The maximum last index value used is \(6\).
<dl class="description"><dt class="description">     
<!--l. 6668--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 6668--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.errors = 2</span></dd></dl>
<!--l. 6671--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">10.7.4</span>  <a 
 id="x1-23700010.7.4"></a><span 
class="ec-lmri-10x-x-109">esample</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}</span></h4>
<dl class="description"><dt class="description">     
<!--l. 6673--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 6673--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">1</span></dd></dl>
<!--l. 6675--><p class="noindent" >This sets the type and size of sampling errors that are plotted. If <span 
class="ec-lmri-10x-x-109">esample = 0</span>, no
sampling error lines are plotted, just the mean. If \(esample=-n\), \(\pm n\sigma \) sampling errors are included
in the errorbars. If \(esample=n\), separate upper and lower \(\pm n\sigma \) sampling error lines are plotted.
In both cases, the magnitude of esample sets the number of standard deviations
used. 
<dl class="description"><dt class="description">
<!--l. 6682--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 6682--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.esample</span><span 
class="ec-lmri-10x-x-109">{3</span><span 
class="ec-lmri-10x-x-109">} = -1</span></dd></dl>
<!--l. 6685--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">10.7.5</span>  <a 
 id="x1-23800010.7.5"></a><span 
class="ec-lmri-10x-x-109">font</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}</span></h4>
                                                                                
                                                                                
     
<dl class="description"><dt class="description">
<!--l. 6687--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 6687--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">18</span></dd></dl>
<!--l. 6689--><p class="noindent" >This sets the default font sizes for the graph labels, indexed by graph. This can be changed per
graph.
<dl class="description"><dt class="description">     
<!--l. 6692--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 6692--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.font</span><span 
class="ec-lmri-10x-x-109">{4</span><span 
class="ec-lmri-10x-x-109">}=18</span></dd></dl>
<!--l. 6695--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">10.7.6</span>  <a 
 id="x1-23900010.7.6"></a><span 
class="ec-lmri-10x-x-109">functions</span></h4>
<dl class="description"><dt class="description">     
<!--l. 6697--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 6697--><p class="noindent" >number of functional transformations</dd></dl>
<!--l. 6699--><p class="noindent" >This gives the maximum number of output graph functions and is available to restrict graphical
output. The default is the length of the cell array of input data. Normally, the default will be
used. 
<dl class="description"><dt class="description">
<!--l. 6703--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 6703--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.functions = 10</span></dd></dl>
<!--l. 6706--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">10.7.7</span>  <a 
 id="x1-24000010.7.7"></a><span 
class="ec-lmri-10x-x-109">glabels</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}</span></h4>
<dl class="description"><dt class="description">     
<!--l. 6708--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 6708--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">xlabels </span>or <span 
class="ec-lmri-10x-x-109">klabels</span></dd></dl>
                                                                                
                                                                                

<!--l. 6710--><p class="noindent" >Graph-dependent labels for the independent variable labels. This is a nested cell array with first
dimension of <span 
class="ec-lmri-10x-x-109">graphs </span>and second dimension of <span 
class="ec-lmri-10x-x-109">dimension</span>s. This is used to replace the global
values of <span 
class="ec-lmri-10x-x-109">xlabels </span>or <span 
class="ec-lmri-10x-x-109">klabels </span>if the axis labels change from graph to graph, for example, if the
coordinates have a functional transform. These can be set for an individual coordinate on one
graph if needed.
<dl class="description"><dt class="description">     
<!--l. 6718--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 6718--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.glabels</span><span 
class="ec-lmri-10x-x-109">{4</span><span 
class="ec-lmri-10x-x-109">}</span><span 
class="ec-lmri-10x-x-109">{2</span><span 
class="ec-lmri-10x-x-109">} = ’x</span><span 
class="ec-lmri-10x-x-109">^2’</span></dd></dl>
<!--l. 6721--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">10.7.8</span>  <a 
 id="x1-24100010.7.8"></a><span 
class="ec-lmri-10x-x-109">graphs</span></h4>
<dl class="description"><dt class="description">     
<!--l. 6723--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 6723--><p class="noindent" >observables to plot</dd></dl>
<!--l. 6725--><p class="noindent" >This gives the observables to plot. The default is a vector of indices from one to the length of the
cell array of observe functions. Normally not initialized, as the default is used. Mostly used to
reduce graphical output on a long file.
<dl class="description"><dt class="description">     
<!--l. 6730--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 6730--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.graphs = 10</span></dd></dl>
<!--l. 6733--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">10.7.9</span>  <a 
 id="x1-24200010.7.9"></a><span 
class="ec-lmri-10x-x-109">gtransforms</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}</span></h4>
<dl class="description"><dt class="description">     
<!--l. 6735--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 6735--><p class="noindent" >[0,0,...]</dd></dl>
                                                                                
                                                                                

<!--l. 6737--><p class="noindent" >This switch specifies the Fourier transformed graphs and axes for graphics labeling.
Automatically equal to <span 
class="ec-lmri-10x-x-109">ftransforms </span>if from an earlier xSIM input, but can be changed. If
altered for a given graph, all the axis Fourier switches should be reset. This is ignored if there
is no <span 
class="ec-lmri-10x-x-109">dimensions </span>setting to indicate space dimensions.
<dl class="description"><dt class="description">     
<!--l. 6743--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 6743--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.gtransforms</span><span 
class="ec-lmri-10x-x-109">{1</span><span 
class="ec-lmri-10x-x-109">} = [0,0,1]</span></dd></dl>
<!--l. 6746--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">10.7.10</span>  <a 
 id="x1-24300010.7.10"></a><span 
class="ec-lmri-10x-x-109">headers</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}</span></h4>
<dl class="description"><dt class="description">     
<!--l. 6748--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 6748--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">”</span></dd></dl>
<!--l. 6750--><p class="noindent" >This is a string variable giving the graph headers for each type of function plotted. The default
value is an empty string. Otherwise, the header string that is input is used. Either is
combined with the simulation name and a graph number to identify the graph. This is
used to include simulation headers to identify graphs in simulation outputs. Graph
headers may not be needed in a final published result. For this, either edit the graph,
or use a space to make plot headers blank: <span 
class="ec-lmri-10x-x-109">p.headers</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">} = ’ ’</span>, or <span 
class="ec-lmri-10x-x-109">p.name = ’ ’</span>
.     
<dl class="description"><dt class="description">
<!--l. 6759--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 6759--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.headers</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">} = ’my</span><span 
class="ec-lmri-10x-x-109">_graph</span><span 
class="ec-lmri-10x-x-109">_header’</span></dd></dl>
<!--l. 6762--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">10.7.11</span>  <a 
 id="x1-24400010.7.11"></a><span 
class="ec-lmri-10x-x-109">images</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}</span></h4>
                                                                                
                                                                                
     
<dl class="description"><dt class="description">
<!--l. 6764--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 6764--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">0</span></dd></dl>
<!--l. 6766--><p class="noindent" >This is the number of 3D, transverse o-x-y images plotted as discrete time slices. Only valid if
the input data dimension is greater than 2. If present, the coordinates not plotted are set to
their central value when plotting the transverse images. This input should have a value from
zero up to a maximum value of the number of plotted points. It has a vector length equal to
<span 
class="ec-lmri-10x-x-109">graphs.</span>
<dl class="description"><dt class="description">     
<!--l. 6773--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 6773--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.images</span><span 
class="ec-lmri-10x-x-109">{4</span><span 
class="ec-lmri-10x-x-109">} = 5</span></dd></dl>
<!--l. 6776--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">10.7.12</span>  <a 
 id="x1-24500010.7.12"></a><span 
class="ec-lmri-10x-x-109">imagetype</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}</span></h4>
<dl class="description"><dt class="description">     
<!--l. 6778--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 6778--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">1</span></dd></dl>
<!--l. 6780--><p class="noindent" >This is the type of transverse o-x-y movie images plotted. It has a vector length equal to
<span 
class="ec-lmri-10x-x-109">graphs</span>.
<ul class="itemize1">     
<li class="itemize">
<!--l. 6783--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">imagetype = 1 </span>gives a perspective surface plot
</li>     
<li class="itemize">
<!--l. 6784--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">imagetype = 2</span>, gives a 2D plot with colors
</li>     
<li class="itemize">
<!--l. 6785--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">imagetype = </span>3 gives a contour plot with 10 equally spaced contours
                                                                                
                                                                                
     
</li>
<li class="itemize">     
<!--l. 6786--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">imagetype = </span>4 gives a pseudo-color map</li></ul>
<dl class="description"><dt class="description">     
<!--l. 6789--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 6789--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.imagetype</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">} = 1, 2, 3, 4</span></dd></dl>
<!--l. 6792--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">10.7.13</span>  <a 
 id="x1-24600010.7.13"></a><span 
class="ec-lmri-10x-x-109">klabels</span></h4>
<dl class="description"><dt class="description">     
<!--l. 6794--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 6794--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">{’</span><span 
class="ec-lmri-10x-x-109">\omega’, ’k</span><span 
class="ec-lmri-10x-x-109">_x’, ’k</span><span 
class="ec-lmri-10x-x-109">_y’, ’k</span><span 
class="ec-lmri-10x-x-109">_z’</span><span 
class="ec-lmri-10x-x-109">}“ or “</span><span 
class="ec-lmri-10x-x-109">{’k</span><span 
class="ec-lmri-10x-x-109">_1’, ’k</span><span 
class="ec-lmri-10x-x-109">_2’, ’k</span><span 
class="ec-lmri-10x-x-109">_3’, ’k</span><span 
class="ec-lmri-10x-x-109">_4’,...</span><span 
class="ec-lmri-10x-x-109">}</span></dd></dl>
<!--l. 6797--><p class="noindent" >Labels for the graph axis Fourier transform labels, vector length of <span 
class="ec-lmri-10x-x-109">dimension</span>s. The numerical
labeling default is used when the “<span 
class="ec-lmri-10x-x-109">p.numberaxis</span>“ option is set. Note, these are typeset in Latex
mathematics mode! When changing from the default values, all the required new labels must
be set.
<dl class="description"><dt class="description">     
<!--l. 6803--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 6803--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.klabels= </span><span 
class="ec-lmri-10x-x-109">{’</span><span 
class="ec-lmri-10x-x-109">\Omega’, ’K</span><span 
class="ec-lmri-10x-x-109">_x’, ’K</span><span 
class="ec-lmri-10x-x-109">_y’,</span><span 
class="ec-lmri-10x-x-109">}</span></dd></dl>
<!--l. 6807--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">10.7.14</span>  <a 
 id="x1-24700010.7.14"></a><span 
class="ec-lmri-10x-x-109">legends</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}</span></h4>
<dl class="description"><dt class="description">     
<!--l. 6809--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 6809--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">{”,”</span><span 
class="ec-lmri-10x-x-109">}</span></dd></dl>
                                                                                
                                                                                

<!--l. 6811--><p class="noindent" >Graph-dependent legends, specified as a nested cell array of strings for each line.
<dl class="description"><dt class="description">     
<!--l. 6814--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 6814--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.legends</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">} = </span><span 
class="ec-lmri-10x-x-109">{labels(1), ..., labels(lines)</span><span 
class="ec-lmri-10x-x-109">}</span></dd></dl>
<!--l. 6817--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">10.7.15</span>  <a 
 id="x1-24800010.7.15"></a><span 
class="ec-lmri-10x-x-109">limits</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}</span></h4>
<dl class="description"><dt class="description">     
<!--l. 6819--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 6819--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">{0,0,0,0; ...</span><span 
class="ec-lmri-10x-x-109">}</span></dd></dl>
<!--l. 6821--><p class="noindent" >Graph-dependent limits specified as a cell array with dimension <span 
class="ec-lmri-10x-x-109">graphs</span>. Each entry is a cell array
of graph limits indexed by the dimension. The limits are vectors, indexed as 1,2 for the lower
and upper plot limits. This is useful if the limits required change from graph to graph. If an
automatic limit is required for either the upper or lower limit, it is set to <span 
class="ec-lmri-10x-x-109">inf. </span>An invalid, scalar
or empty limit vector, like [0,0] or \(0\) or [] is ignored. In these cases an automatic graph
limit 
<dl class="description"><dt class="description">
<!--l. 6830--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 6830--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.limits</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">} = </span><span 
class="ec-lmri-10x-x-109">{[t1,t2],[x1,x2],[y1,y2] ...,</span><span 
class="ec-lmri-10x-x-109">}</span></dd></dl>
<!--l. 6834--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">10.7.16</span>  <a 
 id="x1-24900010.7.16"></a><span 
class="ec-lmri-10x-x-109">lines</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}</span></h4>
<dl class="description"><dt class="description">     
<!--l. 6836--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 6836--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">{’-k’,’–k’,’:k’,’-.k’,’-ok’,’–ok’,’:ok’,’-.ok’,’-+k’,’–+k’</span><span 
class="ec-lmri-10x-x-109">}</span></dd></dl>
                                                                                
                                                                                

<!--l. 6838--><p class="noindent" >Line types for each line in every two-dimensional graph plotted. If a given line on a
two-dimensional line is to be removed completely, set the relevant line-style to zero. For
example, to remove the first line from graph 3, set p.lines{3} ={0}. This is useful when
generating and changing graphics output from a saved data file.
<dl class="description"><dt class="description">     
<!--l. 6844--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 6844--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.lines</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">} = </span><span 
class="ec-lmri-10x-x-109">{linetype</span><span 
class="ec-lmri-10x-x-109">{1</span><span 
class="ec-lmri-10x-x-109">}, ..., linetype</span><span 
class="ec-lmri-10x-x-109">{nl</span><span 
class="ec-lmri-10x-x-109">}</span><span 
class="ec-lmri-10x-x-109">}</span></dd></dl>
<!--l. 6847--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">10.7.17</span>  <a 
 id="x1-25000010.7.17"></a><span 
class="ec-lmri-10x-x-109">minbar</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}</span></h4>
<dl class="description"><dt class="description">     
<!--l. 6849--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 6849--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">{0.01, ...</span><span 
class="ec-lmri-10x-x-109">}</span></dd></dl>
<!--l. 6851--><p class="noindent" >This is the minimum relative error-bar that is plotted. Set to a large value to suppress unwanted
error-bars, although its best not to ignore the error-bar information! This can be changed per
graph.
<dl class="description"><dt class="description">     
<!--l. 6855--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 6855--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.minbar</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">} = 0</span></dd></dl>
<!--l. 6858--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">10.7.18</span>  <a 
 id="x1-25100010.7.18"></a><span 
class="ec-lmri-10x-x-109">name</span></h4>
<dl class="description"><dt class="description">     
<!--l. 6860--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 6860--><p class="noindent" >”</dd></dl>
                                                                                
                                                                                

<!--l. 6862--><p class="noindent" >Name used to label simulation graphs, usually corresponding to the equation or problem solved.
This can be removed from individual graphs by using <span 
class="ec-lmri-10x-x-109">headers</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">} </span>equal to a single blank space.
The default is a null string. To remove all headers globally, set <span 
class="ec-lmri-10x-x-109">name </span>equal to a single blank
space: <span 
class="ec-lmri-10x-x-109">name = ’ ’.</span>
<dl class="description"><dt class="description">     
<!--l. 6868--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 6868--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.name = ’Wiener process simulation’</span></dd></dl>
<!--l. 6871--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">10.7.19</span>  <a 
 id="x1-25200010.7.19"></a><span 
class="ec-lmri-10x-x-109">olabels</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}</span></h4>
<dl class="description"><dt class="description">     
<!--l. 6873--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 6873--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">’a’</span></dd></dl>
<!--l. 6875--><p class="noindent" >Cell array of labels for the graph axis observables and functions. These are text labels that are
used on the graph axes. The default value is <span 
class="ec-lmri-10x-x-109">’a</span><span 
class="ec-lmri-10x-x-109">_1</span>’ if the default observable is used, otherwise
it is blank. This is overwritten by any subsequent label input when the graphics program is
run:  
<dl class="description"><dt class="description">
<!--l. 6881--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 6881--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.olabels</span><span 
class="ec-lmri-10x-x-109">{4</span><span 
class="ec-lmri-10x-x-109">} = ’v’</span></dd></dl>
<!--l. 6884--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">10.7.20</span>  <a 
 id="x1-25300010.7.20"></a><span 
class="ec-lmri-10x-x-109">parametric</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}</span></h4>
<dl class="description"><dt class="description">     
<!--l. 6886--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 6886--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">[0,0]</span></dd></dl>
                                                                                
                                                                                

<!--l. 6888--><p class="noindent" >Cell array that defines parametric plots, if required, for each graph number. The first number is
the graph number of the alternative observable plotted on the horizontal axis for the
parametric plot. The second number is the axis number where the parametric value is
substituted, which can be the time (axis 1) or x-coordinate (axis 2).
<!--l. 6894--><p class="indent" >  If both are zero, the plot against an independent space-time coordinate is calculated as
usual. If nonzero, a parametric plot is made for two-dimensional plots . In both cases the
vertical axis is used to plot the original graph variable. The horizontal axis is used for either
the independent variable or the parametric variable. In this version, only vertical error-bars
are available. Can be usefully combined with <span 
class="ec-lmri-10x-x-109">scatters</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">} </span>to plot individual trajectories, but
the number of scatters should be the same in each of the two graphs that are parametrically
plotted against each other.
<dl class="description"><dt class="description">     
<!--l. 6904--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 6904--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.parametric</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">} = [p1,p2] </span><span 
class="ec-lmri-10x-x-109">&#x003E;= 0</span></dd></dl>
<!--l. 6908--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">10.7.21</span>  <a 
 id="x1-25400010.7.21"></a><span 
class="ec-lmri-10x-x-109">pdimension</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}</span></h4>
<dl class="description"><dt class="description">     
<!--l. 6910--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 6910--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">3</span></dd></dl>
<!--l. 6912--><p class="noindent" >This is the maximum plotted space-time dimension for each plotted quantity. The purpose is
eliminate unwanted graphs. For example, it is useful to reduce the maximum dimension when
averaging in space. Higher dimensional graphs are not needed, as the data is duplicated.
Averaging can be useful for checking conservation laws, or for averaging over homogeneous
data to reduce sampling errors. All graphs are suppressed if it is set to zero. Any three
dimensions can be chosen to be plotted, using the <span 
class="ec-lmri-10x-x-109">axes </span>parameter to suppress the unwanted
data points in other dimensions.
<dl class="description"><dt class="description">     
<!--l. 6922--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 6922--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.pdimension</span><span 
class="ec-lmri-10x-x-109">{4</span><span 
class="ec-lmri-10x-x-109">} = 2</span></dd></dl>
                                                                                
                                                                                
<!--l. 6925--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">10.7.22</span>  <a 
 id="x1-25500010.7.22"></a><span 
class="ec-lmri-10x-x-109">saveeps</span></h4>
<dl class="description"><dt class="description">     
<!--l. 6927--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 6927--><p class="noindent" >0</dd></dl>
<!--l. 6929--><p class="noindent" >If set to \(1\), all plots are saved to the current folder as .eps files, numbered consecutively. It is best
to use the <span 
class="ec-lmri-10x-x-109">close all </span>command first to remove unwanted displayed xFIGURES, before running
<span 
class="ec-lmri-10x-x-109">xgraph </span>with this option.
<dl class="description"><dt class="description">     
<!--l. 6934--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 6934--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.saveeps =1</span></dd></dl>
<!--l. 6937--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">10.7.23</span>  <a 
 id="x1-25600010.7.23"></a><span 
class="ec-lmri-10x-x-109">savefig</span></h4>
<dl class="description"><dt class="description">     
<!--l. 6939--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 6939--><p class="noindent" >0</dd></dl>
<!--l. 6941--><p class="noindent" >If set to \(1\), all plots are saved to the current folder as .fig files, numbered consecutively. It is best
to use the <span 
class="ec-lmri-10x-x-109">close all </span>command first to remove unwanted displayed xFIGURES, before running
<span 
class="ec-lmri-10x-x-109">xgraph </span>with this option.
<dl class="description"><dt class="description">     
<!--l. 6946--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 6946--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.savefig =1</span></dd></dl>
                                                                                
                                                                                
<!--l. 6949--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">10.7.24</span>  <a 
 id="x1-25700010.7.24"></a><span 
class="ec-lmri-10x-x-109">transverse</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}</span></h4>
<dl class="description"><dt class="description">     
<!--l. 6951--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 6951--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">0</span></dd></dl>
<!--l. 6953--><p class="noindent" >This is the number of 2D transverse images plotted as discrete time slices. Only valid if
<span 
class="ec-lmri-10x-x-109">dimensions </span>is greater than 2. If present, the \(y,z\)-coordinates are set to their central values when
plotting transverse images. Each element can be from 0 up to the number of plotted
time-points. The cell array has a vector length equal to <span 
class="ec-lmri-10x-x-109">graphs</span>.
<dl class="description"><dt class="description">     
<!--l. 6959--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 6959--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.transverse</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}= 6</span></dd></dl>
<!--l. 6962--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">10.7.25</span>  <a 
 id="x1-25800010.7.25"></a><span 
class="ec-lmri-10x-x-109">verbose</span></h4>
<dl class="description"><dt class="description">     
<!--l. 6964--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 6964--><p class="noindent" >0</dd></dl>
<!--l. 6966--><p class="noindent" >Print flag for output information while running xGRAPH. Print options are:
<ul class="itemize1">     
<li class="itemize">
<!--l. 6969--><p class="noindent" >Minimal if <span 
class="ec-lmri-10x-x-109">verbose = -1</span>: Prints just the start-up time and hard error messages
</li>     
<li class="itemize">
<!--l. 6971--><p class="noindent" >Brief if <span 
class="ec-lmri-10x-x-109">verbose = 0</span>: Additionally prints the final, total chi-squared errors where
present
                                                                                
                                                                                
     
</li>
<li class="itemize">     
<!--l. 6973--><p class="noindent" >Informative if <span 
class="ec-lmri-10x-x-109">verbose = 1</span>: Also prints the graph progress indicators
</li>     
<li class="itemize">
<!--l. 6975--><p class="noindent" >Full if <span 
class="ec-lmri-10x-x-109">verbose = 2</span>: Prints everything including the internal parameter structure
data.</li></ul>
<!--l. 6978--><p class="noindent" >In summary, if <span 
class="ec-lmri-10x-x-109">verbose = 0</span>, most output is suppressed except the final data, <span 
class="ec-lmri-10x-x-109">verbose = 1</span>
displays a progress report, and <span 
class="ec-lmri-10x-x-109">verbose = 2 </span>additionally generates a readable summary of the
graphics parameter input.
<dl class="description"><dt class="description">     
<!--l. 6983--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 6983--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.verbose = 0</span></dd></dl>
<!--l. 6986--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">10.7.26</span>  <a 
 id="x1-25900010.7.26"></a><span 
class="ec-lmri-10x-x-109">xlabels</span></h4>
<dl class="description"><dt class="description">     
<!--l. 6988--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Default:</span> 
</dt><dd 
class="description">
<!--l. 6988--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">{’t’, ’x’, ’y’, ’z’</span><span 
class="ec-lmri-10x-x-109">} </span>or {<span 
class="ec-lmri-10x-x-109">’x</span><span 
class="ec-lmri-10x-x-109">_1’, ’x</span><span 
class="ec-lmri-10x-x-109">_2’, ’x</span><span 
class="ec-lmri-10x-x-109">_3’, ’x</span><span 
class="ec-lmri-10x-x-109">_4’</span>,...}</dd></dl>
<!--l. 6991--><p class="noindent" >Global labels for the independent variable labels, vector length equal to <span 
class="ec-lmri-10x-x-109">dimension</span>s. The
numerical labeling default is used when the <span 
class="ec-lmri-10x-x-109">numberaxis </span>option is true. These are typeset in
Latex mathematics mode. When changing from the default values, all the required new labels
must be set.
<dl class="description"><dt class="description">     
<!--l. 6997--><p class="noindent" >
<span 
class="ec-lmssbx-10x-x-109">Example:</span> 
</dt><dd 
class="description">
<!--l. 6997--><p class="noindent" ><span 
class="ec-lmri-10x-x-109">p.xlabels = </span><span 
class="ec-lmri-10x-x-109">{’tau’</span><span 
class="ec-lmri-10x-x-109">}</span></dd></dl>
                                                                                
                                                                                
<!--l. 7000--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">10.8</span>  <a 
 id="x1-26000010.8"></a>User function reference</h3>
<!--l. 7002--><p class="noindent" >It is possible to simply run <span 
class="ec-lmri-10x-x-109">xgraph </span>as is, without much intervention. However, there are
customization options, including user defined functions. These are as follows:
<!--l. 7006--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">10.8.1</span>  <a 
 id="x1-26100010.8.1"></a><span 
class="ec-lmri-10x-x-109">gfunction</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">} (d,p)</span></h4>
<!--l. 7008--><p class="noindent" >This is a cell array of graphics function handles. Use when a graph is needed that is a
functional transformation of the observed averages. The default value generates the <span 
class="ec-lmri-10x-x-109">n-th </span>graph
<span 
class="ec-lmri-10x-x-109">data </span>array directly from the <span 
class="ec-lmri-10x-x-109">n-th </span>input <span 
class="ec-lmri-10x-x-109">data</span>. The input is the data cell array for all the graphs
in the current sequence number with their graph parametes <span 
class="ec-lmri-10x-x-109">x</span>, and the output is the <span 
class="ec-lmri-10x-x-109">n-th </span>data
array that is plotted.
<!--l. 7016--><p class="indent" >  An arbitrary number of functions of these observables can be plotted, including
vector observables. The input to graphics functions is the observed data averages or
functions of averages in a given sequence, each stored in a cell array \(d\{n\}(\ell ,\mathbf {j},c)\). If there are
more graphics functions than input data cells, this generate additional data for
plotting.
<!--l. 7023--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">10.8.2</span>  <a 
 id="x1-26200010.8.2"></a><span 
class="ec-lmri-10x-x-109">xfunctions</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">} </span><span 
class="ec-lmri-10x-x-109">{nd</span><span 
class="ec-lmri-10x-x-109">} (ax,p)</span></h4>
<!--l. 7025--><p class="noindent" >This is a nested cell array of axis transformations. Use when a graph is needed with an axis
that is a function of the original axes. The input is the original axis coordinates,
and the output is the new coordinate set. The default value generates the input
axes. Called as <span 
class="ec-lmri-10x-x-109">xfunctions</span><span 
class="ec-lmri-10x-x-109">{n</span><span 
class="ec-lmri-10x-x-109">}</span><span 
class="ec-lmri-10x-x-109">{nd</span><span 
class="ec-lmri-10x-x-109">}(ax,p) </span>for the <span 
class="ec-lmri-10x-x-109">n</span>-th graph and axis direction <span 
class="ec-lmri-10x-x-109">dir</span>,
where <span 
class="ec-lmri-10x-x-109">ax </span>is a vector of coordinates for that axis.There is one graphics function for
each separate graph dimension or axis. The default value is the coordinate vector \(xk\{nd\}\)
stored in the input parameter structure p, or else the relevant index if <span 
class="ec-lmri-10x-x-109">xk</span><span 
class="ec-lmri-10x-x-109">{nd</span><span 
class="ec-lmri-10x-x-109">} </span>is
omitted.
<!--l. 7036--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">10.9</span>  <a 
 id="x1-26300010.9"></a>xGRAPH structure</h3>
<!--l. 7038--><p class="noindent" >The graphics function, \(xgraph\), plots the simulation data. The general stucture is:
<!--l. 7045--><p class="indent" >  \begin {align*}  \mathbf {xgraph} &amp; \rightarrow \mathbf {xgpreferences}\,\,(checks\,inputs)\\ &amp; \rightarrow \mathbf {xmultigraph}\leftrightarrow \mathbf {xreduce\leftrightarrow \mathbf {xcompress}}\,\,(structures\,data\,arrays)\\ &amp; \rightarrow \mathbf {ximages}\rightarrow \mathbf {xtransverse}\rightarrow \mathbf {xplot3}\rightarrow \mathbf {xplot2}\,\,(graphs\,all\,data)  \end {align*}
                                                                                
                                                                                
<!--l. 7047--><p class="indent" >  Most graphics functions simply work, but two important functions are listed here for
reference.
<!--l. 7050--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">10.9.1</span>  <a 
 id="x1-26400010.9.1"></a><span 
class="ec-lmri-10x-x-109">xgraph(data,input)</span></h4>
<!--l. 7052--><p class="noindent" >The <span 
class="ec-lmri-10x-x-109">xgraph </span>function graphs multidimensional data files.
<ul class="itemize1">     
<li class="itemize">
<!--l. 7054--><p class="noindent" >Input: graphics data cells <span 
class="ec-lmri-10x-x-109">data</span>, input parameter cells <span 
class="ec-lmri-10x-x-109">input</span>.
</li>     
<li class="itemize">
<!--l. 7055--><p class="noindent" >Output: graphs, displayed and/or stored as <span 
class="ec-lmri-10x-x-109">eps </span>or <span 
class="ec-lmri-10x-x-109">fig </span>files.
</li>     
<li class="itemize">
<!--l. 7057--><p class="noindent" >If no numeric <span 
class="ec-lmri-10x-x-109">data </span>present, reads data from a file named <span 
class="ec-lmri-10x-x-109">data</span>.
</li>     
<li class="itemize">
<!--l. 7058--><p class="noindent" >If  <span 
class="ec-lmri-10x-x-109">data  </span>is  present  but  without  any  <span 
class="ec-lmri-10x-x-109">input  </span>parameters  it  plots  using  default
parameters.
</li>     
<li class="itemize">
<!--l. 7060--><p class="noindent" >First  data  dimension  is  the  line  index,  last  dimension  are  the  error-bars  and
comparisons
</li>     
<li class="itemize">
<!--l. 7062--><p class="noindent" >Needs: x<span 
class="ec-lmri-10x-x-109">read, xmakecell, xgpreferences, xmultiplot</span></li></ul>
<!--l. 7065--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">10.9.2</span>  <a 
 id="x1-26500010.9.2"></a><span 
class="ec-lmri-10x-x-109">input = xgpreferences (input,oldinput)</span></h4>
<!--l. 7067--><p class="noindent" >The <span 
class="ec-lmri-10x-x-109">xgpreferences </span>function sets default values for graphics inputs.
<ul class="itemize1">     
<li class="itemize">
<!--l. 7070--><p class="noindent" >Input: <span 
class="ec-lmri-10x-x-109">input </span>cell array and optionally previous inputs from a datafile, <span 
class="ec-lmri-10x-x-109">oldinput</span>.
                                                                                
                                                                                
     
</li>
<li class="itemize">     
<!--l. 7072--><p class="noindent" >Note that each cell array is a sequence of graphics parameter structures
</li>     
<li class="itemize">
<!--l. 7073--><p class="noindent" >Output: the updated plus default graphics parameters
</li>     
<li class="itemize">
<!--l. 7074--><p class="noindent" >Called by: <span 
class="ec-lmri-10x-x-109">xgraph</span>
</li>     
<li class="itemize">
<!--l. 7075--><p class="noindent" >Needs: <span 
class="ec-lmri-10x-x-109">xprefer</span>, <span 
class="ec-lmri-10x-x-109">xcprefer</span></li></ul>
<!--l. 7077--><p class="noindent" >
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
  
<h2 class="chapterHead"><span class="titlemark">11</span>  <a 
 id="x1-26600011"></a>Examples</h2>
<!--l. 7081--><p class="noindent" >A variety of examples are given in the xAMPLES folder distributed with xSPDE. These can
all be run using <span 
class="ec-lmri-10x-x-109">Batchtest.m</span>, which has a typical runtime of \(50-100s\), and runs \(34\) different
case studies. This shows your distribution is intact. All the graphs produced are
deleted. It also lists the many different templates available, some of which are listed
here.
  
<h3 class="sectionHead"><span class="titlemark">11.1</span>  <a 
 id="x1-26700011.1"></a>SDE examples</h3>
<!--l. 7090--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">11.1.1</span>  <a 
 id="x1-26800011.1.1"></a>Kubo</h4>
<!--l. 7092--><p class="noindent" >This solves a multiplicative SDE with initial condition \(a\left (0\right )=1\) and:
<!--l. 7097--><p class="indent" >  \begin {equation}  \frac {\partial a}{\partial t}=iaw(t)\,.\label {eq:SDE-3}  \end {equation}
<!--l. 7099--><p class="indent" >  The function uses the RK4 algorithm together with both vector and series ensembles, then
stores the computed averages with a comparison of the variance and an exact solution,
\[ \left \langle a^{n}\right \rangle =e^{-tn^{2}/2}. \]
<div class="center" 
>
<!--l. 7106--><p class="noindent" >
<div class="doublebox"><div class="minipage"><span 
class="ec-lmtt-10x-x-109">function [e] = Kubo()</span>
<!--l. 7110--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">% [e] = KUBO() simulates a Kubo oscillator</span>
<!--l. 7112--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<!--l. 7114--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.name = ’Kubo oscillator’;</span>
<!--l. 7116--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.ensembles = [1000,8];</span>
<!--l. 7118--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.method = @RK4;</span>
<!--l. 7120--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.initial = @(w,p) 1;</span>
<!--l. 7122--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.deriv = @(a,w,p) 1i*w.*a(1,:) ;</span>
<!--l. 7124--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.file = ’Kubo.mat’;</span>
<!--l. 7126--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.observe</span><span 
class="ec-lmtt-10x-x-109">{2</span><span 
class="ec-lmtt-10x-x-109">} = @(a,p) a.</span><span 
class="ec-lmtt-10x-x-109">^2;</span>
<!--l. 7129--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.olabels</span><span 
class="ec-lmtt-10x-x-109">{2</span><span 
class="ec-lmtt-10x-x-109">} = </span><span 
class="ec-lmtt-10x-x-109">{’</span><span 
class="ec-lmtt-10x-x-109">&#x003C;a</span><span 
class="ec-lmtt-10x-x-109">^2</span><span 
class="ec-lmtt-10x-x-109">&#x003E;’</span><span 
class="ec-lmtt-10x-x-109">};</span>
<!--l. 7131--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.compare = </span><span 
class="ec-lmtt-10x-x-109">{@(p) exp(-p.t/2),@(p) exp(-2*p.t)</span><span 
class="ec-lmtt-10x-x-109">};</span>
<!--l. 7133--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">e = xsim(p);</span>
<!--l. 7135--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p2.name = ’Kubo oscillator edited title’;</span>
<!--l. 7137--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">xgraph(p.file,p2);</span>
<!--l. 7139--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">end</span>                                                                    </div></div>
</div>
                                                                                
                                                                                
<!--l. 7143--><p class="indent" >  <a 
 id="paragraph*.6"></a>
<!--l. 7143--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-26900011.1.1"></a>Notes</span>
<ul class="itemize1">     
<li class="itemize">
<!--l. 7145--><p class="noindent" >The algorithm is changed from the default to RK4.
</li>     
<li class="itemize">
<!--l. 7146--><p class="noindent" >The data is stored to ’Kubo.mat’.
</li>     
<li class="itemize">
<!--l. 7147--><p class="noindent" >This is re-read and edited using a second parameter structure, p2.</li></ul>
<!--l. 7149--><p class="noindent" ><figure class="figure"> 
<a 
 id="x1-269001r1"></a><img 
src="xFIGURES/Kubo-example1.svg" alt="pict"  
 style="width:31.36917em;" ><br />
<img 
src="xFIGURES/Kubo-example2.svg" alt="pict"  
 style="width:31.36917em;" >
<figcaption class="caption" ><span class="id">Figure 11.1: </span><span  
class="content">Example: Kubo oscillator. The graph shows the sampling error-bars as
two parallel lines. The discretization error-bars are less than the minimum, and are not
shown.</span></figcaption><!--tex4ht:label?: x1-269001r1 -->
<!--l. 7154--><p class="indent" >  </figure>
<!--l. 7156--><p class="indent" >
                                                                                
                                                                                
  
<h4 class="subsectionHead"><span class="titlemark">11.1.2</span>  <a 
 id="x1-27000011.1.2"></a>Loss/Gain with noise</h4>
<!--l. 7160--><p class="noindent" >This solves an SDE with a complex Gaussian distributed initial condition having \(\left \langle \left |a\left (0\right )\right |^{2}\right \rangle =1\) and a
sequence of SDE equations, such that \begin {equation}  \frac {\partial a}{\partial t}=\begin {cases} -a+w_{1}(t)+iw_{2}(t) &amp; 0&lt;t&lt;4\\ a+w_{1}(t)+iw_{2}(t) &amp; 4&lt;t&lt;8 \end {cases}\,.\label {eq:SDE-3-1-1}  \end {equation}
<!--l. 7170--><p class="indent" >  The computed variance is compared with an exact solution, \[ \left \langle a^{2}\right \rangle =\begin {cases} 1 &amp; 0&lt;t&lt;4\\ 2e^{2\left (t-4\right )t}-1 &amp; 4&lt;t&lt;8 \end {cases}. \]
<!--l. 7178--><p class="indent" >  .
<div class="center" 
>
<!--l. 7179--><p class="noindent" >
<div class="doublebox"><div class="minipage"><span 
class="ec-lmtt-10x-x-109">function [e] = Gain()</span>
<!--l. 7183--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">% e = GAIN() solves an SDE with sequential loss then gain</span>
<!--l. 7185--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<!--l. 7187--><p class="noindent" >%
<!--l. 7189--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.name = ’Loss with noise’;</span>
<!--l. 7191--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.ranges = 4;</span>
<!--l. 7193--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.noises = [2,0];</span>
<!--l. 7195--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.ensembles = [10000,1,10];</span>
<!--l. 7197--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.initial = @(w,</span><span 
class="ec-lmtt-10x-x-109">~) (w(1,:)+1i*w(2,:))/sqrt(2);</span>
<!--l. 7199--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.deriv = @(a,w,p) -a + w(1,:)+1i*w(2,:);</span>
<!--l. 7201--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.observe = </span><span 
class="ec-lmtt-10x-x-109">{@(a,</span><span 
class="ec-lmtt-10x-x-109">~) a.*conj(a)</span><span 
class="ec-lmtt-10x-x-109">};</span>
<!--l. 7203--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.olabels = </span><span 
class="ec-lmtt-10x-x-109">{’</span><span 
class="ec-lmtt-10x-x-109">|a</span><span 
class="ec-lmtt-10x-x-109">|</span><span 
class="ec-lmtt-10x-x-109">^2’</span><span 
class="ec-lmtt-10x-x-109">};</span>
<!--l. 7205--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.compare = </span><span 
class="ec-lmtt-10x-x-109">{@(p) 1</span><span 
class="ec-lmtt-10x-x-109">};</span>
<!--l. 7207--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p2 = p;</span>
<!--l. 7209--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p2.steps = 2;</span>
<!--l. 7211--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p2.name = ’Gain with noise’;</span>
<!--l. 7213--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p2.deriv = @(a,w,</span><span 
class="ec-lmtt-10x-x-109">~) a + w(1,:)+1i*w(2,:);</span>
<!--l. 7215--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p2.compare = </span><span 
class="ec-lmtt-10x-x-109">{@(p) 2*exp(2*p.t)-1</span><span 
class="ec-lmtt-10x-x-109">};</span>
<!--l. 7217--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">e = xspde(</span><span 
class="ec-lmtt-10x-x-109">{p,p2</span><span 
class="ec-lmtt-10x-x-109">});</span>
<!--l. 7219--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">end</span>                                                                    </div></div>
</div>
<!--l. 7223--><p class="indent" >  <a 
 id="paragraph*.7"></a>
<!--l. 7223--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-27100011.1.2"></a>Notes</span>
<ul class="itemize1">     
<li class="itemize">
<!--l. 7225--><p class="noindent" >Low and high level parallel ensembles optimize use of multi-core vector hardware.
</li>     
<li class="itemize">
<!--l. 7227--><p class="noindent" >Two distinct simulations are run in series, with a change in the equation.
                                                                                
                                                                                
     
</li>
<li class="itemize">     
<!--l. 7228--><p class="noindent" >The simulation name is changed in sequence 2, to distinguish the graphical outputs</li></ul>
<!--l. 7231--><p class="noindent" ><figure class="figure"> 
<a 
 id="x1-271001r2"></a><img 
src="xFIGURES/Gain-example1.svg" alt="pict"  
 style="width:31.36917em;" ><br />
<img 
src="xFIGURES/Gain-example2.svg" alt="pict"  
 style="width:31.36917em;" >
<figcaption class="caption" ><span class="id">Figure 11.2: </span><span  
class="content">Top figure: amplitude squared with loss balanced by noise. Bottom figure,
amplitude squared with gain. Graphs show excellent agreement with theory up to the
sampling errors of less than \(\pm 0.005\) in the initial phase, shown by the parallel lines, with step
errors of order \(\pm 0.001\) indicated by error-bars.</span></figcaption><!--tex4ht:label?: x1-271001r2 -->
<!--l. 7238--><p class="indent" >  </figure>
                                                                                
                                                                                
<!--l. 7242--><p class="noindent" >  
<h3 class="sectionHead"><span class="titlemark">11.2</span>  <a 
 id="x1-27200011.2"></a>Spectral examples</h3>
<!--l. 7244--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">11.2.1</span>  <a 
 id="x1-27300011.2.1"></a>Equilibrium</h4>
<!--l. 7246--><p class="noindent" >This solves an SDE with a complex Gaussian initial condition having \(\left \langle \left |a\left (0\right )\right |^{2}\right \rangle =1\) and:
<!--l. 7251--><p class="indent" >  \begin {equation}  \frac {\partial a}{\partial t}=-a+w_{1}(t)+iw_{2}(t)\,.\label {eq:SDE-3-1}  \end {equation}
<!--l. 7253--><p class="indent" >  The equation is such that the initial distribution is also the equilibrium probability
distribution. The computed ordinary and spectral variances are compared with exact solutions
and graphed, where \begin {align*}  \lim _{t\rightarrow \infty }\left \langle \left |a\left (t\right )\right |^{2}\right \rangle &amp; =1.\\ \left \langle \left |a\left (\omega \right )\right |^{2}\right \rangle &amp; =\frac {T}{\pi \left (1+\omega ^{2}\right )}.  \end {align*}
<div class="center" 
>
<!--l. 7261--><p class="noindent" >
<div class="doublebox"><div class="minipage"><span 
class="ec-lmtt-10x-x-109">function [e] = Equilibrium()</span>
<!--l. 7265--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">% e = EQUILIBRIUM() solves an SDE with a known spectrum</span>
<!--l. 7267--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<!--l. 7269--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">%</span>
<!--l. 7271--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.name = ’Equilibrium spectrum’;</span>
<!--l. 7273--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.points = 101;</span>
<!--l. 7275--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.ranges = 100;</span>
<!--l. 7277--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.seed = 241;</span>
<!--l. 7279--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.noises = [2,0];</span>
<!--l. 7281--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.ensembles = [100,5];</span>
<!--l. 7283--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.initial = @(w,</span><span 
class="ec-lmtt-10x-x-109">~) (w(1,:)+1i*w(2,:))/sqrt(2);</span>
<!--l. 7285--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.deriv = @(a,w,</span><span 
class="ec-lmtt-10x-x-109">~) -a + w(1,:)+1i*w(2,:);</span>
<!--l. 7287--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.observe</span><span 
class="ec-lmtt-10x-x-109">{1</span><span 
class="ec-lmtt-10x-x-109">} = @(a,</span><span 
class="ec-lmtt-10x-x-109">~) a.*conj(a);</span>
<!--l. 7289--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.observe</span><span 
class="ec-lmtt-10x-x-109">{2</span><span 
class="ec-lmtt-10x-x-109">} = @(a,</span><span 
class="ec-lmtt-10x-x-109">~) a.*conj(a);</span>
<!--l. 7291--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.transforms = </span><span 
class="ec-lmtt-10x-x-109">{0,1</span><span 
class="ec-lmtt-10x-x-109">};</span>
<!--l. 7294--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.olabels = </span><span 
class="ec-lmtt-10x-x-109">{’</span><span 
class="ec-lmtt-10x-x-109">|a(t)</span><span 
class="ec-lmtt-10x-x-109">|</span><span 
class="ec-lmtt-10x-x-109">^2’,’</span><span 
class="ec-lmtt-10x-x-109">|a(</span><span 
class="ec-lmtt-10x-x-109">\omega)</span><span 
class="ec-lmtt-10x-x-109">|</span><span 
class="ec-lmtt-10x-x-109">^2’</span><span 
class="ec-lmtt-10x-x-109">};</span>
<!--l. 7296--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.compare = </span><span 
class="ec-lmtt-10x-x-109">{@(p) 1, @(p)p.ranges(1)./(pi*(1+p.w.</span><span 
class="ec-lmtt-10x-x-109">^2))</span><span 
class="ec-lmtt-10x-x-109">};</span>
<!--l. 7298--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">e = xspde(p);</span>
<!--l. 7300--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">end</span>                                                                    </div></div>
</div>
                                                                                
                                                                                
<!--l. 7304--><p class="indent" >  <a 
 id="paragraph*.8"></a>
<!--l. 7304--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-27400011.2.1"></a>Notes</span>
<ul class="itemize1">     
<li class="itemize">
<!--l. 7306--><p class="noindent" >A fixed random seed is input using the <span 
class="ec-lmri-10x-x-109">p.seed </span>parameter.
</li>     
<li class="itemize">
<!--l. 7307--><p class="noindent" >The <span 
class="ec-lmri-10x-x-109">p.transforms </span>cell array gives a Fourier transform for <span 
class="ec-lmri-10x-x-109">p.observe</span><span 
class="ec-lmri-10x-x-109">{2</span><span 
class="ec-lmri-10x-x-109">} </span>only.
</li>     
<li class="itemize">
<!--l. 7309--><p class="noindent" >A small number of ensembles and time-steps is used to improve error visibility.</li></ul>
<!--l. 7312--><p class="noindent" ><figure class="figure"> 
<a 
 id="x1-274001r3"></a><img 
src="xFIGURES/Equilibrium-example1.svg" alt="pict"  
 style="width:31.36917em;" ><br />
<img 
src="xFIGURES/Equilibrium-example2.svg" alt="pict"  
 style="width:31.36917em;" >
<figcaption class="caption" ><span class="id">Figure 11.3: </span><span  
class="content">Top figure: Mean amplitude squared, showing invariant behaviour with
time,  apart  from  sampling  errors.  Bottom  figure:  Mean  spectrum  as  a  function  of
frequency. The dashed lines are exact results, solid lines are upper and lower sampling
error bounds \((\pm \sigma )\), from sampling the stochastic equations, the error-bars are errors due
to the step-size. Error bars are less than the minimum size for graphics display in the
bottom figure.</span></figcaption><!--tex4ht:label?: x1-274001r3 -->
<!--l. 7321--><p class="indent" >  </figure>
                                                                                
                                                                                
<!--l. 7325--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">11.2.2</span>  <a 
 id="x1-27500011.2.2"></a>Quantum</h4>
<!--l. 7327--><p class="noindent" >This solves an SDE for a quantum harmonic oscillator in the (truncated) Wigner phase-space
calculus. It is initialized as a vacuum state, corresponding to a complex Gaussian initial
condition having \(\left \langle \left |a\left (0\right )\right |^{2}\right \rangle =1\). It is subject to vacuum noise, here realized by the auxiliary field \(a_{in}\). An
output field is given through the input-output relations and is realized by the auxiliary field
\(a_{out}\).
<!--l. 7338--><p class="indent" >  \begin {align}  \frac {\partial a}{\partial t} &amp; =-a+\sqrt {2}a_{in}.\nonumber \\ a_{in} &amp; =\frac {1}{2}\left (w_{1}(t)+iw_{2}(t)\,\right )\nonumber \\ a_{out} &amp; =\sqrt {2}a-a_{in}  \end {align}
<!--l. 7340--><p class="indent" >  The computed spectral variances are compared with exact solutions and graphed, where: \begin {align}  \frac {2\pi }{T}\left \langle \left |a\left (\omega \right )\right |^{2}\right \rangle &amp; =\frac {1}{\left (1+\omega ^{2}\right )}.\nonumber \\ \left \langle \left |a_{in}\left (\omega \right )\right |^{2}\right \rangle &amp; =\frac {1}{2}\nonumber \\ \left \langle \left |a_{out}\left (\omega \right )\right |^{2}\right \rangle &amp; =\frac {1}{2}.  \end {align}
<!--l. 7349--><p class="indent" >  <a 
 id="paragraph*.9"></a>
<!--l. 7349--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-27600011.2.2"></a>Notes</span>
<ul class="itemize1">     
<li class="itemize">
<!--l. 7351--><p class="noindent" >Demonstrates how to include defined fields
</li>     
<li class="itemize">
<!--l. 7352--><p class="noindent" >There are \(4\) steps per point, to give better accuracy due to finite steps
</li>     
<li class="itemize">
<!--l. 7354--><p class="noindent" >The observe functions are all transformed, and include defined fields.</li></ul>
<div class="center" 
>
<!--l. 7356--><p class="noindent" >
                                                                                
                                                                                
<div class="doublebox"><div class="minipage"><span 
class="ec-lmtt-10x-x-109">function e = Quantum()</span>
<!--l. 7360--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">% e = QUANTUM() solves an SDE with a known spectrum</span>
<!--l. 7363--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">% This is the quantum harmonic oscillator with a vacuum input and</span>
<!--l. 7365--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">% output, for which one expects 0.5 ’photons’ per mode.</span>
<!--l. 7367--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<!--l. 7369--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">%</span>
<!--l. 7371--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.name = ’Quantum harmonic oscillator spectrum’;</span>
<!--l. 7373--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.points = 160;</span>
<!--l. 7375--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.steps = 4;</span>
<!--l. 7377--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.ranges = 120;</span>
<!--l. 7379--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.fields = 1;</span>
<!--l. 7381--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.auxfields = 2;</span>
<!--l. 7383--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.noises = 2;</span>
<!--l. 7385--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.ensembles = [400,1,12];</span>
<!--l. 7387--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.initial = @(w,</span><span 
class="ec-lmtt-10x-x-109">~) (w(1,:)+1i*w(2,:))/(2);</span>
<!--l. 7389--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.a1 = @(w) (w(1,:)+1i*w(2,:))/2;</span>
<!--l. 7391--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.deriv = @(a,w,</span><span 
class="ec-lmtt-10x-x-109">~) -a(1,:)+sqrt(2)*p.a1(w);</span>
<!--l. 7393--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.define = @(a,w,p) [p.a1(w);sqrt(2)*a(1,:)-p.a1(w)];</span>
<!--l. 7395--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">T = @(p) p.ranges(1);</span>
<!--l. 7397--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.observe</span><span 
class="ec-lmtt-10x-x-109">{1</span><span 
class="ec-lmtt-10x-x-109">} = @(a,p) (2.*pi/T(p))*a(1,:).*conj(a(1,:));</span>
<!--l. 7399--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.observe</span><span 
class="ec-lmtt-10x-x-109">{2</span><span 
class="ec-lmtt-10x-x-109">} = @(a,p) (2.*pi/T(p))*a(2,:).*conj(a(2,:));</span>
<!--l. 7401--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.observe</span><span 
class="ec-lmtt-10x-x-109">{3</span><span 
class="ec-lmtt-10x-x-109">} = @(a,p) (2.*pi/T(p))*a(3,:).*conj(a(3,:));</span>
<!--l. 7403--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.transforms = </span><span 
class="ec-lmtt-10x-x-109">{1,1,1</span><span 
class="ec-lmtt-10x-x-109">};</span>
<!--l. 7405--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.olabels</span><span 
class="ec-lmtt-10x-x-109">{1</span><span 
class="ec-lmtt-10x-x-109">} = ’</span><span 
class="ec-lmtt-10x-x-109">|a(</span><span 
class="ec-lmtt-10x-x-109">\omega)</span><span 
class="ec-lmtt-10x-x-109">|</span><span 
class="ec-lmtt-10x-x-109">^2’;</span>
<!--l. 7407--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.olabels</span><span 
class="ec-lmtt-10x-x-109">{2</span><span 
class="ec-lmtt-10x-x-109">} = ’</span><span 
class="ec-lmtt-10x-x-109">|a</span><span 
class="ec-lmtt-10x-x-109">_</span><span 
class="ec-lmtt-10x-x-109">{in</span><span 
class="ec-lmtt-10x-x-109">}(</span><span 
class="ec-lmtt-10x-x-109">\omega)</span><span 
class="ec-lmtt-10x-x-109">|</span><span 
class="ec-lmtt-10x-x-109">^2’;</span>
<!--l. 7409--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.olabels</span><span 
class="ec-lmtt-10x-x-109">{3</span><span 
class="ec-lmtt-10x-x-109">} = ’</span><span 
class="ec-lmtt-10x-x-109">|a</span><span 
class="ec-lmtt-10x-x-109">_</span><span 
class="ec-lmtt-10x-x-109">{out</span><span 
class="ec-lmtt-10x-x-109">}(</span><span 
class="ec-lmtt-10x-x-109">\omega)</span><span 
class="ec-lmtt-10x-x-109">|</span><span 
class="ec-lmtt-10x-x-109">^2’;</span>
<!--l. 7411--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.compare</span><span 
class="ec-lmtt-10x-x-109">{1</span><span 
class="ec-lmtt-10x-x-109">} = @(p) 1./(1+p.w.</span><span 
class="ec-lmtt-10x-x-109">^2);</span>
<!--l. 7413--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.compare</span><span 
class="ec-lmtt-10x-x-109">{2</span><span 
class="ec-lmtt-10x-x-109">} = @(p) 0.5;</span>
<!--l. 7415--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.compare</span><span 
class="ec-lmtt-10x-x-109">{3</span><span 
class="ec-lmtt-10x-x-109">} = @(p) 0.5;</span>
<!--l. 7417--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">e = xspde(p);</span>
<!--l. 7419--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">end</span>                                                                    </div></div>
</div>
<!--l. 7423--><p class="indent" >  <figure class="figure"> 

                                                                                
                                                                                
<a 
 id="x1-276001r4"></a>
                                                                                
                                                                                
<!--l. 7425--><p class="noindent" ><img 
src="xFIGURES/Quantum-example1.svg" alt="pict"  
 style="width:31.36917em;" >
<!--l. 7427--><p class="noindent" ><img 
src="xFIGURES/Quantum-example2.svg" alt="pict"  
 style="width:31.36917em;" >
<figcaption class="caption" ><span class="id">Figure 11.4: </span><span  
class="content">Top figure: Spectral density of the quantum state. Bottom figure: Spectral
density of the output field. The solid lines indicate upper and lower spampling error
bounds \((\pm \sigma )\), from sampling the stochastic equations. The dashed lines are exact results, the
error-bars indicate step-size errors. Error bars are less than the minimum size for display
in the top figure.</span></figcaption><!--tex4ht:label?: x1-276001r4 -->
                                                                                
                                                                                
<!--l. 7433--><p class="indent" >  </figure>
                                                                                
                                                                                
  
<h3 class="sectionHead"><span class="titlemark">11.3</span>  <a 
 id="x1-27700011.3"></a>Probability examples</h3>
<!--l. 7439--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">11.3.1</span>  <a 
 id="x1-27800011.3.1"></a>Probability density, Wiener process</h4>
<!--l. 7441--><p class="noindent" >Solves an SDE with an initial condition \(\left \langle a\left (0\right )\right \rangle ^{2}=\frac {1}{4}\) and
<!--l. 7446--><p class="indent" >  \begin {equation}  \dot {a}=w(t)\,.  \end {equation}
<!--l. 7448--><p class="indent" >  Records the probability density and compares this with an exact solution:
<div class="eqnarray">\begin {eqnarray}  P\left (x,t\right ) &amp; = &amp; \frac {1}{\sqrt {2\pi \sigma ^{2}\left (t\right )}}e^{-\frac {x^{2}}{2\sigma ^{2}\left (t\right )}}\nonumber \\ \sigma ^{2}\left (t\right ) &amp; = &amp; \frac {1}{4}+t\,.  \end {eqnarray}
</div>
<!--l. 7456--><p class="indent" >  <a 
 id="paragraph*.10"></a>
<!--l. 7456--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-27900011.3.1"></a>Notes</span>
<ul class="itemize1">     
<li class="itemize">
<!--l. 7458--><p class="noindent" >The script outputs a 3D plot of \(P\left (x,t\right )\), together with the time evolution of \(P\left (0,t\right )\)
</li>     
<li class="itemize">
<!--l. 7460--><p class="noindent" >There are 5 “transverse” plots of transient probabilities at intermediate times.
</li>     
<li class="itemize">
<!--l. 7462--><p class="noindent" >Legends are plotted to identify the simulated and the analytic comparison lines.</li></ul>
<div class="center" 
>
<!--l. 7465--><p class="noindent" >
                                                                                
                                                                                
<div class="doublebox"><div class="minipage"><span 
class="ec-lmtt-10x-x-109">function e = Wienerprob()</span>
<!--l. 7469--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">% e = WIENERPROB() solves a Wiener process for the probability</span>
<!--l. 7471--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<!--l. 7473--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">%</span>
<!--l. 7475--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.name = ’Wiener SDE distribution’;</span>
<!--l. 7477--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.noises = 1;</span>
<!--l. 7479--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.points = 10;</span>
<!--l. 7481--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.ensembles = [10000,10];</span>
<!--l. 7483--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.initial = @(v,p) v/2;</span>
<!--l. 7485--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.sig = @(p) .25 + p.r</span><span 
class="ec-lmtt-10x-x-109">{1</span><span 
class="ec-lmtt-10x-x-109">};</span>
<!--l. 7487--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.deriv = @(a,w,p) w;</span>
<!--l. 7489--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.observe</span><span 
class="ec-lmtt-10x-x-109">{1</span><span 
class="ec-lmtt-10x-x-109">} = @(a,p) a;</span>
<!--l. 7491--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.compare</span><span 
class="ec-lmtt-10x-x-109">{1</span><span 
class="ec-lmtt-10x-x-109">} = @gaussprob;</span>
<!--l. 7493--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.transverse</span><span 
class="ec-lmtt-10x-x-109">{1</span><span 
class="ec-lmtt-10x-x-109">} = 5;</span>
<!--l. 7495--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.olabels</span><span 
class="ec-lmtt-10x-x-109">{1</span><span 
class="ec-lmtt-10x-x-109">} = ’P(x)’;</span>
<!--l. 7497--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.binranges</span><span 
class="ec-lmtt-10x-x-109">{1</span><span 
class="ec-lmtt-10x-x-109">} = </span><span 
class="ec-lmtt-10x-x-109">{-5:0.25:5</span><span 
class="ec-lmtt-10x-x-109">};</span>
<!--l. 7500--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.legends</span><span 
class="ec-lmtt-10x-x-109">{1</span><span 
class="ec-lmtt-10x-x-109">} = </span><span 
class="ec-lmtt-10x-x-109">{’Sampled P(x,</span><span 
class="ec-lmtt-10x-x-109">\tau) </span><span 
class="ec-lmtt-10x-x-109">\pm </span><span 
class="ec-lmtt-10x-x-109">\sigma’,’Exact</span>
<span 
class="ec-lmtt-10x-x-109">P(x,</span><span 
class="ec-lmtt-10x-x-109">\tau)’</span><span 
class="ec-lmtt-10x-x-109">};</span>
<!--l. 7502--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.xlabels = </span><span 
class="ec-lmtt-10x-x-109">{’</span><span 
class="ec-lmtt-10x-x-109">\tau’,’x’</span><span 
class="ec-lmtt-10x-x-109">};</span>
<!--l. 7504--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">e = xspde(p);</span>
<!--l. 7506--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">end</span>
<!--l. 7508--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">%</span>
<!--l. 7510--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">function p = gaussprob(p)</span>
<!--l. 7512--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p = exp(-(p.r</span><span 
class="ec-lmtt-10x-x-109">{2</span><span 
class="ec-lmtt-10x-x-109">}.</span><span 
class="ec-lmtt-10x-x-109">^2)./(2*p.sig(p)))./sqrt(2*pi*p.sig(p));</span>
<!--l. 7514--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">end</span>                                                                    </div></div>
</div>
<!--l. 7518--><p class="indent" >  <figure class="figure"> 

                                                                                
                                                                                
<a 
 id="x1-279001r5"></a>
                                                                                
                                                                                
<!--l. 7520--><p class="noindent" ><img 
src="xFIGURES/Wienerprob1.svg" alt="pict"  
 style="width:31.36917em;" >
<!--l. 7523--><p class="noindent" ><img 
src="xFIGURES/Wienerprob3.svg" alt="pict"  
 style="width:31.36917em;" >
<figcaption class="caption" ><span class="id">Figure 11.5: </span><span  
class="content">Top figure: 3D plot of the computed probability density of the simulated
Wiener process as a function of time (\(\tau \)) and “position” (\(x\)). Bottom figure: Time evolution
of  the  computed  probability  density  for  \(x=0\).  The  solid  lines  indicate  upper  and  lower
sampling error bounds, while the dashed line indicates theoretical predictions.</span></figcaption><!--tex4ht:label?: x1-279001r5 -->
                                                                                
                                                                                
<!--l. 7530--><p class="indent" >  </figure>
<!--l. 7532--><p class="indent" >  <figure class="figure"> 

                                                                                
                                                                                
<a 
 id="x1-279002r6"></a>
                                                                                
                                                                                
<!--l. 7534--><p class="noindent" ><img 
src="xFIGURES/Wienerprob2.svg" alt="pict"  
 style="width:31.36917em;" >
<!--l. 7537--><p class="noindent" ><img 
src="xFIGURES/Wienerprob4.svg" alt="pict"  
 style="width:31.36917em;" >
<figcaption class="caption" ><span class="id">Figure 11.6: </span><span  
class="content">Top and bottom figure: Computed probability densities of the simulated
Wiener process at \(\tau =5.556\) and \(\tau =10\), respectively. In total, 5 of these transverse plots are generated,
however, only 2 are presented here.</span></figcaption><!--tex4ht:label?: x1-279002r6 -->
                                                                                
                                                                                
<!--l. 7543--><p class="indent" >  </figure>
                                                                                
                                                                                
  
<h3 class="sectionHead"><span class="titlemark">11.4</span>  <a 
 id="x1-28000011.4"></a>SPDE examples</h3>
<!--l. 7549--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">11.4.1</span>  <a 
 id="x1-28100011.4.1"></a>Nonlinear Schrodinger equation with Dirichlet boundary conditions</h4>
<!--l. 7551--><p class="noindent" >This solves a (1+1)-dimensional PSDE with an initial condition of \(a\left (t=0,x\right )=sech\left (x\right )\) and
<div class="eqnarray">\begin {eqnarray}  \frac {\partial a}{\partial t} &amp; = &amp; i\cdot \left (a\cdot \left (\left |a\right |^{2}-\frac {1}{2}\right )+\frac {1}{2}\frac {\partial ^{2}a}{\partial x^{2}}\right )\,.  \end {eqnarray}
</div>
<!--l. 7557--><p class="indent" >  The solution is subject to Neumann boundary conditions with boundary values at
zero
<div class="eqnarray">\begin {eqnarray}  a_{x}\left (t,\pm x_{m}\right ) &amp; = &amp; 0\,.  \end {eqnarray}
</div>
<!--l. 7564--><p class="indent" >  The equation is a deterministic nonlinear Schrodinger equation, which applies to nonlinear
optics, Bose-Einstein condensates and plasma physics. The observables are \(o_{1}\equiv \left |a\right |^{2}\) and
\(o_{2}\equiv \int _{-x_{m}}^{x_{m}}\left |\frac {\partial }{\partial x}a\right |^{2}dx\),
<!--l. 7569--><p class="indent" >  <a 
 id="paragraph*.11"></a>
<!--l. 7569--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-28200011.4.1"></a>Notes</span>
<ul class="itemize1">     
<li class="itemize">
<!--l. 7571--><p class="noindent" >The boundary conditions are specified with <span 
class="ec-lmri-10x-x-109">p.boundaries</span></li></ul>
<div class="center" 
>
<!--l. 7573--><p class="noindent" >
<div class="doublebox"><div class="minipage"><span 
class="ec-lmtt-10x-x-109">function [e] = SolitonDerivN()</span>
<!--l. 7577--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.dimensions = 2;</span>
<!--l. 7579--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.points = [101,101];</span>
<!--l. 7581--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.ranges = [10,15];</span>
<!--l. 7583--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.initial = @(v,p) sech(p.x);</span>
<!--l. 7585--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.observe</span><span 
class="ec-lmtt-10x-x-109">{1</span><span 
class="ec-lmtt-10x-x-109">} = @(a,p) a.*conj(a);</span>
<!--l. 7587--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.observe</span><span 
class="ec-lmtt-10x-x-109">{2</span><span 
class="ec-lmtt-10x-x-109">} = @(a,p) Int(abs(D1(a,2,p)).</span><span 
class="ec-lmtt-10x-x-109">^2,p);</span>
<!--l. 7590--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.olabels = </span><span 
class="ec-lmtt-10x-x-109">{’</span><span 
class="ec-lmtt-10x-x-109">|a</span><span 
class="ec-lmtt-10x-x-109">|</span><span 
class="ec-lmtt-10x-x-109">^2’,’</span><span 
class="ec-lmtt-10x-x-109">\int </span><span 
class="ec-lmtt-10x-x-109">|da/dx</span><span 
class="ec-lmtt-10x-x-109">|</span><span 
class="ec-lmtt-10x-x-109">^2 dx’</span><span 
class="ec-lmtt-10x-x-109">};</span>
<!--l. 7592--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.name = ’NLS soliton:spectral method + Neumann’;</span>
<!--l. 7594--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.boundaries</span><span 
class="ec-lmtt-10x-x-109">{2</span><span 
class="ec-lmtt-10x-x-109">} = [-1,-1];</span>
<!--l. 7596--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.transverse = </span><span 
class="ec-lmtt-10x-x-109">{3</span><span 
class="ec-lmtt-10x-x-109">};</span>
<!--l. 7598--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.deriv = @(a,</span><span 
class="ec-lmtt-10x-x-109">~,p) 1i*a.*(conj(a).*a);</span>
<!--l. 7600--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.linear = @(p) 0.5*1i*(p.Dx.</span><span 
class="ec-lmtt-10x-x-109">^2-1);</span>
<!--l. 7602--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">e = xspde(p);</span>
<!--l. 7604--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">end</span>                                                                    </div></div>
</div>
                                                                                
                                                                                
<!--l. 7608--><p class="indent" >  <figure class="figure"> 

                                                                                
                                                                                
<a 
 id="x1-282001r7"></a>
                                                                                
                                                                                
<!--l. 7610--><p class="noindent" ><img 
src="xFIGURES/NLS_Neumann.svg" alt="pict"  
 style="width:31.36917em;" >
<!--l. 7612--><p class="noindent" ><img 
src="xFIGURES/NLS_Neumann_deriv.svg" alt="pict"  
 style="width:31.36917em;" >
<figcaption class="caption" ><span class="id">Figure 11.7: </span><span  
class="content">Top figure: 3D plot of the solution for \(\left |a\right |^{2}\) as a function of time and position.
Bottom figure: time evolution of \(\int _{-x_{m}}^{x_{m}}\left |\frac {\partial }{\partial x}a\right |^{2}dx\).</span></figcaption><!--tex4ht:label?: x1-282001r7 -->
                                                                                
                                                                                
<!--l. 7614--><p class="indent" >  </figure>
                                                                                
                                                                                
  
<h4 class="subsectionHead"><span class="titlemark">11.4.2</span>  <a 
 id="x1-28300011.4.2"></a>Planar noise growth</h4>
<!--l. 7620--><p class="noindent" >This solves a (1+2)-dimensional PSDE describing the growth of noise in an extended planar
vector field with additive noise and a diffraction term giving rise to noise dispersion. There are
\(240\) trajectories in the total ensemble. The equation is:
<div class="eqnarray">\begin {eqnarray}  \frac {\partial \mathbf {a}}{\partial t} &amp; = &amp; \frac {i}{2}\left (\frac {\partial ^{2}}{\partial x^{2}}+\frac {\partial ^{2}}{\partial x^{2}}\right )\mathbf {a}+\mathbf {\eta }\left (t,x\right )\,.  \end {eqnarray}
</div>
<!--l. 7628--><p class="indent" >  The initial conditions are that \(\mathbf {a}=\left (\mathbf {v}_{x}+i\mathbf {v}_{y}\right )/\sqrt {2}\), where: \[ \left \langle v_{i}\left (\mathbf {x}\right )v_{j}\left (\mathbf {x}'\right )\right \rangle =\delta \left (\mathbf {x}-\mathbf {x}'\right )\delta _{ij} \] the noise correlations are that \(\mathbf {\eta }=\left (\mathbf {w}_{x}+i\mathbf {w}_{y}\right )/\sqrt {2}\), where:
<div class="eqnarray">\begin {eqnarray}  \left \langle w_{i}\left (\mathbf {r}\right )w_{j}\left (\mathbf {r}'\right )\right \rangle &amp; = &amp; \delta \left (t-t'\right )\delta _{ij}\left (\mathbf {x}-\mathbf {x}'\right )  \end {eqnarray}
</div>
<!--l. 7640--><p class="indent" >  The solution is subject to periodic boundary conditions. The noise correlations for the
second field are specified in momentum space. As there are no filters specified, the noise terms
are delta-correlated in both momentum (\(\mathbf {k}\)) and in space (\(x\)). Using a Fourier transform, one can
show that the exact results for comparison for the correlations within each field are similar in
position and momentum space: \begin {align*}  \left \langle \left |a_{i}\left (t,\mathbf {x}\right )\right |^{2}\right \rangle &amp; =\left (1+t\right )/\Delta A_{x}.\\ \left \langle \left |a_{i}\left (t,\mathbf {k}\right )\right |^{2}\right \rangle &amp; =\left (1+t\right )/\Delta A_{k}.  \end {align*}
<!--l. 7652--><p class="indent" >  Here, \(\Delta A_{x,k}\) is the area of a lattice cell in space or momentum space respectively. This is \(\Delta A_{x}=1/49\) for the
parameters used here. On integration over the whole lattice, the correlation is proportional to \(N_{s}\),
the number of points in the spatial lattice, which is \(35^{2}=1225\) for the default spatial lattice used
here:
<!--l. 7660--><p class="indent" >  \begin {align*}  \int \left \langle \left |a_{i}\left (t,\mathbf {x}\right )\right |^{2}\right \rangle d\mathbf {x}=\int \left \langle \left |a_{i}\left (t,\mathbf {k}\right )\right |^{2}\right \rangle d\mathbf {k} &amp; =N_{s}\left (1+t\right ).  \end {align*}
<!--l. 7663--><p class="indent" >  <a 
 id="paragraph*.12"></a>
<!--l. 7663--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-28400011.4.2"></a>Notes</span>
<ul class="itemize1">     
<li class="itemize">
<!--l. 7665--><p class="noindent" >All three types of ensemble are used
</li>     
<li class="itemize">
<!--l. 7666--><p class="noindent" >The much lower sampling error after integration is evident in the graphs
</li>     
<li class="itemize">
<!--l. 7668--><p class="noindent" >Spatially resolved graphs show larger sampling errors \[ \]</li></ul>
<div class="center" 
>
<!--l. 7672--><p class="noindent" >
                                                                                
                                                                                
<div class="doublebox"><div class="minipage"><span 
class="ec-lmtt-10x-x-109">function [e] = Planar()</span>
<!--l. 7676--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">% e = PLANAR() solves a linear stochastic PDE in (1+2) dimensions</span>
<!--l. 7678--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<!--l. 7680--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">%</span>
<!--l. 7682--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.name = ’Planar noise growth’;</span>
<!--l. 7684--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.dimensions = 3;</span>
<!--l. 7686--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.fields = 2;</span>
<!--l. 7688--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.ranges = [1,5,5];</span>
<!--l. 7690--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.points = 10;</span>
<!--l. 7692--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.noises = [2,2];</span>
<!--l. 7694--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.ensembles = [10,2,12];</span>
<!--l. 7696--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.initial = @Initial;</span>
<!--l. 7698--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.deriv = @D</span><span 
class="ec-lmtt-10x-x-109">_planar;</span>
<!--l. 7700--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.linear = @Linear;</span>
<!--l. 7702--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.observe</span><span 
class="ec-lmtt-10x-x-109">{1</span><span 
class="ec-lmtt-10x-x-109">} = @(a,p) Int(a(1,:).*conj(a(1,:)),p);</span>
<!--l. 7704--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.observe</span><span 
class="ec-lmtt-10x-x-109">{2</span><span 
class="ec-lmtt-10x-x-109">} = @(a,p) Int(a(2,:).*conj(a(2,:)),p.dk,p);</span>
<!--l. 7706--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.observe</span><span 
class="ec-lmtt-10x-x-109">{3</span><span 
class="ec-lmtt-10x-x-109">} = @(a,p) real(Ave(a(1,:).*conj(a(2,:)),p));</span>
<!--l. 7708--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.observe</span><span 
class="ec-lmtt-10x-x-109">{4</span><span 
class="ec-lmtt-10x-x-109">} = @(a,p) a(2,:).*conj(a(2,:));</span>
<!--l. 7710--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.transforms = </span><span 
class="ec-lmtt-10x-x-109">{[0,0,0],[0,1,1],[0,1,1]</span><span 
class="ec-lmtt-10x-x-109">};</span>
<!--l. 7713--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.olabels</span><span 
class="ec-lmtt-10x-x-109">{1</span><span 
class="ec-lmtt-10x-x-109">} = ’</span><span 
class="ec-lmtt-10x-x-109">&#x003C;</span><span 
class="ec-lmtt-10x-x-109">\int</span><span 
class="ec-lmtt-10x-x-109">|a</span><span 
class="ec-lmtt-10x-x-109">_1(x)</span><span 
class="ec-lmtt-10x-x-109">|</span><span 
class="ec-lmtt-10x-x-109">^2 d</span><span 
class="ec-lmtt-10x-x-109">^2x</span><span 
class="ec-lmtt-10x-x-109">&#x003E;’;</span>
<!--l. 7716--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.olabels</span><span 
class="ec-lmtt-10x-x-109">{2</span><span 
class="ec-lmtt-10x-x-109">} = ’</span><span 
class="ec-lmtt-10x-x-109">&#x003C;</span><span 
class="ec-lmtt-10x-x-109">\int</span><span 
class="ec-lmtt-10x-x-109">|a</span><span 
class="ec-lmtt-10x-x-109">_2(k)</span><span 
class="ec-lmtt-10x-x-109">|</span><span 
class="ec-lmtt-10x-x-109">^2 d</span><span 
class="ec-lmtt-10x-x-109">^2k</span><span 
class="ec-lmtt-10x-x-109">&#x003E;’;</span>
<!--l. 7719--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.olabels</span><span 
class="ec-lmtt-10x-x-109">{3</span><span 
class="ec-lmtt-10x-x-109">} = ’</span><span 
class="ec-lmtt-10x-x-109">&#x003C;</span><span 
class="ec-lmtt-10x-x-109">&#x003C; a</span><span 
class="ec-lmtt-10x-x-109">_1(k)a</span><span 
class="ec-lmtt-10x-x-109">^*</span><span 
class="ec-lmtt-10x-x-109">_2(k)</span><span 
class="ec-lmtt-10x-x-109">&#x003E;</span><span 
class="ec-lmtt-10x-x-109">&#x003E;’;</span>
<!--l. 7722--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.olabels</span><span 
class="ec-lmtt-10x-x-109">{4</span><span 
class="ec-lmtt-10x-x-109">} = ’</span><span 
class="ec-lmtt-10x-x-109">&#x003C;</span><span 
class="ec-lmtt-10x-x-109">|a</span><span 
class="ec-lmtt-10x-x-109">_2(x)</span><span 
class="ec-lmtt-10x-x-109">|</span><span 
class="ec-lmtt-10x-x-109">^2</span><span 
class="ec-lmtt-10x-x-109">&#x003E;’;</span>
<!--l. 7724--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.compare</span><span 
class="ec-lmtt-10x-x-109">{1</span><span 
class="ec-lmtt-10x-x-109">} = @(p) (1+p.t)*p.nspace;</span>
<!--l. 7726--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.compare</span><span 
class="ec-lmtt-10x-x-109">{2</span><span 
class="ec-lmtt-10x-x-109">} = @(p) (1+p.t)*p.nspace;</span>
<!--l. 7728--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.compare</span><span 
class="ec-lmtt-10x-x-109">{3</span><span 
class="ec-lmtt-10x-x-109">} = @(p) 0.0;</span>
<!--l. 7730--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">e = xspde(p);</span>
<!--l. 7732--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">end</span> <br 
class="newline" /> 
<!--l. 7735--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">function a0 = Initial(v,</span><span 
class="ec-lmtt-10x-x-109">~)</span>
<!--l. 7737--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">a0(1,:) = (v(1,:)+1i*v(2,:))/sqrt(2);</span>
<!--l. 7739--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">a0(2,:) = (v(3,:)+1i*v(4,:))/sqrt(2);</span>
<!--l. 7741--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">end</span> <br 
class="newline" /> 
<!--l. 7745--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">function da = D</span><span 
class="ec-lmtt-10x-x-109">_planar(</span><span 
class="ec-lmtt-10x-x-109">~,w,</span><span 
class="ec-lmtt-10x-x-109">~) %%Derivatives</span>
<!--l. 7747--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">da(1,:) = (w(1,:)+1i*w(2,:))/sqrt(2);</span>
<!--l. 7749--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">da(2,:) = (w(3,:)+1i*w(4,:))/sqrt(2);</span>
<!--l. 7751--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">end </span> <br 
class="newline" /> 
<!--l. 7754--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">function L = Linear(p)</span>
<!--l. 7756--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">lap = p.Dx.</span><span 
class="ec-lmtt-10x-x-109">^2+p.Dy.</span><span 
class="ec-lmtt-10x-x-109">^2;</span>
<!--l. 7758--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">L(1,:) = 1i*0.5*lap(:);</span>
<!--l. 7760--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">L(2,:) = 1i*0.5*lap(:);</span>
<!--l. 7762--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">end</span>                                                                    </div></div>
                                                                                
                                                                                
</div>
<!--l. 7766--><p class="indent" >  <figure class="figure"> 

                                                                                
                                                                                
<a 
 id="x1-284001r8"></a>
                                                                                
                                                                                
<!--l. 7768--><p class="noindent" ><img 
src="xFIGURES/Planar1.svg" alt="pict"  
 style="width:31.36917em;" >
<!--l. 7770--><p class="noindent" ><img 
src="xFIGURES/Planar2.svg" alt="pict"  
 style="width:31.36917em;" >
<figcaption class="caption" ><span class="id">Figure 11.8: </span><span  
class="content">Top and bottom figure: Time evolution of the integrated modulus square of
the first and second field, respectively. The solid lines indicate upper and lower bounds
of the stochastic error, which the dashed lines indicate theoretical predictions.</span></figcaption><!--tex4ht:label?: x1-284001r8 -->
                                                                                
                                                                                
<!--l. 7774--><p class="indent" >  </figure>
<!--l. 7776--><p class="indent" >  <figure class="figure"> 

                                                                                
                                                                                
<a 
 id="x1-284002r9"></a>
                                                                                
                                                                                
<!--l. 7778--><p class="noindent" ><img 
src="xFIGURES/Planar4image.svg" alt="pict"  
 style="width:31.36917em;" >
<!--l. 7780--><p class="noindent" ><img 
src="xFIGURES/Planar4.svg" alt="pict"  
 style="width:31.36917em;" >
<figcaption class="caption" ><span class="id">Figure 11.9: </span><span  
class="content">Top figure: 3D plot of the modulus square of \(a_{2}\) at \(t=1\) as a function of \(x\) and \(y\).
Bottom figure: 3D plot of the modulus square of \(a_{2}\) for \(y=0\) as a function of \(x\) and \(t\).</span></figcaption><!--tex4ht:label?: x1-284002r9 -->
                                                                                
                                                                                
<!--l. 7783--><p class="indent" >  </figure>
                                                                                
                                                                                
  
<h4 class="subsectionHead"><span class="titlemark">11.4.3</span>  <a 
 id="x1-28500011.4.3"></a>Gross-Pitaevskii equation with vortex formation</h4>
<!--l. 7789--><p class="noindent" >This solves a (1+2)-dimensional PDE called the Gross-Pitaevski equation. In addition to
the standard GPE terms, it includes tbe vortex forming term \(\left (\mathbf {x}\times \nabla \right )a\). There is just one
ensemble member, to demonstrate how a single trajectory can be imaged. The equation
is:
<div class="eqnarray">\begin {eqnarray}  \frac {\partial a}{\partial t} &amp; = &amp; \left (\frac {1}{2}\nabla ^{2}a-\left \Vert \left (\left (V\left (\mathbf {x}\right )+200\left |a\right |^{2}\right )+0.6i\cdot \left (\mathbf {x}\times \nabla \right )\right )a\right \Vert \right )\nonumber \\ V\left (\mathbf {x}\right ) &amp; = &amp; 0.35\left (x^{2}+y^{2}\right )\nonumber \\ \left \Vert b\left (\mathbf {x}\right )\right \Vert &amp; = &amp; \frac {b\left (\mathbf {x}\right )}{\int \left |b\right |^{2}d\mathbf {x}}\,.  \end {eqnarray}
</div>
<!--l. 7801--><p class="indent" >  Here,\(\left \Vert \cdot \right \Vert \) is the normalized derivative and \(\times \) indicates the two-dimensional cross-product. The
system is initialized as
<div class="eqnarray">\begin {eqnarray}  a\left (t=0,\mathbf {x}\right ) &amp; = &amp; 0.1\cdot \exp \left (-V\left (\mathbf {x}\right )\right )\,.  \end {eqnarray}
</div>
<!--l. 7810--><p class="indent" >  <a 
 id="paragraph*.13"></a>
<!--l. 7810--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-28600011.4.3"></a>Notes</span>
<ul class="itemize1">     
<li class="itemize">
<!--l. 7812--><p class="noindent" >This is a deterministic pde case
</li>     
<li class="itemize">
<!--l. 7813--><p class="noindent" >The \(15\) intermediate <span 
class="ec-lmri-10x-x-109">steps </span>used are necessary to reduce integration errors
</li>     
<li class="itemize">
<!--l. 7815--><p class="noindent" >The trap potential is an inline function, and is not a parameter
</li>     
<li class="itemize">
<!--l. 7816--><p class="noindent" >Normalisation is used because otherwise particle number is not conserved
</li>     
<li class="itemize">
<!--l. 7817--><p class="noindent" >The output includes transverse <span 
class="ec-lmri-10x-x-109">images </span>to show how the vortices develop
</li>     
<li class="itemize">
<!--l. 7819--><p class="noindent" >Different <span 
class="ec-lmri-10x-x-109">imagetypes </span>are used to show different 3D features</li></ul>
                                                                                
                                                                                
<div class="center" 
>
<!--l. 7821--><p class="noindent" >
<div class="doublebox"><div class="minipage"><span 
class="ec-lmtt-10x-x-109">function [e] = GPEvortex2D()</span>
<!--l. 7826--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">% e = GPEvortex2D() tests xSPDE for a lattice of superfluid</span>
<span 
class="ec-lmtt-10x-x-109">vortices</span>
<!--l. 7828--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">% Tests a 2D GPE with vortices plus rotation</span>
<!--l. 7830--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<!--l. 7832--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">%</span>
<!--l. 7834--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.name = ’GPEvortex2D’;</span>
<!--l. 7836--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.dimensions = 3;</span>
<!--l. 7838--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.fields = 1;</span>
<!--l. 7840--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.points = [50,40,40];</span>
<!--l. 7842--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.ranges = [15,16,16];</span>
<!--l. 7844--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.steps = 15;</span>
<!--l. 7846--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">g = 200;</span>
<!--l. 7848--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">om = 0.6;</span>
<!--l. 7850--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">L = @(a,p) 1i*(p.x.*xd(a,p.Dy,p)-p.y.*xd(a,p.Dx,p));</span>
<!--l. 7852--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">V = @(p) 0.35*(p.x.</span><span 
class="ec-lmtt-10x-x-109">^2+p.y.</span><span 
class="ec-lmtt-10x-x-109">^2);</span>
<!--l. 7854--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.initial = @(v,p) 0.1*exp(-V(p));</span>
<!--l. 7856--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">rho = @(a) g*conj(a).*a;</span>
<!--l. 7858--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.deriv = @normda;</span>
<!--l. 7860--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.da1 = @(a,w,p) -a.*(V(p)+rho(a))+om*L(a,p);</span>
<!--l. 7862--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.linear = @(p) 0.5*(p.Dx.</span><span 
class="ec-lmtt-10x-x-109">^2+p.Dy.</span><span 
class="ec-lmtt-10x-x-109">^2);</span>
<!--l. 7864--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.observe</span><span 
class="ec-lmtt-10x-x-109">{1</span><span 
class="ec-lmtt-10x-x-109">} = @(a,p) a(1,:).*conj(a(1,:));</span>
<!--l. 7866--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.observe</span><span 
class="ec-lmtt-10x-x-109">{2</span><span 
class="ec-lmtt-10x-x-109">} = @(a,p) a(1,:).*conj(a(1,:));</span>
<!--l. 7868--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.images = </span><span 
class="ec-lmtt-10x-x-109">{2,2</span><span 
class="ec-lmtt-10x-x-109">};</span>
<!--l. 7870--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.imagetype = </span><span 
class="ec-lmtt-10x-x-109">{1,2</span><span 
class="ec-lmtt-10x-x-109">};</span>
<!--l. 7873--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.olabels = </span><span 
class="ec-lmtt-10x-x-109">{’</span><span 
class="ec-lmtt-10x-x-109">|a</span><span 
class="ec-lmtt-10x-x-109">|</span><span 
class="ec-lmtt-10x-x-109">^2’,’</span><span 
class="ec-lmtt-10x-x-109">|a</span><span 
class="ec-lmtt-10x-x-109">|</span><span 
class="ec-lmtt-10x-x-109">^2’</span><span 
class="ec-lmtt-10x-x-109">};</span>
<!--l. 7875--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">e = xspde(p);</span>
<!--l. 7877--><p class="noindent" > 
<!--l. 7879--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">function b = normda(a,w,p)</span>
<!--l. 7881--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">% b = NORMDA(a,z,r) is a normalized derivative</span>
<!--l. 7883--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">% Takes a derivative and returns a normalized step</span>
<!--l. 7885--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">b = a+p.da1(a,w,p)*p.dtr;</span>
<!--l. 7887--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">norm = sqrt(Int(abs(b).</span><span 
class="ec-lmtt-10x-x-109">^2,p.dx,p));</span>
<!--l. 7889--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">b = (b./norm-a)/p.dtr;</span>
<!--l. 7891--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">end</span>
<!--l. 7893--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">end</span>                                                                    </div></div>
</div>
<!--l. 7897--><p class="indent" >  <figure class="figure"> 

                                                                                
                                                                                
<a 
 id="x1-286001r10"></a>
                                                                                
                                                                                
<!--l. 7899--><p class="noindent" ><img 
src="xFIGURES/GPE-vortex-example1.svg" alt="pict"  
 style="width:31.36917em;" >
<!--l. 7901--><p class="noindent" ><img 
src="xFIGURES/GPE-vortex-example2.svg" alt="pict"  
 style="width:31.36917em;" >
<figcaption class="caption" ><span class="id">Figure 11.10: </span><span  
class="content">Top and bottom figure: The computed solution for \(\left |a\right |^{2}\) at \(t=15\) as a function of \(x,y\)
as a 3D plot (top) and as a color map (bottom).</span></figcaption><!--tex4ht:label?: x1-286001r10 -->
                                                                                
                                                                                
<!--l. 7904--><p class="indent" >  </figure>
<!--l. 7906--><p class="indent" >  <figure class="figure"> 

                                                                                
                                                                                
<a 
 id="x1-286002r11"></a>
                                                                                
                                                                                
<!--l. 7908--><p class="noindent" ><img 
src="xFIGURES/GPE-vortex-example3.svg" alt="pict"  
 style="width:31.36917em;" >
<!--l. 7910--><p class="noindent" ><img 
src="xFIGURES/GPE-vortex-example4.svg" alt="pict"  
 style="width:31.36917em;" >
<figcaption class="caption" ><span class="id">Figure 11.11: </span><span  
class="content">Top and bottom figure: The computed solution for \(\left |a\right |^{2}\) for \(y=0\) as a function of \(x,t\)
as a 3D plot (top) and as a color map (bottom).</span></figcaption><!--tex4ht:label?: x1-286002r11 -->
                                                                                
                                                                                
<!--l. 7913--><p class="indent" >  </figure>
<!--l. 7915--><p class="indent" >
                                                                                
                                                                                
  
<h4 class="subsectionHead"><span class="titlemark">11.4.4</span>  <a 
 id="x1-28700011.4.4"></a>Heat equation with finite-difference and propagators </h4>
<!--l. 7919--><p class="noindent" >This very simple example solves a (1+1)-dimensional PDE with an initial condition of \(\mathbf {a}\left (t=0,x\right )=\mathbf {f}\left (x\right )\)
and
<div class="eqnarray">\begin {eqnarray}  \frac {\partial \mathbf {a}}{\partial t} &amp; = &amp; \frac {\partial ^{2}\mathbf {a}}{\partial x^{2}}\,.  \end {eqnarray}
</div>
<!--l. 7926--><p class="indent" >  The solution is subject to periodic boundary conditions or Dirichlet and/or Neumann with
boundary values at zero, so that \(a\left (t,\pm x_{m}\right )=0\,\) or \(\partial a/\partial x\left (t,\pm x_{m}\right )=0\). Each component has different combinations of boundary
types. Using spectral methods the solutions here are exact, up to round-off errors of order \(10^{-15}\),
and are also much faster than with finite differences, which is demonstrated in the
example.
<!--l. 7934--><p class="indent" >  In all cases the grid range is from \(x=0\) to \(x=\pi ,\) and the time duration is from \(t=0\) to \(t=4\). In the examples,
the spectral propagation error is reduced by more than \(10^{10}\) and the time is reduced by a factor of \(20\)
compared to the finite-difference methods. The periodic method has boundaries just outside
the grid.
<!--l. 7940--><p class="noindent" ><span class="likeparagraphHead"><a 
 id="x1-28800011.4.4"></a>Dirichlet-Dirichlet</span>
Here \(a_{x}(0)=a_{x}(\pi )=0\), then the exact solution has the form: \begin {align}  a &amp; =\sum _{n=1}^{\infty }S_{n}\sin \left (nx\right )e^{-n^{2}t}.  \end {align}
<!--l. 7946--><p class="indent" >  Suppose that \begin {equation}  a(x,0)=4\sin \left (x\right )+\sin \left (2x\right ),  \end {equation}
<!--l. 7951--><p class="indent" >  For this case: \begin {equation}  a(x,t)=4\sin \left (x\right )e^{-t}+\sin \left (2x\right )e^{-4t}.  \end {equation}
<!--l. 7957--><p class="noindent" ><span class="likeparagraphHead"><a 
 id="x1-28900011.4.4"></a>Neumann-Neumann</span>
with \(a(0)=a(\pi )=0\), then the exact solution has the form: \begin {align}  a &amp; =\sum _{n=0}^{\infty }C_{n}\cos \left (nx\right )e^{-n^{2}t}.  \end {align}
<!--l. 7963--><p class="indent" >  Suppose that \begin {equation}  a(x,0)=5+4\cos \left (x\right )+\cos \left (2x\right ),  \end {equation}
<!--l. 7968--><p class="indent" >  For this case: \begin {equation}  a(x,t)=5+4\cos \left (x\right )e^{-t}+\cos \left (2x\right )e^{-4t}.  \end {equation}
<!--l. 7974--><p class="noindent" ><span class="likeparagraphHead"><a 
 id="x1-29000011.4.4"></a>Dirichlet-Neumann</span>
Here \(a(0)=a_{x}(\pi )=0\), then the exact solution has the form: \begin {align}  a &amp; =\sum _{n=1}^{\infty }S_{n}\sin \left ((2n-1)x/2\right )e^{-(2n-1)^{2}t/4}.  \end {align}
<!--l. 7980--><p class="indent" >  Suppose that \begin {equation}  a(x,0)=4\sin \left (x/2\right )+\sin \left (3x/2\right ),  \end {equation}
<!--l. 7985--><p class="indent" >  For this case: \begin {equation}  u(x,0)=4\sin \left (x/2\right )e^{-t/4}+\sin \left (3x/2\right )e^{-9t/4}.  \end {equation}
                                                                                
                                                                                
<!--l. 7991--><p class="noindent" ><span class="likeparagraphHead"><a 
 id="x1-29100011.4.4"></a>Neumann-Dirichlet</span>
Here \(a_{x}(0)=a(\pi )=0\), then the general solution has the form: \begin {align}  a &amp; =\sum _{n=1}^{\infty }C_{n}\cos \left ((2n-1)x/2\right )e^{-(2n-1)^{2}t/4}.  \end {align}
<!--l. 7997--><p class="indent" >  Suppose that \begin {equation}  a(x,0)=4\cos \left (x/2\right )+\cos \left (3x/2\right ).  \end {equation}
<!--l. 8002--><p class="indent" >  For this case: \begin {equation}  a(x,t)=4\cos \left (x/2\right )e^{-t/4}+\cos \left (3x/2\right )e^{-9t/4}.  \end {equation}
<!--l. 8008--><p class="noindent" ><span class="likeparagraphHead"><a 
 id="x1-29200011.4.4"></a>Periodic</span>
Here \(a(0)=a(\epsilon \pi )\), where \(\epsilon =N/\left (N-1\right )\) accounts for the periodic boundaries being outside the grid range, then the
general solution has the form: \begin {align}  a &amp; =\sum _{n=1}^{\infty }S_{n}\sin \left (2nx\right )e^{-4n^{2}t/\epsilon ^{2}}\nonumber \\ &amp; +\sum _{n=0}^{\infty }C_{n}\cos \left (2nx\right )e^{-4n^{2}t/\epsilon ^{2}}.  \end {align}
<!--l. 8017--><p class="indent" >  Suppose that \begin {equation}  a(x,0)=2+\cos \left (2x/\epsilon \right )+\sin \left (4x/\epsilon \right ).  \end {equation}
<!--l. 8022--><p class="indent" >  For this case: \begin {equation}  u(x,0)=2+2\cos \left (2x/\epsilon \right )e^{-4t/\epsilon ^{2}}+\sin \left (4x/\epsilon \right )e^{-16t/\epsilon ^{2}}.  \end {equation}
<!--l. 8028--><p class="indent" >  <a 
 id="paragraph*.14"></a>
<!--l. 8028--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-29300011.4.4"></a>Notes</span>
<ul class="itemize1">     
<li class="itemize">
<!--l. 8030--><p class="noindent" >This is another deterministic pde case, although noise can be added
</li>     
<li class="itemize">
<!--l. 8031--><p class="noindent" >Different boundary conditions apply to each component
</li>     
<li class="itemize">
<!--l. 8032--><p class="noindent" >Sequential integration is used, but the initial condition is just recycled.
</li>     
<li class="itemize">
<!--l. 8034--><p class="noindent" >In <span 
class="ec-lmri-10x-x-109">p1</span>, the \(40\) intermediate <span 
class="ec-lmri-10x-x-109">steps </span>are necessary to reduce finite-difference errors</li></ul>
                                                                                
                                                                                
<div class="doublebox"><div class="minipage"><span 
class="ec-lmtt-10x-x-109">function [e] = Boundaries()</span>
<!--l. 8040--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.dimensions = 2;</span>
<!--l. 8042--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.points = [51,51];</span>
<!--l. 8044--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.order = 0;</span>
<!--l. 8046--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.verbose = 1;</span>
<!--l. 8048--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.fields = 5;</span>
<!--l. 8050--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.ranges = [4,pi];</span>
<!--l. 8052--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.origins = [0,0];</span>
<!--l. 8054--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.initial = @heat</span><span 
class="ec-lmtt-10x-x-109">_in;</span>
<!--l. 8056--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.observe = </span><span 
class="ec-lmtt-10x-x-109">{@(a,p) a(1,:),@(a,p) a(2,:),@(a,p) a(3,:)...</span>
<!--l. 8058--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">@(a,p) a(4,:),@(a,p) a(5,:)</span><span 
class="ec-lmtt-10x-x-109">};</span>
<!--l. 8060--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.compare = </span><span 
class="ec-lmtt-10x-x-109">{@heat</span><span 
class="ec-lmtt-10x-x-109">_1,@heat</span><span 
class="ec-lmtt-10x-x-109">_2,@heat</span><span 
class="ec-lmtt-10x-x-109">_3,@heat</span><span 
class="ec-lmtt-10x-x-109">_4,@heat</span><span 
class="ec-lmtt-10x-x-109">_5</span><span 
class="ec-lmtt-10x-x-109">};</span>
<!--l. 8062--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.diffplot = </span><span 
class="ec-lmtt-10x-x-109">{1,1,1,1,1</span><span 
class="ec-lmtt-10x-x-109">};</span>
<!--l. 8064--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.olabels = </span><span 
class="ec-lmtt-10x-x-109">{’a, DD’,’a, NN’,’a, DN’,’a, ND’,’a, PP’</span><span 
class="ec-lmtt-10x-x-109">};</span>
<!--l. 8066--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.name = ’Heat test, spectral’;</span>
<!--l. 8068--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.boundaries</span><span 
class="ec-lmtt-10x-x-109">{2</span><span 
class="ec-lmtt-10x-x-109">}= [1,1;-1,-1;1,-1;-1,1;0,0];</span>
<!--l. 8070--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.linear = @(p) p.Dx.</span><span 
class="ec-lmtt-10x-x-109">^2;</span>
<!--l. 8072--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p1 = p;</span>
<!--l. 8074--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p1.linear = @(p) [];</span>
<!--l. 8076--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p1.deriv = @(a,w,p) D2(a,2,p);</span>
<!--l. 8078--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p1.steps = 40;</span>
<!--l. 8081--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p1.transfer = @(</span><span 
class="ec-lmtt-10x-x-109">~,p,</span><span 
class="ec-lmtt-10x-x-109">~,</span><span 
class="ec-lmtt-10x-x-109">~) heat</span><span 
class="ec-lmtt-10x-x-109">_in(0,p);</span>
<!--l. 8083--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p1.name = ’Heat test, finite diffs’;</span>
<!--l. 8085--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">e = xspde(</span><span 
class="ec-lmtt-10x-x-109">{p,p1</span><span 
class="ec-lmtt-10x-x-109">});</span>
<!--l. 8087--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">end</span>
<!--l. 8089--><p class="noindent" > 
<!--l. 8091--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">function a = heat</span><span 
class="ec-lmtt-10x-x-109">_in(</span><span 
class="ec-lmtt-10x-x-109">~,p)</span>
<!--l. 8093--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">a(1,:) = 4*sin(p.x)+sin(2*p.x);</span>
<!--l. 8095--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">a(2,:) = 5+4*cos(p.x)+cos(2*p.x);</span>
<!--l. 8097--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">a(3,:) = 4*sin(p.x/2)+sin(3*p.x/2);</span>
<!--l. 8099--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">a(4,:) = 4*cos(p.x/2)+cos(3*p.x/2);</span>
<!--l. 8101--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">a(5,:) = 2+cos(2*p.x/1.02)+sin(4*p.x/1.02);</span>
<!--l. 8103--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">end</span>
<!--l. 8105--><p class="noindent" > 
<!--l. 8107--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">function o = heat</span><span 
class="ec-lmtt-10x-x-109">_1(p)</span>
<!--l. 8109--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">o = 4*sin(p.x).*exp(-p.t)+sin(2*p.x).*exp(-4*p.t);</span>
<!--l. 8111--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">end</span>
<!--l. 8113--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">function o = heat</span><span 
class="ec-lmtt-10x-x-109">_2(p)</span>
<!--l. 8116--><p class="noindent" > <span 
class="ec-lmtt-10x-x-109">o = 5+4*cos(p.x).*exp(-p.t)+cos(2*p.x).*exp(-4*p.t);</span>
<!--l. 8118--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">end</span>
<!--l. 8120--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">function o = heat</span><span 
class="ec-lmtt-10x-x-109">_3(p)</span>
<!--l. 8123--><p class="noindent" > <span 
class="ec-lmtt-10x-x-109">o = 4*sin(p.x/2).*exp(-p.t/4)+sin(3*p.x/2).*exp(-9*p.t/4);</span>
<!--l. 8125--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">end</span>
<!--l. 8127--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">function o = heat</span><span 
class="ec-lmtt-10x-x-109">_4(p)</span>
<!--l. 8130--><p class="noindent" > <span 
class="ec-lmtt-10x-x-109">o = 4*cos(p.x/2).*exp(-p.t/4)+cos(3*p.x/2).*exp(-9*p.t/4);</span>
<!--l. 8132--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">end</span>
<!--l. 8134--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">function o = heat</span><span 
class="ec-lmtt-10x-x-109">_5(p)</span>
<!--l. 8136--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">o = 2+cos(2*p.x/1.02).*exp(-4*p.t/1.02</span><span 
class="ec-lmtt-10x-x-109">^2)+...</span>
<!--l. 8139--><p class="noindent" > <span 
class="ec-lmtt-10x-x-109">sin(4*p.x/1.02).*exp(-16*p.t/1.02</span><span 
class="ec-lmtt-10x-x-109">^2);</span>
<!--l. 8141--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">end</span>                                                                    </div></div>
                                                                                
                                                                                
<!--l. 8144--><p class="indent" >
                                                                                
                                                                                
<div class="center" 
>
<!--l. 8145--><p class="noindent" >
</div>
<!--l. 8149--><p class="indent" >  <figure class="figure"> 

                                                                                
                                                                                
<a 
 id="x1-293001r12"></a>
                                                                                
                                                                                
<!--l. 8151--><p class="noindent" ><img 
src="xFIGURES/Boundaries.svg" alt="pict"  
 style="width:31.36917em;" ><br />
<img 
src="xFIGURES/BoundariesNN.svg" alt="pict"  
 style="width:31.36917em;" >
<figcaption class="caption" ><span class="id">Figure 11.12:   </span><span  
class="content">Top   figure:   Spectral   solution   for   \(a\)   as   a   function   of   time   and
position with Dirichlet-Dirichlet boundaries. Bottom figure: Plot of the solution with
Neumann-Neumann boundaries.</span></figcaption><!--tex4ht:label?: x1-293001r12 -->
                                                                                
                                                                                
<!--l. 8157--><p class="indent" >  </figure>
                                                                                
                                                                                
  
<h3 class="sectionHead"><span class="titlemark">11.5</span>  <a 
 id="x1-29400011.5"></a>Projection examples</h3>
<!--l. 8163--><p class="noindent" >  
<h4 class="subsectionHead"><span class="titlemark">11.5.1</span>  <a 
 id="x1-29500011.5.1"></a>SDE with catenoid projection</h4>
<!--l. 8165--><p class="noindent" >This solves an SDE with 3 field variables \(\mathbf {a}=\left (a_{1},a_{2},a_{3}\right )^{T}\). The Stratonovich diffusion equation is
<div class="eqnarray">\begin {eqnarray}  \frac {\partial \mathbf {a}}{\partial t} &amp; = &amp; \mathcal {P}_{\mathbf {a}}^{\parallel }\left [\mathbf {w}\right ]\,,  \end {eqnarray}
</div>
<!--l. 8170--><p class="indent" >  where \(\mathcal {P}_{\mathbf {a}}^{\parallel }\left [\cdot \right ]\) indicates a projected onto the surface of a catenoid manifold defined by
<div class="eqnarray">\begin {eqnarray}  f &amp; =x_{1}^{2}+x_{2}^{2}-\sinh ^{2}\left (x_{3}\right )-1 &amp; =0\,.  \end {eqnarray}
</div>
<!--l. 8175--><p class="indent" >  The initial condition is given by \(\mathbf {a}\left (o\right )=\left (1,0,0\right )^{T}\). Here \(\mathbf {w}=\left (w_{1},w_{2},w_{3}\right )^{T}\) consists of 3 independent noise variables
<!--l. 8179--><p class="indent" >  <a 
 id="paragraph*.15"></a>
<!--l. 8179--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-29600011.5.1"></a>Notes</span>
<ul class="itemize1">     
<li class="itemize">
<!--l. 8181--><p class="noindent" >This is a projected sde case
</li>     
<li class="itemize">
<!--l. 8182--><p class="noindent" >The Euclidean distance from the initial point is computed
</li>     
<li class="itemize">
<!--l. 8183--><p class="noindent" >This is compared with the predicted analytic value \(\left \langle R^{2}\right \rangle =2t\).</li></ul>
<div class="center" 
>
<!--l. 8185--><p class="noindent" >
                                                                                
                                                                                
<div class="doublebox"><div class="minipage"><span 
class="ec-lmtt-10x-x-109">function [e] = Catenoid</span>
<!--l. 8189--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">% e = CATENOID() simulates catenoid diffusion.</span>
<!--l. 8191--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<!--l. 8193--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">%</span>
<!--l. 8195--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.name = ’3D Catenoid diffusion’;</span>
<!--l. 8197--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.iterproj = 3;</span>
<!--l. 8199--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.X0 = [1,0,0]’;</span>
<!--l. 8201--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.fields = 3;</span>
<!--l. 8203--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.ranges = 5;</span>
<!--l. 8205--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.points = 51;</span>
<!--l. 8207--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.ensembles = [400, 10];</span>
<!--l. 8209--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.compare</span><span 
class="ec-lmtt-10x-x-109">{2</span><span 
class="ec-lmtt-10x-x-109">} = @(p) 2*p.t;</span>
<!--l. 8211--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.deriv = @(a, w, p) w;</span>
<!--l. 8213--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.initial = @(w, p) p.X0;</span>
<!--l. 8215--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.observe</span><span 
class="ec-lmtt-10x-x-109">{2</span><span 
class="ec-lmtt-10x-x-109">} = @(a, p) sum((p.X0-a).</span><span 
class="ec-lmtt-10x-x-109">^2,1);</span>
<!--l. 8217--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.diffplot</span><span 
class="ec-lmtt-10x-x-109">{2</span><span 
class="ec-lmtt-10x-x-109">} = 1;</span>
<!--l. 8219--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.function</span><span 
class="ec-lmtt-10x-x-109">{1</span><span 
class="ec-lmtt-10x-x-109">} = @(o, p) o</span><span 
class="ec-lmtt-10x-x-109">{2</span><span 
class="ec-lmtt-10x-x-109">}.</span><span 
class="ec-lmtt-10x-x-109">^2;</span>
<!--l. 8223--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.olabels = </span><span 
class="ec-lmtt-10x-x-109">{’</span><span 
class="ec-lmtt-10x-x-109">\langle R</span><span 
class="ec-lmtt-10x-x-109">^2 </span><span 
class="ec-lmtt-10x-x-109">\rangle</span><span 
class="ec-lmtt-10x-x-109">^2’,’</span><span 
class="ec-lmtt-10x-x-109">\langle R</span><span 
class="ec-lmtt-10x-x-109">^2 </span><span 
class="ec-lmtt-10x-x-109">\rangle’</span><span 
class="ec-lmtt-10x-x-109">};</span>
<!--l. 8225--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.project = @Catproj;</span>
<!--l. 8227--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">p.method = @MPnproj;</span>
<!--l. 8229--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">e = xspde(p);</span>
<!--l. 8231--><p class="noindent" ><span 
class="ec-lmtt-10x-x-109">end</span>                                                                    </div></div>
</div>
<div class="center" 
>
<!--l. 8235--><p class="noindent" >
<!--l. 8236--><p class="noindent" ><figure class="figure"> 
<a 
 id="x1-296001r13"></a> <img 
src="xFIGURES/Catenoid-example1.svg" alt="pict"  
 style="width:31.36917em;" >
<figcaption class="caption" ><span class="id">Figure 11.13: </span><span  
class="content">Computed time evolution of the squared Euclidean distance \(\left |\mathbf {x}_{0}-\mathbf {x}\left (t\right )\right |^{2}\), where \(\mathbf {x}_{0}=\left (1,0,0\right )^{T}\), as
a function of time. The solid lines indicate the stochastic error bounds while the dashed
line indicates the theoretical prediction.</span></figcaption><!--tex4ht:label?: x1-296001r13 -->
<!--l. 8241--><p class="noindent" ></figure>
</div>
                                                                                
                                                                                
                                                                                
                                                                                
<!--l. 1--><p class="indent" >  <a 
 id="chapter*.16"></a>
<!--l. 1--><p class="noindent" >  
<h2 class="likechapterHead"><a 
 id="x1-29700011.5.1"></a>Bibliography</h2>
<div class="thebibliography">    
<p class="bibitem" ><span class="biblabel">
[1]
<span class="bibsp">   </span></span><a 
 id="Xkiesewetter2016xspde"></a>Simon  Kiesewetter,  Rodney  Polkinghorne,  Bogdan  Opanchuk,  and  Peter D
Drummond.    xspde:  Extensible  software  for  stochastic  equations.    <span 
class="ec-lmri-10x-x-109">SoftwareX</span>,
5:12–15, 2016.
</p>    
<p class="bibitem" ><span class="biblabel">
[2]
<span class="bibsp">   </span></span><a 
 id="XLangevin1908-theorie"></a>Paul Langevin.   Sur la théorie du mouvement brownien.   <span 
class="ec-lmri-10x-x-109">C. R. Acad. Sci.</span>
<span 
class="ec-lmri-10x-x-109">(Paris)</span>, 146:530–533, 1908.
</p>    
<p class="bibitem" ><span class="biblabel">
[3]
<span class="bibsp">   </span></span><a 
 id="XKaratzas1991-brownian"></a>Ioannis Karatzas and Steven Shreve. <span 
class="ec-lmri-10x-x-109">Brownian motion and stochastic calculus</span>.
Springer, 2nd edition, 1991.
</p>    
<p class="bibitem" ><span class="biblabel">
[4]
<span class="bibsp">   </span></span><a 
 id="Xgardinerhandbook2004"></a>C W Gardiner. <span 
class="ec-lmri-10x-x-109">Handbook of stochastic methods(for physics, chemistry and the</span>
<span 
class="ec-lmri-10x-x-109">natural sciences)</span>. Springer-Verlag, Berlin, 2004.
</p>    
<p class="bibitem" ><span class="biblabel">
[5]
<span class="bibsp">   </span></span><a 
 id="XGlasserman2010-monte"></a>Paul Glasserman.  <span 
class="ec-lmri-10x-x-109">Monte Carlo Methods in Financial Engineering</span>.  Springer,
reprint edition, 2010.
</p>    
<p class="bibitem" ><span class="biblabel">
[6]
<span class="bibsp">   </span></span><a 
 id="XDrummond2014"></a>Peter D. Drummond and M. Hillery. <span 
class="ec-lmri-10x-x-109">The Quantum Theory of Nonlinear Optics</span>.
Cambridge University Press, Cambridge, 2014.
</p>    
<p class="bibitem" ><span class="biblabel">
[7]
<span class="bibsp">   </span></span><a 
 id="XDrummond1991"></a>Peter D. Drummond and I. K. Mortimer. <span 
class="ec-lmri-10x-x-109">J. Comp. Phys.</span>, 93:144–170, 1991.
                                                                                
                                                                                
    
</p>
<p class="bibitem" ><span class="biblabel">  
[8]
<span class="bibsp">   </span></span><a 
 id="XKloeden1992"></a>Peter E.  Kloeden  and  Eckhard  Platen.    <span 
class="ec-lmri-10x-x-109">Numerical  Solution  of  Stochastic</span>
<span 
class="ec-lmri-10x-x-109">Differential Equations</span>. Springer-Verlag, Berlin, 1992.
</p>    
<p class="bibitem" ><span class="biblabel">
[9]
<span class="bibsp">   </span></span><a 
 id="XWerner1997"></a>M. J.  Werner  and  Peter D.  Drummond.    Robust  Algorithms  for  Solving
Stochastic Partial Differential Equations. <span 
class="ec-lmri-10x-x-109">J. Comput. Phys.</span>, 132(2):312–326, 1997.
</p>    
<p class="bibitem" ><span class="biblabel">
[10]
<span class="bibsp">   </span></span><a 
 id="Xburrage2006comment"></a>Kevin Burrage, Pamela Burrage, Desmond J Higham, Peter E Kloeden, and
Eckhard  Platen.    Comment  on  “numerical  methods  for  stochastic  differential
equations”. <span 
class="ec-lmri-10x-x-109">Physical Review E</span>, 74(6):068701, 2006.
</p>    
<p class="bibitem" ><span class="biblabel">
[11]
<span class="bibsp">   </span></span><a 
 id="XArnold1992-stochastic"></a>Ludwig Arnold. <span 
class="ec-lmri-10x-x-109">Stochastic differential equations: theory and applications</span>. Folens
Publishers, reprint edition, 1992.
</p>    
<p class="bibitem" ><span class="biblabel">
[12]
<span class="bibsp">   </span></span><a 
 id="XRisken1996"></a>Hannes  Risken.   <span 
class="ec-lmri-10x-x-109">The Fokker-Planck Equation</span>.   Springer-Verlag,  Berlin,  2nd
edition, 1996.
</p>    
<p class="bibitem" ><span class="biblabel">
[13]
<span class="bibsp">   </span></span><a 
 id="Xgardiner2004quantum"></a>Crispin Gardiner and Peter Zoller.  <span 
class="ec-lmri-10x-x-109">Quantum noise: a handbook of Markovian</span>
<span 
class="ec-lmri-10x-x-109">and  non-Markovian  quantum  stochastic  methods  with  applications  to  quantum</span>
<span 
class="ec-lmri-10x-x-109">optics</span>. Springer Science &#x0026; Business Media, 2004.
</p>    
<p class="bibitem" ><span class="biblabel">
[14]
<span class="bibsp">   </span></span><a 
 id="Xquastel2015one"></a>Jeremy Quastel and Herbert Spohn. The one-dimensional kpz equation and its
universality class. <span 
class="ec-lmri-10x-x-109">Journal of Statistical Physics</span>, 160(4):965–984, 2015.
</p>    
<p class="bibitem" ><span class="biblabel">
[15]
<span class="bibsp">   </span></span><a 
 id="Xlam1998improved"></a>Chi-Hang  Lam  and  Franklin G  Shin.      Improved  discretization  of  the
kardar-parisi-zhang equation. <span 
class="ec-lmri-10x-x-109">Physical Review E</span>, 58(5):5592, 1998.
</p>
                                                                                
                                                                                
    
<p class="bibitem" ><span class="biblabel">
[16]
<span class="bibsp">   </span></span><a 
 id="Xcrank1947practical"></a>John Crank and Phyllis Nicolson. A practical method for numerical evaluation
of  solutions  of  partial  differential  equations  of  the  heat-conduction  type.    In
<span 
class="ec-lmri-10x-x-109">Mathematical proceedings of the Cambridge philosophical society</span>, volume 43, pages
50–67. Cambridge University Press, 1947.
</p>    
</div>
 
</body> 
</html>
                                                                                


